<!DOCTYPE HTML>
<html lang="ko">
<head>
<title>Gui - Syntax &amp; Usage | AutoHotkey</title>
<meta name="description" content="The Gui command creates and manages windows and controls. 그런 창은 데이터 엔트리 폼 또는 맞춤 사용자 인터페이스에 사용할 수 있습니다." />
<meta name="ahk:equiv-v2" content="objects/Gui.htm" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>GUI</h1>

<p>창과 콘트롤을 생성하고 관리합니다. 그런 창은 데이터 엔트리 폼 또는 맞춤 사용자 인터페이스에 사용할 수 있습니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, <a href="#SubCommands">SubCommand</a> <span class="optional">, Value1, Value2, Value3</span></pre>
<p><em>SubCommand</em>, <em>Value1</em>, <em>Value2</em> 그리고 <em>Value3</em> 매개변수는 서로 의존적입니다. 그리고 그 사용법은 아래에 기술합니다.</p>

<h2 id="toc">목차</h2>
<ul>
    <li><a href="#SubCommands">부-명령어</a></li>
    <li><a href="#ControlOptions">Options for a Control (Gui Add)</a><ul>
      <li><a href="#PosSize">콘트롤의 위치 배정과 크기 변경</a></li>
      <li><a href="#Events">사용자 입력을 저장하고 그에 반응하기</a></li>
      <li><a href="#OtherOptions">콘트롤: 공통 스타일과 기타 옵션</a></li>
    </ul></li>
    <li><a href="#Labels">창 이벤트</a>: <a href="#GuiClose">GuiClose</a> | <a href="#GuiEscape">GuiEscape</a> | <a href="#GuiSize">GuiSize</a> | <a href="#GuiContextMenu">GuiContextMenu</a> | <a href="#GuiDropFiles">GuiDropFiles</a></li>
    <li><a href="#MultiWin">여러 GUI 창 만들기</a></li>
    <li><a href="#DefaultWin">GUI 이벤트, 쓰레드 그리고 서브루틴</a></li>
    <li><a href="#Navigate">키보드 항해</a></li>
    <li><a href="#Appear">창의 모습</a></li>
    <li><a href="#GenRemarks">총평</a></li>
    <li><a href="#Examples">예제</a></li>
</ul>

<h2 id="SubCommands">부-명령어</h2>
<p>For <em>SubCommand</em>, specify one of the following:</p>
<ul>
    <li><a href="#New">New</a> <span class="ver">[v1.1.04+]</span>: 새 창을 만듭니다.</li>
    <li><a href="#Add">Add</a>: 텍스트, 버튼, 또는 체크박스 같은 콘트롤을 생성합니다.</li>
    <li><a href="#Show">Show</a>: 창을 보여줍니다. 또한 창을 최대화, 최소화, 또는 이동할 수 있습니다.</li>
    <li><a href="#Submit">Submit</a>: 사용자의 입력을 저장하고 선택적으로 창을 감춥니다.</li>
    <li><a href="#Cancel">Cancel</a> / <a href="#Hide">Hide</a>: 창을 감춥니다.</li>
    <li><a href="#Destroy">Destroy</a>: 창을 삭제합니다.</li>
    <li><a href="#Font">Font</a>: 연이어 생성되는 콘트롤에 대하여 글꼴의 모양, 크기, 스타일, 그리고 색을 설정합니다.</li>
    <li><a href="#Color">Color</a>: 창과 그의 콘트롤에 대하여 배경 색을 설정합니다.</li>
    <li><a href="#Margin">Margin</a>: 콘트롤에 명시적으로 위치가 지정되어 있지 않으면 여백/공간을 설정합니다.</li>
    <li><a href="#Options">창에 대한 옵션과 스타일</a>: 창의 모습과 행위에 대하여 다양한 옵션을 설정합니다.</li>
    <li><a href="#Menu">Menu</a>: 메뉴 바를 추가하거나 제거합니다.</li>
    <li><a href="#Minimize">Minimize</a> / <a href="#Maximize">Maximize</a> / <a href="#Restore">Restore</a>: 창에 지시된 연산을 수행합니다.</li>
    <li><a href="#Flash">Flash</a>: 창과 그의 태스크바 버튼을 깜빡입니다.</li>
    <li><a href="#Default">Default</a>: 현재 쓰레드의 기본 GUI 창 이름을 변경합니다.</li>
</ul>

<h3 id="New">New <span class="ver">[v1.1.04+]</span></h3>
<p>창을 만들고 현재 쓰레드에 대하여 <a href="#Default">기본 창</a>으로 설정합니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, New <span class="optional">, Options, Title</span>
<span class="func">Gui</span>, GuiName:New <span class="optional">, Options, Title</span></pre>
<p>If <em>GuiName</em> is specified, a new GUI will be created, destroying any existing GUI with that name. Otherwise, a new unnamed and unnumbered GUI will be created.</p>
<p><em>Options</em> 메인 GUI 명령어가 지원하는 <a href="#Options">옵션</a>을 담을 수 있습니다.</p>
<p><em>Title</em>이 생략되면, 스크립트 파일의 이름이 사용됩니다.</p>
<p>이 부-명령어는 다음 약점이 따라 옵니다:</p>
<ul>
    <li>대부분의 경우 창은 요구하면 자동으로 생성됩니다. 그래서 보통 <code>Gui New</code>를 호출할 필요가 없습니다.</li>
    <li>새 창을 <em>현재 쓰레드</em>에 대하여 <a href="#Default">기본 창</a>으로 설정할 수 있지만, 비-GUI 쓰레드도 여전히 <a href="#DefaultWin">GUI 번호 1</a>을 기본값으로 설정할 수 있습니다.</li>
    <li>GUI에 이름이 없고 <a href="#Default">기본 GUI</a>가 아니면, 그의 HWND로 식별하여야 합니다. <a href="#GuiHwndOutputVar">+Hwnd<i>GuiHwnd</i></a> 옵션을 사용하여 새 창의 HWND를 <em>GuiHwnd</em>에 저장할 수 있습니다. <code>Gui, %<i>GuiHwnd</i>%:Default</code>를 사용하면 기본값으로 다른 Gui 명령어들을 그 창에 작동시킬 수 있습니다.</li>
</ul>
<p>긍정적인 면에 관하여:</p>
<ul>
    <li><code>Gui New</code>를 호출하면 스크립트가 기존의 GUI를 변경하는 것이 아니라, 새로 만든다는 것을 확신할 수 있습니다. 또한 코드를 읽는 사람들에게 (또는 미래의 여러분에게) 스크립트의 목적을 더 명료하게 보여줄 수 있습니다.</li>
    <li><code>Gui New</code>는 각 GUI에 대하여 유일한 이름 또는 번호를 고를 필요를 제거합니다. 이는 스크립트가 하나 이상의 GUI를 생성할 필요가 있을 때, 또는 다른 스크립트에 포함될 의도가 있을 때 특히 유용할 수 있습니다.</li>
    <li>GUI가 <a href="#Show">보여질</a> 때가 아니라 생성될 때 창의 제목을 설정하는 것이 종종 더 직관적인 경우가 있습니다.</li>
</ul>
<p>이름이 주어지지 않으면, 다음이 적용됩니다:</p>
<ul>
    <li><a href="#GuiClose">GuiClose</a>와 같이 특별한 <a href="#Labels">라벨</a>은 기본적으로 "Gui"를 접두사로 가집니다. 단, 옵션에서 <a href="#PlusLabel">+Label<em>Prefix</em></a>로 오버라이드하는 경우는 예외입니다.</li>
    <li>GUI기 새 쓰레드를 기동할 때, <a href="../Variables.htm#Gui">A_Gui</a>는 이름 대신에 HWND가 담깁니다.</li>
</ul>
<p class="note"><strong>주의:</strong> <span class="ver">[v1.1.08]</span> 이전에서, 이 부-명령어는 이름이 지정되면 기본 Gui를 설정하지 않았습니다.</p>

<h3 id="Add">Add</h3>
<p>콘트롤을 GUI 창에 추가합니다 (필요하면, 먼저 GUI 창 자체를 생성합니다).</p>
<pre class="Syntax"><span class="func">Gui</span>, Add, ControlType <span class="optional">, Options, Text</span></pre>
<p><em>ControlType</em>은 다음 중 하나입니다:</p>
<ul>
    <li><a href="GuiControls.htm#Text">Text</a>, <a href="GuiControls.htm#Edit">Edit</a>, <a href="GuiControls.htm#UpDown">UpDown</a>, <a href="GuiControls.htm#Picture">Picture</a></li>
    <li><a href="GuiControls.htm#Button">Button</a>, <a href="GuiControls.htm#Checkbox">Checkbox</a>, <a href="GuiControls.htm#Radio">Radio</a></li>
    <li><a href="GuiControls.htm#DropDownList">DropDownList</a>, <a href="GuiControls.htm#ComboBox">ComboBox</a></li>
    <li><a href="GuiControls.htm#ListBox">ListBox</a>, <a href="ListView.htm">ListView</a>, <a href="TreeView.htm">TreeView</a></li>
    <li><a href="GuiControls.htm#Link">Link</a>, <a href="GuiControls.htm#Hotkey">Hotkey</a>, <a href="GuiControls.htm#DateTime">DateTime</a>, <a href="GuiControls.htm#MonthCal">MonthCal</a></li>
    <li><a href="GuiControls.htm#Slider">Slider</a>, <a href="GuiControls.htm#Progress">Progress</a></li>
    <li><a href="GuiControls.htm#GroupBox">GroupBox</a>, <a href="GuiControls.htm#Tab">Tab</a>, <a href="GuiControls.htm#StatusBar">StatusBar</a></li>
    <li><a href="GuiControls.htm#ActiveX">ActiveX</a> (예, 인터넷 익스플로러 콘트롤)</li>
    <li><a href="GuiControls.htm#Custom">Custom</a></li>
</ul>
<p><em>Options</em> is a string of zero or more options, as described in the following sections:</p>
<ul>
  <li><a href="#PosSize">콘트롤의 위치 배정과 크기 변경</a></li>
  <li><a href="#Events">사용자 입력을 저장하고 그에 반응하기</a></li>
  <li><a href="#OtherOptions">콘트롤: 공통 스타일과 기타 옵션</a></li>
</ul>
<p>예를 들어:</p>
<pre>Gui, Add, Text,, 이름을 입력하십시오:
Gui, Add, Edit, vName
Gui, Show</pre>

<h3 id="Show">Show</h3>
<p>따로 <em>Options</em>에 지정하지 않으면, 이 부-명령어는 창을 보이게 만들고, (필요하면) 창 크기를 복원하고, <a href="WinActivate.htm">활성화</a> 하며, 그리고 그의 타이틀을 설정합니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Show <span class="optional">, Options, Title</span></pre>
<p><em>Title</em>이 생략되면, 이전 제목이 유지됩니다 (또는 없으면, 스크립트의 이름이 사용됩니다).</p>
<p>아래의 X, Y, W, 그리고 H 옵션을 생략하면 창의 이전 크기와 위치를 유지할 수 있습니다. 이전의 위치가 없을 경우, 아래에 언급된 X 또는/그리고 Y 옵션이 없다면 창은 두 차원 중 하나에 또는 둘 모두에 맞게 자동 중앙 정렬됩니다. 이전의 크기가 없을 경우, 창은 내용을 가진 콘트롤의 크기와 위치에 맞게 자동 조절됩니다.</p>
<p>다음 문자열이 <em>Options</em>에 존재할 수 있습니다 (각 숫자를 십진수로 지정하십시오. 십육진수가 아닙니다):</p>
<p><strong>Wn</strong>: <strong>n</strong>에 창의 클라이언트 구역의 너비 (픽셀 단위)를 지정합니다 (클라이언트 구역에서 창의 테두리, 제목 바, 그리고 <a href="#Menu">메뉴 바</a>는 제외됩니다).</p>
<p><strong>Hn</strong>: <strong>n</strong>에 창의 클라이언트 구역의 높이를 픽셀 단위로 지정합니다.</p>
<p><strong>Xn</strong>: <strong>n</strong>에 화면에서 창의 X-위치를 픽셀 단위로 지정합니다. 위치가 0이면 화면에서 가장 왼쪽에 보이는 왼쪽의 컬럼 픽셀입니다.</p>
<p><strong>Yn</strong>: <strong>n</strong>에 화면에서 Y-위치를 픽셀 단위로 지정합니다. 위치 0은 화면에서 보이는 가장 위쪽 행의 픽셀입니다.</p>
<p><strong>Center</strong>: 창을 화면에서 수평 수직으로 가운데에 정렬합니다.</p>
<p><strong>xCenter</strong>: 창을 화면에서 수평으로 중앙 정렬합니다. 예를 들어: <code>Gui, Show, xCenter y0</code>.</p>
<p><strong>yCenter</strong>: 화면에서 창을 수직으로 중앙 정렬합니다.</p>
<p id="AutoSize"><strong>AutoSize</strong>: 창의 크기를 현재 보이는 콘트롤에만 맞게 변경합니다. 이것은 새 콘트롤을 추가한 후 창의 크기를 바꿀 때, 또는 기존의 콘트롤이 크기가 바뀌거나, 숨거나, 또는 다시 나타나거나 할 때 유용합니다. 예를 들어: <code>Gui, Show, AutoSize Center</code>.</p>
<p><strong>Minimize</strong>: 창을 최소화하고 그 아래에 있는 창을 활성화 합니다.</p>
<p><strong>Maximize</strong>: 창을 최대화하고 활성화합니다.</p>
<p><strong>Restore</strong>: 창을 복구합니다. 창을 보여주고 활성화합니다.</p>
<p><strong>NoActivate</strong>: 창을 복구합니다. 창을 활성화하지 않고 보여줍니다.</p>
<p><strong>NA</strong>: 창을 활성화하지 않고 보여줍니다. 그 창이 최소화되어 있더라도, 그대로 있겠지만 아마도 z-순서는 더 높아질 것입니다 (z-순서란 알트-탭 선택자에 보여지는 순서입니다). 창이 이전에 숨어 있었으면, 이 때문에 아마도 활성 창이 비활성화되지 않았다고 할지라도 그 위에 나타날 것입니다.</p>
<p><strong>Hide</strong>: 창을 감추고 그 아래의 창을 활성화 합니다. 이것은 기능상 <a href="#Cancel">Gui Cancel</a>과 동일합니다. 단, 숨은 창을 이동하고, 크기 변경을 할 수 있고 또는 보여줄 필요 없이 새 제목을 줄 수 있다는 점은 다릅니다. 예를 들어: <code>Gui, Show, Hide x55 y66 w300 h200, New Title</code>.</p>

<h3 id="Submit">Submit</h3>
<p>각 콘트롤의 내용을 그의 <a href="#var">연관 변수</a>에 저장하고 창을 감춥니다. 단, NoHide 옵션이 있는 경우는 예외입니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Submit <span class="optional">, NoHide</span></pre>
<p><a href="GuiControls.htm#ListBoxMulti">다중-선택 ListBox</a>와 같이 여러 필드의 출력을 생산하는 콘트롤에 대하여, 그 출력은 창의 <a href="#Delimiter">현재 가름자</a>를 사용합니다. 그 창이 존재하지 않으면 -- 아마도 <a href="#Destroy">Gui Destroy</a>를 통하여 사라져 버렸다면 -- 이 부-명령어는 아무 효과가 없습니다.</p>

<div id="Cancel"><h3 id="Hide">Cancel / Hide</h3></div>
<p>그의 <a href="#var">연관 변수</a>에 콘트롤의 내용을 저장하지 않고 창을 감춥니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Cancel
<span class="func">Gui</span>, Hide</pre>
<p>그 창이 존재하지 않으면 -- 아마도 <a href="#Destroy">Gui Destroy</a>를 통하여 사라져 버렸다면 -- 이 부-명령어는 아무 효과가 없습니다.</p>

<h3 id="Destroy">Destroy</h3>
<p>창과 그의 모든 콘트롤을 (존재하면) 제거하고, 상응하는 메모리와 시스템 자원을 풀어줍니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Destroy</pre>
<p>나중에 스크립트가 그 창을 다시 만들면, 글꼴과 색깔 같은 창의 모든 특성은 (마치 창이 존재하지 않았던 것처럼) 기본 값으로 시작합니다. 이 부-명령어를 사용하지 않더라도, 모든 GUI 창은 스크립트가 종료할 때 자동으로 파괴됩니다.</p>

<h3 id="Font">Font</h3>
<p>창에 추가된 콘트롤에 대하여 이 시점부터 글꼴 모양, 크기, 스타일 그리고/또는 색을 설정합니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Font <span class="optional">, Options, FontName</span></pre>
<p>예를 들어:</p>
<pre>Gui, Font, s10, Verdana  <em>; Set 10-point Verdana.</em></pre>
<p>마지막 매개변수 두 개를 생략하면 글꼴을 시스템의 기본 GUI 모양, 크기 그리고 색으로 복구할 수 있습니다.</p>
<p><em>FontName</em>은 글꼴 이름입니다. 예를 들어 <a href="../misc/FontsStandard.htm">글꼴 테이블</a>에서 고를 수 있는 이름입니다. <em>FontName</em>을 생략하거나 시스템에 존재하지 않으면, 이전의 글꼴 모양이 사용됩니다 (또는 없으면, 시스템의 기본 GUI 모양이 사용됩니다). 선호하는 글꼴이 없다고 할지라도 여러 시스템에서 GUI 창이 비슷한 글꼴을 가지게 만드는 데 유용합니다. 예를 들어, 다음 명령어를 순서대로 사용하면, Verdana 글꼴이 Arial보다 우선하고, Arial은 MS Sans Serif보다 우선 순위가 주어집니다:</p>
<pre>Gui, Font,, MS Sans Serif
Gui, Font,, Arial
Gui, Font,, Verdana  <em>; 선호하는 글꼴.</em></pre>
<p><em>Options</em> 매개변수가 비어 있으면, 이전의 글꼴 속성이 사용됩니다. 그렇지 않으면, 다음 옵션 기호들을 대신 지정하십시오:</p>
<p><strong>C</strong>: 컬러 이름 (<a href="Progress.htm#colors">컬러 차트</a> 참조) 또는 RGB 값 -- 또는 단어 Default를 지정하면 시스템의 기본 컬러에 의존할 수 있습니다 (대부분의 시스템에서 검정색). 예를 들어: <code>cRed</code>, <code>cFFFFAA</code>, <code>cDefault</code>. 주의: <a href="GuiControls.htm#Button">Buttons</a>은 맞춤 색을 준수하지 않습니다. 또한, C 옵션을 포함함으로써 현재 색 말고 글꼴 색을 가지고 콘트롤을 개별적으로 만들 수 있습니다. 예를 들어: <code>Gui, Add, Text, cRed, My Text</code>.</p>
<p><strong>S</strong>: 크기 (포인트 단위). 예를 들어: <code>s12</code> (십진수로 지정하십시오. 십육진수가 아닙니다)</p>
<p><strong>W</strong>: 두께 (두꺼움), 1과 1000 사이의 숫자입니다 (400은 보통이고 700이면 볼드체입다). 예를 들어: <code>w600</code> (십육진수가 아니라 십진수로 지정하십시오)</p>
<p>다음 단어들을 지원합니다: <strong>bold</strong>, <em>italic</em>, <s>strike</s>, <u>underline</u>, 그리고 norm. <em>Norm</em>은 글꼴을 보통 두께와/무게로 돌려줍니다. 그리고 이탤릭, 취소선, 그리고 밑줄을 끕니다 (그러나 기존의 색과 크기는 유지합니다). norm을 사용하여 모든 속성을 끈 다음 선택적으로 하나씩 켜는 것이 가능합니다. 예를 들어, <code>norm italic</code>을 지정하면 글꼴을 정상으로 만든 다음 이택릭으로 설정합니다.</p>
<p>여러 옵션을 지정하려면, 각 옵션 사이에 스페이스를 포함시키십시오. 예를 들어: <code>cBlue s12 bold</code>.</p>
<p>스크립트가 <a href="#MultiWin">여러 GUI 창</a>을 생성하면, 각 창마다 콘트롤을 더 만들 목적으로 자신의 "현재 글꼴"을 기억합니다.</p>
<p>관련하여, 운영 체제는 사용자가 글꼴, 컬러, 또는 아이콘을 고르도록 표준 대화상자를 제공합니다. 이런 대화상자는 <a href="DllCall.htm">DllCall()</a>을 통하여 보여줄 수 있습니다. 다음에 예시합니다: <a href="https://github.com/majkinetor/mm-autohotkey/tree/master/Dlg">GitHub</a>.</p>
<p id="fontq"><strong>Q</strong>: <span class="ver">[AHK_L 19+]:</span> 텍스트 가공 품질. 예를 들어: <code>q3</code>. Q 다음에 다음 테이블에 있는 숫자가 따라와야 합니다:</p>
<table class="info">
    <tr>
        <th>숫자</th>
        <th abbr="Constant">Windows Constant</th>
        <th abbr="설명">설명</th>
    </tr>
    <tr>
        <td>0</td>
        <td>DEFAULT_QUALITY</td>
        <td>글꼴의 모습은 상관하지 않습니다.</td>
    </tr>
    <tr>
        <td>1</td>
        <td>DRAFT_QUALITY</td>
        <td>PROOF_QUALITY를 사용할 때에 비해 글꼴의 모습이 덜 중요합니다.</td>
    </tr>
    <tr>
        <td>2</td>
        <td>PROOF_QUALITY</td>
        <td>논리적 글꼴 속성에 정확하게 부합하는 것보다 글꼴의 문자 품질이 더 중요합니다.</td>
    </tr>
    <tr>
        <td>3</td>
        <td>NONANTIALIASED_QUALITY</td>
        <td>글꼴을 부드럽게 외곽선 처리하지 않습니다.</td>
    </tr>
    <tr>
        <td>4</td>
        <td>ANTIALIASED_QUALITY</td>
        <td>글꼴이 지원하면 글꼴을 부드럽게 외곽선 처리합니다. 그리고 글꼴의 크기는 너무 작지도 너무 크지도 않습니다.</td>
    </tr>
    <tr>
        <td>5</td>
        <td>CLEARTYPE_QUALITY</td>
        <td>Windows XP 이후: 설정하면, ClearType 외곽선 처리 방법을 사용하여 텍스트를 가공합니다.</td>
    </tr>
</table>
<p>이런 값들의 의미에 관한 더 자세한 정보는 <a href="http://msdn.microsoft.com/ko-kr/library/dd183499.aspx">MSDN: CreateFont</a>를 참조하십시오.</p>
<p>고품질 설정이 보통 기본값이기 때문에, 이 특징은 주로 앤티-엘리어싱을 끄면 텍스트가 더 선명하게 보일 경우에 사용됩니다.</p>

<h3 id="Color">Color</h3>
<p>창의 그의 콘트롤의 배경색을 설정합니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Color <span class="optional">, WindowColor, ControlColor</span></pre>
<p><em>WindowColor</em>는 GUI 창 자체에 대한 배경색으로 사용됩니다. <em>ControlColor</em>는 창에 존재하는 그리고 존재할 모든 콘트롤에 적용됩니다 (그렇지만 어떤 유형의 콘트롤의 맞춤 색을 지원하지 않습니다). <em>ControlColor</em>을 처음에는 <a href="ListView.htm">ListViews</a>와 <a href="TreeView.htm">TreeViews</a>가 준수하지만, 연이어서 <em>ControlColor</em>를 변경하면 영향을 미치지 않습니다. 그런 경우, <code>GuiControl +BackgroundFF9977, MyListView</code>를 사용하여 명시적으로 색을 변경하십시오.</p>
<p>두 매개변수 중 하나라도 그대로 두면 현재 색이 유지됩니다. 그렇지 않으면, 16가지 기본 <a href="Progress.htm#colors">HTML 컬러 이름</a> 또는6-자리 RGB 컬럼 이름 (0x 접두사는 선택적), 또는 단어 Default를 지정하면 그의 기본 값으로 돌아갈 수 있습니다. 예를 들어: <code>Silver</code>, <code>FFFFAA</code>, <code>0xFFFFAA</code>, <code>Default</code>.</p>
<p>기본값으로, 창의 배경 색은 시스템의 버튼색입니다. 그리고 콘트롤의 배경색은 시스템의 기본 창의 색입니다 (보통 흰색).</p>
<p><a href="#Menu">메뉴 바</a>와 그의 하위 메뉴 색은 다음 예제와 같이 바꿀 수 있습니다: <code><a href="Menu.htm">Menu</a>, MyMenuBar, Color, White</code>.</p>
<p>배경을 투명하게 만들려면 <a href="WinSet.htm#TransColor">WinSet TransColor</a>를 사용하십시오. However, if you do this without first having assigned a custom window color via <a href="#Color">Gui Color</a>, buttons will also become transparent. 이를 피하려면, 먼저 맞춤 색을 할당한 다음 그 색을 투명하게 만드십시오. 예를 들어:</p>
<pre>Gui, Color, EEAA99
Gui +LastFound  <em>; GUI 창을 <a href="../misc/WinTitle.htm#LastFoundWindow">마지막 발견 창</a>으로 만들어 아래 줄에 사용합니다.</em>
WinSet, TransColor, EEAA99</pre>
<p>또 테두리와 제목 바를 투명 배경을 가진 창으로부터 제거하려면, 창을 투명하게 <strong>만든 후에</strong> 다음과 같이 하십시오:</p>
<pre>Gui -Caption  <em>; 또는 <a href="#DefaultWin">기본 창</a>이 아니라면 <i>Gui, GuiName:-Caption</i>을 사용하십시오.</em></pre>
<p>이 페이지의 하단 근처에 위를 시연해주는 화면-위 디스플레이 (OSD)의 예제가 있습니다.</p>

<h3 id="Margin">Margin</h3>
<p>Sets the number of pixels of space to leave at the left/right and top/bottom sides of the window when auto-positioning any control that lacks an explicit <a href="#XY">X or Y coordinate</a>.</p>
<pre class="Syntax"><span class="func">Gui</span>, Margin <span class="optional">, X, Y</span></pre>
<p>또, 자동 배치된 콘트롤들을 서로 분리할 수직 수평 거리를 결정하기 위해 여백이 사용됩니다. 마지막으로, (명시적으로 크기가 주어지지 않을 때) 처음 <a href="#Show">Gui Show</a>를 사용할 때 창의 크기를 계산하기 위해 여백이 고려됩니다.</p>
<p><code>Gui, Margin</code>은 <a href="#Default">기본 창</a>에만 영향을 주는 반면에, <code>Gui, Name:Margin</code>는 <a href="#MultiWin">이름붙은 창</a>에만 영향을 미칩니다. 이 명령어가 사용되지 않으면, 첫 콘트롤이 창에 추가될 때, 그 창은 현재 선택된 <a href="#Font">글꼴</a>의 크기에 비례하여 사방에 기본 여백을 얻습니다 (상하로 글꼴 높이의 0.75 배 그리고 좌우로 글꼴 높이의 1.25 배).</p>
<p>콘트롤을 추가하는 동안 여백을 바꿀 수 있지만, 그 때의 변경은 이미 존재하는 콘트롤에는 영향을 주지 않고 앞으로 추가될 콘트롤에만 영향을 줍니다. 마지막으로, Xㄴ Y가 비어 있으면 상응하는 여백은 바뀌지 않습니다.</p>

<h3 id="Options">창에 대한 옵션과 스타일</h3>
<p>GUI 명령어 바로 다음에 여러 옵션을 지정할 수 있습니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, +/-Option1 +/-Option2 ...</pre>
<p>수행성능의 이유로, 모든 옵션을 한 줄에서 설정하는 것이 더 좋습니다. 그리고 창을 만들기 전에 (즉, <a href="#Add">Gui Add</a>와 같은 다른 하위-명령어들을 사용하기 전에) 그렇게 하는 편이 더 좋습니다.</p>
<p>이 명령어의 효과는 점증적입니다. 즉, 명시적으로 지정된 설정만 변경합니다. 다른 설정들은 그대로 둡니다.</p>
<p>플러스 사인을 지정하면 옵션을 추가할 수 있고 마이너스 사인은 제거할 수 있습니다. 예를 들어:</p>
<pre>Gui +Resize -MaximizeBox  <em>; <a href="#DefaultWin">기본</a> GUI 창의 설정을 변경합니다.</em>
Gui <strong>MyGui:</strong>+Resize -MaximizeBox  <em>; 이름이 <i>MyGui</i>인 GUI의 설정을 변경합니다.</em></pre>
<p><strong>AlwaysOnTop</strong>: 창을 항상 다른 모든 창 위에 있도록 만듭니다. 이 효과는 <a href="WinSet.htm#AlwaysOnTop">WinSet AlwaysOnTop</a>과 같습니다.</p>
<p><strong>Border</strong>: 가는-줄 테두리를 창 둘레에 두릅니다. 이것은 일반적이지 않습니다.</p>
<p><strong>Caption</strong> (기본으로 존재): 제목 바와 두꺼운 창 테두리/모서리를 제공합니다. 창에서 캡션을 제거할 때 <a href="WinSet.htm#TransColor">WinSet TransColor</a>를 사용하고 있다면, TransColor를 설정한 후에 제거하십시오.</p>
<p id="Delimiter"><strong>Delimiter</strong>: 파이프 (|) 말고 창이 사용해야 하는 필드 가름자를 지정합니다. 이 가름자는 콘트롤의 내용이 <a href="#Add">Gui Add</a>를 통하여 추가되거나, <a href="GuiControl.htm">GuiControl</a>를 통하여 변경되거나, 또는 <a href="#Submit">Gui Submit</a>나 <a href="GuiControlGet.htm">GuiControlGet</a>를 통하여 열람될 때 사용됩니다. 단어 Delimiter 다음에 바로 문자 하나를 지정하십시오. 예를 들어, <code>Gui +Delimiter`n</code>은 라인피드 문자를 사용합니다. 이는 <a href="../Scripts.htm#continuation">계속 섹션</a>에 특히 적절할 수 있습니다. 비슷하게, <code>Gui +Delimiter|</code>는 기본 가름자로 되돌아 갑니다. 스페이스나 탭을 사용하려면, <code>Gui +DelimiterSpace</code> 또는 <code>Gui +DelimiterTab</code>을 지정하십시오. 구분자가 바뀌면, 이 특정한 창위에서 작동하는 기존의 그리고 잇따르는 모든 <a href="../misc/Threads.htm">쓰레드</a>에 영향을 줍니다.</p>
<p><strong>Disabled</strong>: 창을 비활성화 합니다. 사용자가 그의 콘트롤과 상호작용하지 못하게 막습니다. 이는 종종 다른 창을 소유한 창에 사용됩니다 (<a href="#Owner">Owner</a> 참조).</p>
<p id="DPIScale"><strong>DPIScale</strong> <span class="ver">[v1.1.11+]</span>: <code>Gui -DPIScale</code>를 사용하면 DPI 스케일링을 끌 수 있습니다. 이는 기본 값으로 켜져 있습니다. 비-표준 DPI 설정의 시스템에 DPI 스케일링이 활성화 되면, 이 Gui 부-명령어는 자동으로 좌표와 크기를 조절하여 콘트롤에 대략 비슷하게 보이는 크기를 줍니다 (그러나 해상도는 더 높습니다). 예를 들어, DPI가 144 (150%)이면, <code>Gui Show, w100</code>는 Gui를 150 픽셀 너비로 만들지만, <a href="../Variables.htm#GuiWidth">A_GuiWidth</a>는 여전히 100을 돌려줍니다. <a href="../Variables.htm#ScreenDPI">A_ScreenDPI</a>에는 시스템의 현재 DPI가 담겨 있습니다.</p>
<p>DPI scaling only applies to Gui sub-commands, so coordinates coming directly from other sources such as ControlGetPos or WinGetPos will not work. There are a number of ways to deal with this:</p>
<ul>
    <li>Avoid using hard-coded coordinates wherever possible. For example, use the <a href="#xp">xp</a>, <a href="#xs">xs</a>, <a href="#xm">xm</a> and <a href="#PosPlusMargin">x+m</a> options for positioning controls and specify height in <a href="#R">rows of text</a> instead of pixels.</li>
    <li>Enable (<code>Gui +DPIScale</code>) and disable (<code>Gui -DPIScale</code>) scaling on the fly, as needed. Changing the setting does not affect positions or sizes which have already been set.</li>
    <li>Manually scale the coordinates. For example, <code>x*(A_ScreenDPI/96)</code> converts x from logical/Gui coordinates to physical/non-Gui coordinates.</li>
</ul>
<p id="GuiHwndOutputVar"><strong>Hwnd</strong><em>OutputVar</em> <span class="ver">[v1.1.04+]:</span> 이 옵션은 <em>OutputVar</em>에 GUI의 창 핸들 (HWND)을 저장합니다. 예를 들어: <code>Gui +HwndMyGuiHwnd</code>. 함수 안에서 <em>MyGuiHwnd</em>는 <a href="../Functions.htm#DynVar">함수적 동적 변수</a>로 취급됩니다. GUI의 HWND는 종종 <a href="PostMessage.htm">PostMessage</a>, <a href="PostMessage.htm">SendMessage</a>, 그리고 <a href="DllCall.htm">DllCall()</a>와 함께 사용됩니다. 또한 <a href="../misc/WinTitle.htm#ahk_id">ahk_id WinTitle</a>로 또는 GUI 이름 대신에 직접적으로 사용되기도 합니다; 예를 들어, <code>Gui %MyGuiHwnd%:Destroy</code>.</p>
<p id="PlusLabel"><strong>Label</strong> <span class="ver">[v1.0.44.09+]:</span> 이 창의 <a href="#Labels">특별 라벨</a>에 맞춤 이름을 설정합니다. 예를 들어, <code>Gui MyGui:+LabelMyGui_On</code>는 MyGuiGuiClose와 MyGuiGuiSize 대신에 라벨 MyGui_OnClose와 MyGui_OnSize 를 사용합니다. 다른 말로 하면, 모든 <a href="#Labels">특수 라벨</a>의 이름에 문자열 "MyGuiGui"는 "MyGui_On"으로 교체됩니다. 이는 또한 여러 창이 같은 라벨 세트를 공유하도록 만드는 데 사용할 수도 있습니다 (이 경우 스크립트는 <a href="../Variables.htm#Gui">A_Gui</a>에 문의해 어느 창이 서브루틴을 기동했는지 결정할 수 있습니다).</p>
<p id="LastFound"><strong>LastFound</strong>: <a href="../misc/WinTitle.htm#LastFoundWindow">마지막 발견 창</a>이 될 창을 설정합니다 (그렇지만 <a href="#DefaultWin">Gui 쓰레드</a> 안에서는 자동으로 처리되기 때문에 불필요 합니다). 이 덕분에 <a href="WinSet.htm">WinSet</a>과 같은 명령어들은 숨어 있을 경우에도 창을 처리할 수 있습니다 (즉, <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>는 필요하지 않습니다). 이것은 특히 보여주기 전에 창의 특성을 바꾸는 데 유용합니다. 예를 들어:</p>
<pre>Gui +LastFound
WinSet, TransColor, %CustomColor% 150
Gui Show</pre>
<p id="LastFoundExist"><strong>LastFoundExist</strong> <span class="ver">[v1.0.43.09+]:</span> 다른 옵션과 다르게, LastFoundExist는 같은 줄에 다른 연산이 없을 경우에만 인지됩니다. <em>+LastFoundExist</em>는 <em>+LastFound</em>와 같습니다. 단, 창이 아직 존재하지 않을 경우에도 생성되지 않는다는 점은 다릅니다. 주요 사용법은 특정 GUI 창이 존재하는지 탐지하는 것입니다. 예를 들어:</p>
<pre>Gui MyGui:+LastFoundExist
if WinExist()
    MsgBox GUI "MyGui" already exists.</pre>
<p><strong>MaximizeBox</strong>: 최대화 버튼을 제목 바에 활성화합니다. 이것은 또 아래의 <em>Resize</em>의 일부에 포함될 수도 있습니다.</p>
<p><strong>MinimizeBox</strong> (기본 값으로 보여줌): 최소화 버튼을 제목 바에 활성화 합니다.</p>
<p id="MinSize"><strong>MinSize</strong> 그리고 <strong>MaxSize</strong> <span class="ver">[v1.0.44.13+]:</span> 창의 최대 최소 크기를 결정합니다. 예를 들어, 사용자가 그의 모서리를 끌어 크기를 바꿀 때, 단어 <em>MinSize</em> 그리고/또는 <em>MaxSize</em>를 앞에 접두사 없이 지정하면 창의 현재 크기를 한계 값으로 사용할 수 있습니다 (창에 현재 크기가 없으면, <a href="#Show">Gui Show</a>를 맨 처음 사용했을 때의 크기를 사용합니다). 대안으로, 너비와 X, 다음에 높이를 사용할 수 있습니다; 예를 들어: <code>Gui +Resize +MinSize640x480</code>. 차원은 픽셀 단위입니다. 그리고 창의 클라이언트 구역을 지정합니다 (이 구역에서 테두리, 제목 바, 그리고 <a href="#Menu">메뉴 바</a>를 제외됩니다). 각 숫자를 십진수로 지정하십시오. 십육진수가 아닙니다.</p>
<p>너비 또는 높이를 생략하면 그대로 둘 수 있습니다 (예, <code>+MinSize640x</code> 또는 <code>+MinSizex480</code>). 게다가, Min/MaxSize는 여러 번 지정해 한 차원에는 창의 현재 크기를 사용하고 다른 차원에는 명시적인 크기를 사용할 수 있습니다. 예를 들어, <code>+MinSize +MinSize640x</code>는 높이에 창의 현재 크기를 사용하고 너비에 640을 사용합니다.</p>
<p><em>MinSize</em> 그리고 <em>MaxSize</em>가 사용되지 않으면, 운영 체제의 기본 값이 사용됩니다 (비슷하게, <code>Gui -MinSize -MaxSize</code>를 사용하면 기본 값으로 되돌아 갈 수 있습니다).</p>
<p class="note"><strong>주의</strong>: 창은 <a href="#Resize">+Resize</a>이 있어야 사용자에게 크기 변경을 허용할 수 있습니다.</p>
<p id="OwnDialogs"><strong>OwnDialogs</strong>: <code>Gui +OwnDialogs</code>는 각 <a href="../misc/Threads.htm">쓰레드</a>마다 지정해야 합니다 (예를 들어 ButtonOK 서브루틴). 연이어 보여지는 <a href="MsgBox.htm">MsgBox</a>, <a href="InputBox.htm">InputBox</a>, <a href="FileSelectFile.htm">FileSelectFile</a>, 그리고 <a href="FileSelectFolder.htm">FileSelectFolder</a> 대화상자는 그 창이 소유해야 합니다. 그런 대화상자는 모달이 되는데, 취소하기 전까지 사용자가 그 GUI 창과 상호작용할 수 없다는 뜻입니다. 대조적으로, <a href="ToolTip.htm">ToolTip</a>, <a href="Progress.htm">Progress</a>, 그리고 <a href="Progress.htm">SplashImage</a> 창은 소유되어 있는 경우에도 모달이 되지 않습니다; 그냥 그의 소유자보다 언제나 위에 있을 뿐입니다. 어느 경우든, 소유된 대화상자 또는 창은 소유한 GUI 창이 <a href="#Destroy">파괴되면</a> 자동으로 파괴됩니다.</p>
<p>전형적으로 이 설정을 다시 끌 필요는 없습니다. 왜냐하면 다른 <a href="../misc/Threads.htm">쓰레드</a>에는 영향을 주지 않기 때문입니다. 그렇지만, 쓰레드가 소유한 창과 소유된 대화상자를 모두 보여줄 필요가 있다면, 이 설정을 <code>Gui -OwnDialogs</code>를 통하여 끄면 됩니다.</p>
<p>창이름 접두사가 지정되지 않으면 -- 예를 들어 <code>Gui MyGui:+OwnDialogs</code> 대신에 <code>Gui +OwnDialogs</code>와 같이 사용하면 -- <a href="#DefaultWin">쓰레드의 기본 창</a>이 그 대화상자를 소유합니다.</p>
<p id="Owner"><strong>Owner</strong>: <em>+Owner</em>를 사용하면 그 창을 또다른 창에게 귀속시킬 수 있습니다. 소유된 창은 기본으로 태스크바 버튼이 없습니다. 그리고 보이면 언제나 그의 소유 창 위에 나타납니다. 또한 그의 소유 창이 파괴될 때 자동으로 파괴됩니다. <em>+Owner</em>는 창의 소유자를 생성한 <u>후에</u> 사용해야 합니다. 그러나 <span class="ver">[v1.1.05]</span> 이후는 소유된 창이 생성되기 전 또는 후에 사용해도 됩니다. <em>+Owner</em>를 사용하는 방법은 다음 예제와 같이 두 가지가 있습니다:</p>
<pre>Gui, MyGui:+OwnerMyOtherGui  <em>; <i>MyGui</i>를 <i>MyOtherGui</i>에 귀속시킵니다.</em>
Gui, MyGui:+Owner  <em>; <i>MyGui</i>를 <a href="Menu.htm#MainWindow">스크립트의 메인 창</a>에 귀속시켜 태스크바 버튼이 나타나지 못하도록 방지합니다.</em></pre>
<p><span class="ver">[v1.1.03+]:</span> <code>+Owner</code> 다음에 바로 기존의 Gui 번호나 <a href="#Name">이름</a> 또는 최상위 수준 창의 <a href="WinGet.htm#ID">HWND</a>가 따라올 수 있습니다.</p>
<p class="note"><strong>호환성 주의</strong>: <span class="ver">[v1.1.03]</span> 이후로, <code>+Owner</code>는 WS_CHILD 스타일을 제거하고 WS_POPUP 스타일을 설정합니다. Gui의 부모 창을 설정하려면, 스크립트는 <code>+Parent</code> 옵션을 사용하거나, 아니면 <code>+Owner</code> 옵션을 <em>사용한 후에</em> 적절한 스타일을 오버라이드 해야합니다.</p>
<p>소유된 창 중 하나가 보이는 동안 소유 창과 사용자가 상호작용하지 못하도록 방지하려면, <code>Gui +Disabled</code>를 통하여 소유 창을 비활성화 하십시오. 나중에 (소유된 창을 취소하거나 소유된 창이 파괴되는 순간), <code>Gui -Disabled</code>를 통하여 소유 창을 다시 활성화 하십시오. 취소/파괴 전에 이렇게 하십시오. 그래야 소유 창이 자동으로 다시 활성화 됩니다.</p>
<p id="Parent"><strong>Parent</strong> <span class="ver">[v1.1.03+]</span>: <code>+Parent</code> 다음에 기존의 Gui 번호나 <a href="#Name">이름</a> 또는 창이나 콘트롤의 <a href="WinGet.htm#ID">HWND</a>를 지정하면 이 창의 부모 창으로 사용할 수 있습니다. 그 Gui를 다시 최상위 수준 창으로 바꾸려면, <code>-Parent</code>를 사용하십시오. 이 옵션은 창이 생성된 후에도 작동합니다.</p>
<p id="Resize"><strong>Resize</strong>: 창의 크기를 변경 가능하도록 만듭니다. 그리고 그의 최대화 버튼을 제목 바에 활성화 합니다. 최대화 버튼의 활성화를 피하려면, <code>+Resize -MaximizeBox</code>를 지정하십시오.</p>
<p><strong>SysMenu</strong> (기본으로 존재): <code>-SysMenu</code> (마이너스 SysMenu)를 지정하면 시스템 메뉴와 아이콘을 창의 좌상 모서리에서 생략할 수 있습니다. 뿐만 아니라 제목 바의 최대, 최소, 그리고 닫기 버튼도 생략됩니다.</p>
<p id="Theme"><strong>Theme</strong>: <code>-Theme</code>를 지정하면, 그 다음에 창에 생성되는 콘트롤은 모두 Windows XP 이상에서 고전 테마의 모습을 가집니다. 나중에 추가로 현재 테마를 준수하는 콘트롤을 생성하려면, <code>+Theme</code>를 통하여 다시 원래대로 바꿀 수 있습니다.</p>
<p class="note"><strong>주의</strong>: Theme 옵션은 Windows XP보다 오래된 운영 체제에 작동하지 않으며, XP 자체에도 고전 테마가 있으면 아무 효과가 없습니다.</p>
<p>마지막으로, 이 설정은 콘트롤에 개별적으로 바꿀 수 있습니다. 생성될 때 그의 옵션에<code>+Theme</code> 또는 <code>-Theme</code>을 지정하면 됩니다.</p>
<p><strong>ToolWindow</strong>: 좁은 제목 바를 제공하지만, 태스크바 버튼은 없습니다. This always hides the maximize and minimize buttons, regardless of whether the <a href="../misc/Styles.htm#WS_MAXIMIZEBOX">WS_MAXIMIZEBOX</a> and <a href="../misc/Styles.htm#WS_MINIMIZEBOX">WS_MINIMIZEBOX</a> styles are present.</p>
<p><strong>(Unnamed Style)</strong>: 플러스나 마이너스 사인 다음에 바로 십진 또는 십육진 <a href="../misc/Styles.htm">스타일 번호</a>를 지정하십시오.</p>
<p><strong>(Unnamed ExStyle)</strong>: 플러스나 마이너스 사인 다음에 바로 기호 E 그리고 십진 또는 십육진 확장 스타일 번호를 지정하십시오. 예를 들어, <code>+E0x40000</code>는 WS_EX_APPWINDOW 스타일을 추가합니다. 이 스타일은 창에 태스크바 버튼을 제공합니다. For other extended styles not documented here (since they are rarely used), see <a href="https://docs.microsoft.com/ko-kr/windows/win32/winmsg/extended-window-styles">Extended Window Styles | Microsoft Docs</a> for a complete list.</p>

<h3 id="Menu">Menu</h3>
<p>메뉴 바를 창에 추가합니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Menu <span class="optional">, MenuName</span></pre>
<p><a href="Menu.htm">Menu</a> 명령어를 사용하면 이 목적으로 평범한 메뉴를 만들 수 있습니다. 예를 들어:</p>
<pre>Menu, FileMenu, Add, &amp;Open<a href="../misc/EscapeChar.htm">`t</a>Ctrl+O, MenuFileOpen  <em>; Ctrl+O에 관한 것은 아래의 논평을 참조하십시오.</em>
Menu, FileMenu, Add, E&amp;xit, MenuHandler
Menu, HelpMenu, Add, &amp;About, MenuHandler
Menu, MyMenuBar, Add, &amp;File, :FileMenu  <em>; 위에서 생성한 두 개의 하위 메뉴를 부착합니다.</em>
Menu, MyMenuBar, Add, &amp;Help, :HelpMenu
Gui, Menu, MyMenuBar</pre>
<p>위의 첫 줄에, <code>&amp;Open</code> 다음에 (그 사이에 탭 문자) <code>Ctrl+O</code>가 따라 오는 것을 주목하십시오. 사용자가 메뉴 항목을 선택하는 대신 누를 키보드 단축키를 가리킵니다. <span class="ver">[v1.1.04+]:</span> 단축 키가 Ctrl, Alt 그리고 Shift와 같은 표준 수식 키 이름만 사용하면, GUI에 대하여 자동으로 <em>키보드 단축키</em>로 등록됩니다. 식별 키가 없는 단일-문자 단축키는 대소문자를 구별하고 IME 또는 <kbd>Alt</kbd>+NNNN 같은 비정상정인 수단으로 촉발시킬 수 있습니다.</p>
<p>특정 키 조합이 자동으로 작동하지 않으면, <a href="_IfWinActive.htm">문맥-감지 핫키</a>를 사용하는 것이 필요할 수 있습니다. 그렇지만, 그런 핫키는 전형적으로 <a href="Send.htm">Send</a>로 촉발되지 않으며 표준 키보드 단축키보다 다른 스크립트와 간섭을 일으킬 가능성이 더 높습니다.</p>
<p>창의 현재 메뉴 바를 제거하려면, <code>Gui Menu</code>를 사용하십시오 (즉, 마지막 매개변수를 생략하십시오).</p>
<p>메뉴가 일단 메뉴 바로 사용된 적이 있다면, 팝업 메뉴나 하위메뉴로 사용해서는 안됩니다. 왜냐하면 메뉴 바는 내부적으로 다른 형식을 요구하기 때문입니다 (그렇지만, 이 제한은 메뉴 바 자체에만 적용되지, 그의 하위 메뉴에는 적용되지 않습니다). 이를 우회할 필요가 있다면, 메뉴 바로 사용할 메뉴를 하나 만들고 다른 목적으로 사용할 메뉴를 하나 더 똑 같이 만드십시오.</p>
<p>현재 메뉴 바로 사용중인 메뉴 바에 Delete와 DeleteAll과 같이 파괴적인 <a href="Menu.htm">메뉴 부-명령어</a>를 사용하는 것은 지원하지 않으며 그러면 에러 대화상자가 나타납니다 (단, <a href="Menu.htm">UseErrorLevel</a>가 겨져 있는 경우는 예외입니다). 그런 식으로 변경하려면 다음 단계를 따르십시오: 1) <code>Gui Menu</code>를 통하여 메뉴 바를 떼어냅니다 (즉, <em>MenuName</em>을 생략하십시오); 2) 파괴합니다; 3) <code>Gui, Menu, MyMenuBar</code>를 통하여 메뉴 바를 다시 부착합니다.</p>

<div id="Restore"><div id="Maximize"><h3 id="Minimize">Minimize / Maximize / Restore</h3></div></div>
<p>창을 (필요하면) 다시 보여준 다음 거기에 지정된 연산을 수행합니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Minimize
<span class="func">Gui</span>, Maximize
<span class="func">Gui</span>, Restore</pre>
<p>그 창이 존재하지 않으면 -- 아마도 <a href="#Destroy">Gui Destroy</a>를 통하여 사라져 버렸다면 -- 이 부-명령어는 아무 효과가 없습니다.</p>

<h3 id="Flash">Flash</h3>
<p>태스크바의 창 버튼을 깜빡입니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, Flash <span class="optional">, Off</span></pre>
<p>창 제목 바와 태스크바 바튼의 색을 뒤집어 깜밖입니다. 선택적인 단어 OFF 는 제목 바와 태스크 바 버튼이 원래의 색으로 돌아오도록 만듭니다 (그러나 실제 행위는 OS 버전에 따라 달라질 수 있습니다). 아래의 예제에서, 창은 세 번 깜빡입니다. 왜냐하면 깜빡임 한 쌍 마다 색이 뒤집어지고 다음 원래의 모습으로 복구되기 때문입니다:</p>
<pre>Loop 6
{
    Gui Flash
    Sleep 500  <em>; 이 값은 굉장히 민감합니다; 이 값을 바꾸면 예상 못한 행위를 야기할 수 있습니다.</em>
}</pre>

<h3 id="Default">Default</h3>
<p><a href="../misc/Threads.htm">현재 쓰레드</a>의 기본 <a href="#MultiWin">GUI 창 이름</a>을 바꿉니다.</p>
<pre class="Syntax"><span class="func">Gui</span>, GuiName:Default</pre>
<p>이 이름은 창 이름이 <a href="GuiControl.htm">GuiControl</a>, <a href="GuiControlGet.htm">GuiControlGet</a>, 그리고 Gui 명령어 자체에 지정되어 있지 않으면 사용됩니다. 다음 예제에서, 기본 창 이름은 "MyGui"로 바뀝니다: <code>Gui MyGui:Default</code>. 기본 창에 관한 더 자세한 정보는 <a href="#DefaultWin">쓰레드의 기본 창</a>을 참조하십시오.</p>
<p><span class="ver">[v1.1.03+]:</span> <em>GuiName</em> can be the <a href="#GuiHwndOutputVar">HWND</a> of one of the script's GUI windows. If the window has a name, it becomes the default name and remains so even after the window itself is destroyed. If the window has no name, the default name reverts to 1 when the window is destroyed.</p>
<p><span class="ver">[v1.1.23+]:</span> The built-in variable <strong>A_DefaultGui</strong> contains the name or number of the default GUI.</p>

<h2 id="ControlOptions">Options for a Control (Gui Add)</h2>
<h3 id="PosSize">콘트롤의 위치 배정과 크기 변경</h3>
<p class="note"><strong>주의:</strong> 이 섹션에서 기술하는 옵션들은 간단한 레이아웃에 적당하지만, Rajat의 SmartGUI Creator를 사용하는 편이 더 쉬울 수 있습니다. 왜냐하면 완전히 눈으로 볼 수 있기 때문입니다; 즉,, "눈에 보이는 대로 얻습니다". SmartGUI Creator는 무료이고 <a href="https://www.autohotkey.com/docs/SmartGUI/">www.autohotkey.com/docs/SmartGUI/</a>으로부터 내려 받을 수 있습니다</p>
<p><em>Options</em>으로부터 어떤 차원 그리고/또는 좌표가 생략되면, 그 콘트롤은 이전 콘트롤에 상대적으로 위치가 결정되고 자동으로 그의 내용에 맞게 자연스런 크기로 결정됩니다.</p>
<p>다음 옵션이 지원됩니다:</p>
<p id="R"><strong>R</strong>: 텍스트 행 (R2.5와 같이 부동 소수점 수를 포함할 수 있습니다). <strong>R</strong>을 설정하는 것이 <strong>H</strong> (높이)를 설정하는 것보다 더 선호됩니다. <strong>R</strong>옵션과 <strong>H</strong> 옵션이 모두 존재하면, <strong>R</strong>이 우선 순위를 갖습니다. GroupBox에 대하여, 이 설정은 박스 안의 공간에 예약된 콘트롤의 개수입니다. <a href="GuiControls.htm#DropDownList">DropDownLists</a>, <a href="GuiControls.htm#ComboBox">ComboBoxes</a>, 그리고 <a href="GuiControls.htm#ListBox">ListBoxes</a>에 대하여, 콘트롤의 리스트 부분 안에 한 번에 보이는 항목의 개수입니다 (그러나 Windows XP 이후에서, 종종 DropDownList와 ComboBoxor에 <strong>R</strong> 옵션과<strong>H</strong> 옵션을 모두 생략하는 것이 바람집합니다. 그래야 팝업 리스트가 자동으로 사용가능한 사용자의 바탕화면의 높이를 이용할 수 있습니다). 다른 콘트롤 유형에 대하여, <strong>R</strong>은 그 콘트롤 안에 시각적으로 딱 맞는 텍스트의 행의 개수입니다.</p>
<p><strong>W</strong>: 픽셀 단위 너비. If omitted, the width is calculated automatically for some control types based on their contents; tab controls default to 30 times the current font size, plus 3 times the <a href="#Margin">X-margin</a>; vertical Progress Bars default to two times the current font size; and horizontal Progress Bars, horizontal Sliders, DropDownLists, ComboBoxes, ListBoxes, GroupBoxes, Edits, and Hotkeys default to 15 times the current font size (except GroupBoxes, which multiply by 18 to provide room inside for margins).</p>
<p><strong>H</strong>: 픽셀 단위 높이. <strong>H</strong>옵션과 <strong>R</strong>옵션이 모두 없으면, DropDownLists, ComboBoxes, ListBoxes, 그리고 빈 여러-줄 편집 콘트롤은 기본 값이 3 행입니다; GroupBoxes는 기본 값이 2 행입니다; 수직 슬라이더와 진도 바는 기본 값이 5 행입니다; 수평 슬라이더는 기본 값이 30 픽셀입니다 (단, 두께가 지정되어 있는 경우는 제외); 수평 진도 바는 기본 값이 현재 글꼴의 2배입니다; 핫키 콘트롤은 기본 값이 1 행입니다; 그리고 탭 콘트롤은 기본값이 10 행입니다. 다른 콘트롤 유형에 대하여, 높이는 그의 내용에 기반하여 자동으로 계산됩니다. DropDownLists 그리고 ComboBoxes에 대하여, <strong>H</strong>는 콘트롤에서 언제나 보이는 부분과 그의 리스트 부분을 조합해 높이를 결정한다는 것을 주목하십시오. (그러나 높이가 너무 낮게 설정되더라도, 적어도 하나의 항목은 리스트에 언제나 보일 것입니다). 또한, 모든 유형의 콘트롤에 대하여, <strong>H</strong> 옵션보다 <strong>R</strong> 옵션을 통하여 숫자를 지정하는 것이 더 좋습니다. 왜냐하면 콘트롤이 부분적으로 불완전하게 텍스트를 보여주지 못하게 방지하기 때문입니다.</p>
<p><strong>wp+n</strong>, <strong>hp+n</strong>, <strong>wp-n</strong>, <strong>hp-n</strong> (여기에서 <strong>n</strong>은 숫자임)를 사용하면 콘트롤의 너비와 높시를 이전에 추가된 콘트롤의 너비와 높이와 같게 설정할 수 있습니다. 선택적으로 플러스나 마이너스 사인을 사용해 조절하면 됩니다. 예를 들어, <code>wp</code>는 이전 콘트롤의 너비로 콘트롤의 너비를 설정합니다. 그리고 <code>wp-50</code>은 이전 콘트롤의 너비보다 50 작게 설정합니다.</p>
<p id="XY"><strong>X</strong>, <strong>Y</strong>: Y-위치, X-위치. 예를 들어, <code>x0 y0</code>를 지정하면 콘트롤을 창의 클라이언트 구역의 좌상 모서리에 배치합니다. 클라이언트 구역은 제목 바와 메뉴 바 아래에 있습니다.</p>
<p id="PosPlus"><strong>x+n</strong>, <strong>y+n</strong> (where <strong>n</strong> is any number): 선택적인 플러스 사인을 포함시키면 이전에 추가된 콘트롤의 오른쪽 또는 아래쪽 가장자리에 (각각) 상대적으로 콘트롤을 배치할 수 있습니다. 예를 들어, <code>Y+10</code>을 지정하면 표준 패딩 거리를 사용하는 대신에 이전 콘트롤의 10 픽셀 아래에 콘트롤을 배치합니다. 비슷하게, <code>X+10</code>을 지정하면 이전 콘트롤의 10 픽셀 오른쪽으로 콘트롤을 배치합니다. <code>X-10</code>과 같은 음수는 절대 위치 지정을 위해 예약되어 있으므로, 음의 오프셋을 사용하려면, 그 앞에 플러스 사인을 포함하십시오. 예를 들어: <code>X+-10</code>.</p>
<p id="PosPlusMargin"><span class="ver">[v1.1.16+]:</span> <strong>X+</strong>와 <strong>Y+</strong>에 대하여, 기호 <strong>M</strong>을 창의 현재 <a href="#Margin">여백</a>에 대안으로 사용할 수 있습니다. 예를 들어, <code>x+m</code>은 이전 콘트롤의 오른쪽 가장자리에다 표준 패딩 거리를 사용합니다. <code>xp y+m</code> positions a control below the previous control, whereas specifying a relative X coordinate on its own (with xp or x+) would normally imply <code>yp</code> by default.</p>
<p id="xp"><strong>xp+n</strong>, <strong>yp+n</strong>, <strong>xp-n</strong>, <strong>yp-n</strong> (여기에서 <strong>n</strong>는 숫자임)는 이전 콘트롤의 좌상 모서리에 상대적으로 콘트롤을 배치하는 데 사용할 수 있습니다. 종종 <a href="GuiControls.htm#GroupBox">GroupBox</a> 안에 콘트롤들을 싸 넣을 때 유용합니다.</p>
<p id="xm"><strong>xm</strong>과 <strong>ym</strong>을 사용하면 창의 좌단 그리고 상단 <a href="#Margin">여백</a>에 (각각) 콘트롤을 배치할 수 있습니다 (이 두 옵션 다음에 플러스/마이너스 사인과 숫자가 하나 따라올 수도 있습니다).</p>
<p id="xs"><strong>xs</strong> 그리고 <strong>ys</strong>: 이 옵션들은 <strong>xm</strong> 그리고 <strong>ym</strong>과 비슷하지만 이전에 그의 옵션에 단어 <a href="#Section">Section</a>을 가지고 콘트롤을 추가할 때 저장된 좌표를 참조합니다 (창의 첫 번째 콘트롤은 언제나 새 섹션을 시작합니다. 그의 옵션에 그 단어가 지정되어 있지 않아도 상관이 없습니다). 예를 들어:</p>
<pre>gui, add, edit, w600  <em>; 상당히 넓은 편집 콘트롤을 창의 상단에 추가합니다.</em>
gui, add, text, <strong>section</strong>, First Name:  <em>; 이 콘트롤의 위치를 저장하고 새 섹션을 시작합니다.</em>
gui, add, text,, Last Name:
gui, add, edit, <strong>ys</strong>  <em>; 이 섹션 안에서 새 열을 시작합니다.</em>
gui, add, edit
gui, show</pre>
<p><strong>xs</strong>와 <strong>ys</strong> 다음에 선택적으로 플러스/마이너스 사인과 숫자 하나가 따라올 수도 있습니다. 또한, 단어 <a href="#Section">Section</a>과 xs/ys를 둘 다 콘트롤의 옵션에 지정하는 것도 가능합니다; 이렇게 하면 자기 자신에 대해서는 이전 섹션을 사용하지만 뒤이은 콘트롤에는 새 섹션을 확립합니다.</p>
<p><strong>X</strong>나 <strong>Y</strong>를 생략하면 앞으로 콘트롤의 크기나 글꼴을 바꿀때 그에 딱 맞게 GUI 레이아웃을 지동으로 조절할 수 있으므로 유용합니다. 대조적으로, 매 콘트롤마다 절대 위치를 지정하면 수작업으로 아래에 있는 모든 콘트롤의 위치를 확대된 또는 축소된 콘트롤의 오른쪽으로 이동해야 합니다.</p>
<p>If both <strong>X</strong> and <strong>Y</strong> are omitted, the control will be positioned beneath the previous control using a standard padding distance (the current <a href="#Margin">margin</a>).</p>
<p>If only one component is omitted, its default value depends on which option was used to specify the other component:</p>
<table class="info">
  <tr><th>Specified X</th><th>Default for Y</th></tr>
  <tr><td>x<em>n</em> or xm</td><td>Beneath all previous controls (maximum Y extent plus margin).</td></tr>
  <tr><td>xs</td><td>Beneath all previous controls since the most recent use of the <a href="#Section">Section</a> option.</td></tr>
  <tr><td>x+<em>n</em> or xp</td><td>Same as the previous control's top edge (<a href="#xp">yp</a>).</td></tr>
  <tr><th>Specified Y</th><th>Default for X</th></tr>
  <tr><td>y<em>n</em> or ym</td><td>To the right of all previous controls (maximum X extent plus margin).</td></tr>
  <tr><td>ys</td><td>To the right of all previous controls since the most recent use of the <a href="#Section">Section</a> option.</td></tr>
  <tr><td>y+<em>n</em> or yp</td><td>Same as the previous control's left edge (<a href="#xp">xp</a>).</td></tr>
</table>

<h3 id="Events">사용자 입력을 저장하고 그에 반응하기</h3>
<p id="var"><strong>V</strong>: 변수. 변수를 콘트롤에 연관 짓습니다. 기호 V 다음에 바로, 전역 변수의 이름을 지정하십시오 (또는 전역 변수를 가리키는 <a href="../Functions.htm#ByRef">ByRef 지역 변수</a>, 또는 <span class="ver">[v1.0.46.01+]</span>에서는 <a href="../Functions.htm#static">정적 변수</a>). 예를 들어, <code><strong>v</strong>MyEdit</code>를 지정하면 <a href="#Submit">Gui Submit</a> 명령어가 사용될 때마다 콘트롤의 내용이 변수 <em>MyEdit</em>에 저장됩니다. 콘트롤이 입력이 불가능하더라도 -- Text 콘트롤이나 GroupBox 콘트롤이라도 --변수를 거기에 연관지으면 여전히 도움이 됩니다. 왜냐하면 변수의 이름이 콘트롤의 유일한 식별자로 기여할 수 있어서 <a href="GuiControl.htm">GuiControl</a>, <a href="GuiControlGet.htm">GuiControlGet</a>, 그리고 <a href="../Variables.htm#GuiControl">A_GuiControl</a>에 사용할 수 있기 때문입니다.</p>
  <p class="note"><strong>주의</strong>: <a href="#Submit">Gui Submit</a>은 입력 불가능한 콘트롤의 (예를 들어Text 그리고 GroupBox) 변수의 내용은 물론이고, 다음 섹션에 문서화된 것들도 변경하지 못합니다 (예를 들어 <a href="ListView.htm">ListView</a> 그리고 <a href="TreeView.htm">TreeView</a>).</p>
<p id="label"><strong>G</strong>: Gosub (g-label). 사용자가 콘트롤을 클릭하거나 변경할 때 함수의 서브루틴을 자동으로 기동합니다. 기호 G 다음에 곧바로, 실행할 <a href="../misc/Labels.htm">라벨</a>의 이름을 지정하십시오. <code>gCancel</code>은 지정하면 묵시적인 <a href="#Cancel">Gui Cancel</a>을 실행할 수 있습니다 (그러나 이름이 "Cancel"인 라벨이 스크립트에 존재하면, 대신에 그 라벨이 실행됩니다). 서브루틴은 다음의 내장 변수들을 참조할 수도 있습니다: <a href="../Variables.htm#Gui">A_Gui</a>, <a href="../Variables.htm#GuiControl">A_GuiControl</a>, <a href="../Variables.htm#GuiEvent">A_GuiEvent</a>, 그리고 <a href="../Variables.htm#EventInfo">A_EventInfo</a>.</p>
<p><span class="ver">[v1.1.20+]:</span>유효한 라벨 이름이 아니면, 함수 이름을 대신 사용할 수 있습니다. 다른 방법으로, <a href="GuiControl.htm#Functor">GuiControl</a> 명령어를 사용하면 <a href="../objects/Functor.htm">함수 객체</a>를 콘트롤에 연관지을 수 있습니다. 함수는 선택적으로 다음 매개변수를 받을 수 있습니다 (여기에서 <code>gCtrlEvent</code>은 함수를 설정합니다):</p>
<pre class="Syntax"><span class="func">CtrlEvent</span>(CtrlHwnd, GuiEvent, EventInfo, ErrLevel:="")</pre>
<p>매개변수의 의미는 콘트롤의 유형에 따라 다릅니다. Note that if the fourth parameter is declared without a default value, the function will only be called by events which supply four parameters.</p>

<h3 id="OtherOptions">콘트롤: 공통 스타일과 기타 옵션</h3>
<p class="note"><strong>주의</strong>: 앞에 부호가 없으면, 플러스 사인이 있다고 간주됩니다; 예를 들어, <code>Wrap</code>은 <code>+Wrap</code>와 같습니다. 대조적으로, <code>-Wrap</code>는 단어-넘기기 특성을 제거합니다.</p>
<p id="AltSubmit"><strong>AltSubmit</strong>: 보조적인 제출 방법을 사용합니다. DropDownList, ComboBox, 그리고 ListBox에 대하여 이 매개변수는 <a href="#Submit">Gui Submit</a> 명령어가 텍스트가 아니라 선택된 항목의 위치를 저장하도록 만듭니다. 항목이 선택되지 않으면, ComboBox는 여전히 그의 편집 필드에 텍스트를 저장합니다; 비슷하게, DropDownList 또는 ListBox는 여전히 그의 <a href="#var">출력 변수</a>를 비웁니다. 주의: AltSubmit는 또 그런 콘트롤의 내용을 열람할 때 <a href="GuiControlGet.htm">GuiControlGet</a>의 행위에도 영향을 미칩니다.</p>
<p><strong>C</strong>: 텍스트의 색깔 (<a href="GuiControls.htm#Button">버튼</a>에는 아무 영향이 없습니다). 기호 C 다음에 곧바로 색 이름 (<a href="Progress.htm#colors">컬러 차트</a> 참조) 또는 RGB 값을 지정하십시오 (0x 접두사는 선택적임). 예제: <code>cRed</code>, <code>cFF2211</code>, <code>c0xFF2211</code>, <code>cDefault</code>.</p>
<p><strong>Choose</strong>: Pre-select a single item in a <a href="../commands/GuiControls.htm#ComboBox">ComboBox</a>, <a href="../commands/GuiControls.htm#DateTime">DateTime</a>, <a href="../commands/GuiControls.htm#DropDownList">DropDownList</a>, <a href="../commands/GuiControls.htm#ListBox">ListBox</a> or <a href="../commands/GuiControls.htm#Tab">Tab</a> control. Specify the word <code>Choose</code> followed immediately by the number of an item. 예를 들어: <code>Choose2</code></p>
<p><strong>Disabled</strong>: 입력 가능한 콘트롤이 비활성 상태로 나타나도록 만듭니다. 그래서 사용자는 그의 내용에 초점을 두거나 변경할 수 없습니다. <a href="GuiControl.htm#EnableDisable">GuiControl Enable</a>를 사용하면 나중에 활성화 할 수 있습니다. 주의: Edit 콘트롤을 읽기 전용으로 만들려면, 대신에 문자열 <code>ReadOnly</code>를 지정하십시오. 또한, 단어 Disabled는 선택적으로 다음에 바로 0 또는 1이 따라와 시작 상태를 나타낼 수 있습니다 (0이면 활성화 1이면 비활성화를 나타냅니다). 다른 말로, <code>Disabled</code>와 <code>Disabled%VarContainingOne%</code>는 같습니다.</p>
<p><strong>Hidden</strong>: 콘트롤은 처음에 안 보입니다. <a href="GuiControl.htm#Show">GuiControl Show</a>를 사용하면 나중에 보여줄 수 있습니다. 단어 Hidden은 선택적으로 다음에 곧바로 0 또는 1이 따라와 시작 상태를 나타낼 수 있습니다 (0이면 보이고 1이면 숨습니다). 다른 말로, <code>Hidden</code>과 <code>Hidden%VarContainingOne%</code>는 같습니다.</p>
<p><strong>Left</strong>: 콘트롤의 내용을 그의 가능한 너비 안에서 왼쪽으로 정렬합니다. 이 옵션은 다음 콘트롤에 영향을 미칩니다: Text, Edit, Button, Checkbox, Radio, UpDown, Slider, Tab, Tab2, GroupBox, DateTime.</p>
<p><strong>Right</strong>: 콘트롤의 텍스트를 그의 가능한 너비 안에서 오른쪽으로 정렬합니다. 체크박스와 라디오버튼에 대하여, 이는 또 박스 자신을 콘트롤의 왼쪽이 아니라 오른쪽에 배치합니다. 이 옵션은 다음 콘트롤에 영향을 미칩니다: Text, Edit, Button, Checkbox, Radio, UpDown, Slider, Tab, Tab2, GroupBox, DateTime, Link.</p>
<p><strong>Center</strong>: 콘트롤의 텍스트를 그의 가능한 너비 안에서 가운데로 정렬합니다. 이 옵션은 다음 콘트롤에 영향을 미칩니다: Text, Edit, Button, Checkbox, Radio, Slider, GroupBox.</p>
<p id="Section"><strong>Section</strong>: 새 섹션을 시작하고 나중에 <a href="#xs">위에</a> 기술한 <em>xs</em>와 <em>ys</em> 위치 지정 옵션에 사용하기 위해 이 콘트롤의 위치를 저장합니다.</p>
<p id="Tabstop"><strong>Tabstop</strong>: <code>-Tabstop</code>을 (즉, 마이너스 탭스탑) 사용하면 사용자가 <kbd>Tab</kbd>를 눌러 항해할 때. 입력 가능 콘트롤을 건너뛸 수 있습니다.</p>
<p id="Wrap"><strong>Wrap</strong>: 그의 가능한 너비 안에서 콘트롤의 내용에 단어-넘기기를 활성화합니다. 거의 모든 콘트롤 유형이 단어-줄넘기기를 켜고 시작하기 때문에, 단어 넘기기를 끄려면 <code>-Wrap</code>를 사용합시오.</p>
<p><strong>VScroll</strong>: 이런 유형의 콘트롤에 적절하면 수직 스크롤 바를 제공합니다.</p>
<p><strong>HScroll</strong>: 이런 유형의 콘트롤에 적절하면 수평 스크롤 바를 제공합니다. 이 문단의 나머지는 <a href="GuiControls.htm#ListBox">ListBox</a>에만 적용됩니다. 수평 스크롤 너비는 리스트 박스 너비의 3 배가 기본값입니다. 다른 스크롤 너비를 지정하려면, 숫자를 단어 HScroll 바로 다음에 지정하십시오. 예를 들어, <code>HScroll500</code>은 리스트박스 안에서 500 픽셀의 수평 스크롤을 허용합니다. 그렇지만, 지정된 스크롤 너비가 리스트박스의 너비보다 작으면, 스크롤 바가 보이지 않습니다 (그렇지만 조금이라도<em>HScroll</em>이 보여야 수평 스크롤바를 나중에 <code><a href="GuiControl.htm">GuiControl</a>, +HScroll500, MyScrollBar</code>를 통하여 추가할 수 있습니다. 그렇지 않으면 불가능합니다).</p>

<h3 id="Controls_Uncommon_Styles_and_Options">콘트롤: 잘 쓰이지 않는 스타일과 옵션</h3>
<p id="BackgroundTrans"><strong>BackgroundTrans</strong>: 투명 배경을 사용합니다. 콘트롤이 텍스트 그림 또는 그룹박스 콘드롤 뒤에 있어도 뚫고 볼 수 있습니다. 예를 들어, 그림 콘트롤 위에 보여지는 투명한 텍스트 콘트롤은 텍스트를 그림의 일부분처럼 보이게 만듭니다. <code><a href="GuiControl.htm">GuiControl</a> +Background</code>를 사용하면 이 옵션을 나중에 제거할 수 있습니다. 투명 이미지에 관한 더 자세한 정보는 <a href="GuiControls.htm#PicAltSubmit">Picture 콘트롤의 AltSubmit 섹션</a>을 참조하십시오. 알려진 한계: BackgroundTrans는 <a href="ListView.htm">ListView</a>가 들어 있는 <a href="GuiControls.htm#Tab">Tab 콘트롤</a> 안의 콘트롤에는 제대로 작동하지 않을 수 있습니다.</p>
<p><strong>-Background</strong> (즉, 마이너스 배경): 표준 배경색을 사용합니다. <a href="#Color">Gui Color</a> 명령어로 설정된 색을 사용하지 않습니다. 이것은 주로 Tab 콘트롤이 창 색이 아니라 그의 표준 색을 가지도록 만드는 데 사용됩니다. <code><a href="GuiControl.htm">GuiControl</a> +Background</code>를 사용하면 이 옵션을 나중에 제거할 수 있습니다.</p>
<p><strong>Border</strong>: 콘트롤 둘레에 얇은 줄 테두리를 두릅니다. 대부분의 콘트롤은 이것이 필요하지 않습니다. 왜냐하면 이미 유형-종속적인 테두리가 있기 때문입니다. 테두리를 <em>기존의</em> 콘트롤에 추가할 때, 콘트롤의 너비와 높이를 각각 1 픽셀씩 증가시킬 필요가 있을 수도 있습니다.</p>
<p id="HwndOutputVar"><strong>Hwnd</strong><em>OutputVar</em> <span class="ver">[v1.0.46.01+]:</span> <a href="#Add">Gui Add</a>와 함께 사용될 때, 이 옵션은 새로 생성된 콘트롤의 창 핸들 (HWND)을 <em>OutputVar</em>에 저장합니다. 예를 들어: <code>Gui, Add, Edit, vMyEdit HwndMyEditHwnd</code>. 함수 안에 사용될 때, <em>MyEditHwnd</em>은 <a href="../Functions.htm#DynVar">함수 동적 변수</a>로 취급됩니다. 콘트롤의 HWND는 종종 <a href="PostMessage.htm">PostMessage</a>, <a href="PostMessage.htm">SendMessage</a>, 그리고 <a href="DllCall.htm">DllCall</a>에 사용됩니다. 또 직접적으로 <a href="../misc/WinTitle.htm#ahk_id">ahk_id WinTitle</a>로 사용되기도 합니다 (이것은 숨은 콘트롤에도 작동합니다. 심지어 <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>가 꺼져(Off) 있어도 상관 없습니다). 또는 <span class="ver">[in v1.1.04+]</span> GuiControl과 GuiControlGet에 <em>ControlID</em> 매개변수로 사용됩니다. 관련하여 말씀 드리자면, 부모 창의 HWND는 <a href="#GuiHwndOutputVar">Gui MyGui:+HwndOutputVar</a>를 통하여 열람할 수 있습니다.</p>
<p><strong>Theme</strong>: 이 옵션은 새로 생성된 콘트롤에 대하여 창의 현재 테마 설정을 오버라이드 하는 데 사용될 수 있습니다. 기존의 콘트롤에 사용될 때는 아무 효과도 없습니다; 그렇지만, 미래의 버전에서 이 기능은 변경될 수 있습니다. 자세한 것은 <a href="#Theme">Gui +/-Theme</a>를 참조하십시오.</p>
<p><strong>(Unnamed Style)</strong>: 플러스나 마이너스 사인 다음에 바로 십진 또는 십육진 <a href="../misc/Styles.htm">스타일 번호</a>를 지정하십시오. 부호가 생략되면, 플러스 사인이 있다고 간주됩니다.</p>
<p><strong>(Unnamed ExStyle)</strong>: 플러스나 마이너스 사인 다음에 바로 기호 E 그리고 십진 또는 십육진 확장 스타일 번호를 지정하십시오. 부호가 생략되면, 플러스 사인이 있다고 간주됩니다. 예를 들어, <code>E0x200</code>는 WS_EX_CLIENTEDGE 스타일을 추가합니다. 이 스타일은 푹 들어간 사방 테두리를 제공하므로 그림이나 기타 콘트롤에 적절합니다. 다른 확장 스타일은 (거의 사용되지 않으므로) 여기에 문서화되지 않았지만, WS_EX_CLIENTEDGE를 <a href="https://www.microsoft.com">www.microsoft.com</a>에서 검색해 보십시오.</p>

<h2 id="Labels">창 이벤트</h2>
<p>다음 라벨 (서브루틴)은 스크립트에 존재한다면 자동으로 GUI 창과 연관됩니다:</p>
<ul>
  <li><a href="#GuiClose">GuiClose</a></li>
  <li><a href="#GuiEscape">GuiEscape</a></li>
  <li><a href="#GuiSize">GuiSize</a></li>
  <li><a href="#GuiContextMenu">GuiContextMenu</a></li>
  <li><a href="#GuiDropFiles">GuiDropFiles</a></li>
</ul>
<p><span class="ver">[v1.1.20+]:</span> 주어진 이벤트에 대하여 라벨이 존재하지 않으면, 그 이름의 함수가 대신 호출됩니다. 그 함수는 선택적으로 첫 매개변수로 GUI의 <a href="#GuiHwndOutputVar">HWND</a>를 받을 수 있습니다. 어떤 이벤트는 추가로 매개변수가 있습니다.</p>
<p><a href="#MultiWin">1 번 창을 제외하고</a> 다른 창들에 대하여, 창의 이름이나 번호는 위에 언급된 특수 라벨에 대하여 접두사로 사용됩니다; 예를 들어, "2GuiEscape" 그리고 "2GuiClose"는 2 번 창의 기본 라벨이 됩니다. 반면에 <em>MyGui</em>GuiEscape 그리고 <em>MyGui</em>GuiClose는 <em>MyGui</em>에 대하여 기본 라벨이 됩니다. 맞춤 접두사를 설정하려면, <a href="#PlusLabel">Gui +Label</a>를 사용하십시오.</p>

<h3 id="GuiClose">GuiClose</h3>
<p>다음 중 하나로 창이 닫힐 때 기동됩니다: 제목 바에서 X를 누름, 시스템 메뉴에서 "닫기"를 선택함, 또는 <a href="WinClose.htm">WinClose</a>로 닫음. 이 라벨이 없을 경우, 창을 닫으면 그냥 감춥니다. 이 효과는 <a href="#Cancel">Gui Cancel</a>과 같습니다. GuiClose에 응답하여 가장 흔한 조치 중 하나는 <a href="ExitApp.htm">ExitApp</a>입니다; 예를 들어:</p>
<pre>GuiClose:
ExitApp</pre>
<p><span class="ver">[v1.1.20+]:</span> If GuiClose is a function, the GUI is hidden by default. 그 함수는 0 아닌 정수를 돌려주어 닫히지 못하도록 할 수 있습니다. 아래 예제에 보여주는 바와 같습니다:</p>
<pre>GuiClose(GuiHwnd) {  <em>; 이 매개변수를 선언하는 것은 선택적입니다.</em>
    MsgBox 4,, Are you sure you want to hide the GUI?
    IfMsgBox No
        return true  <em>; true = 1</em>
}</pre>

<h3 id="GuiEscape">GuiEscape</h3>
<p>GUI 창이 활성화 되어 있는 동안에 사용자가 <kbd>Esc</kbd>를 누를 때 기동됩니다. 라벨이 없으면, <kbd>Esc</kbd>를 눌러도 효과가 없습니다. 알려진 한계: 창의 첫 콘트롤이 활성화 되어 있지 않으면 (콘트롤 유형에 따라 다름), GuiEscape 라벨은 기동하지 않습니다. 이런 효과를 생산하는 다른 상황이 있을 수 있습니다.</p>

<h3 id="GuiSize">GuiSize</h3>
<p>창이 크기가 바뀔때, 최대화, 최소화, 또는 복원될 때 기동됩니다. 내장 변수 <a href="../Variables.htm#GuiWidth">A_GuiWidth</a>와 <a href="../Variables.htm#GuiWidth">A_GuiHeight</a>에 창의 클라이언트 구역의 너비와 높이가 담깁니다. 클라이언트 구역에서 제목 바, 메뉴 바, 그리고 테두리를 제외합니다. 게다가, <a href="../Variables.htm#EventInfo">A_EventInfo</a> 그리고 <a href="../misc/ErrorLevel.htm">ErrorLevel</a>는 모두 다음 숫자 중 하나를 담습니다:</p>
<ul>
  <li>0 = 창이 복원되었다. 또는 테두리를 끌어서 정상적으로 크기가 변경되었다.</li>
  <li>1 = 창이 최소화되었다.</li>
  <li>2 = 창이 최대화되었다.</li>
</ul>
<p>스크립트는 GuiSize를 사용해 사용자의 창 크기 변경에 응답하여 콘트롤의 크기와 위치를 다시 조절할 수 있습니다. <a href="https://www.autohotkey.com/boards/viewtopic.php?f=6&amp;t=1079">tmplinshi와 toralf가 만든 AutoXYWH() </a>를 사용하면 더 쉽게 이것을 처리할 수 있습니다.</p>
<p>창이 크기가 바뀔 때 (스크립트가 바꾸어도), GuiSize는 즉시 호출되지 않을 수 있습니다. 다른 창 이벤트와 마찬가지로, 현재 쓰레드가 <a href="Thread.htm#Interrupt">인터럽트가 불가능하다면</a>, GuiSize는 쓰레드가 인터럽트가 가능해질 때까지 호출되지 않습니다. 스크립트가 방금 창의 크기를 변경했다면, 다음 예제를 따라 GuiSize가 즉시 호출되는 것을 확인하십시오:</p>
<pre><a href="Critical.htm#Off">Critical</a> Off  <em>; Critical On이 사용되지 않았더라도.</em>
<a href="Sleep.htm">Sleep</a> -1</pre>
<p><span class="ver">[v1.1.22.05+]:</span> <a href="#Show">Gui Show</a>는 자동으로 <code>Sleep -1</code>을 수행합니다. 그래서 일반적으로 그 경우에는 Sleep을 호출할 필요가 없습니다.</p>
<p><span class="ver">[v1.1.20+]:</span> GuiSize가 함수이면, 그의 매개변수는 다음과 같습니다:</p>
<pre class="Syntax"><span class="func">GuiSize</span>(GuiHwnd, EventInfo, Width, Height)</pre>

<h3 id="GuiContextMenu">GuiContextMenu</h3>
<p>사용자가 제목 바와 라벨을 제외하고 창을 아무데나 클릭하면 기동됩니다. 또 <kbd>Menu</kbd> 키나 <kbd>Shift</kbd>+<kbd>F10</kbd> 키눌림에 응답하여 기동됩니다. 대부분의 다른 GUI 라벨과 다르게, GuiContextMenu는 동시에 여러 병행 <a href="../misc/Threads.htm">쓰레드</a>를 가질 수 있습니다. 다음 내장 변수를 GuiContextMenu에서 사용할 수 있습니다:</p>
<ol>
  <li><a href="../Variables.htm#GuiControl">A_GuiControl</a>, 안에 이벤트를 받은 콘트롤의 <a href="../Variables.htm#GuiControl">텍스트나 변수 이름</a>이 들어 있습니다 (없으면 비어 있습니다).</li>
  <li><a href="../Variables.htm#EventInfo">A_EventInfo</a>: ListBox, ListView, 또는 TreeView가 문맥 메뉴의 목표일 때 (위의 A_GuiControl가 결정함), A_EventInfo는 어느 콘트롤의 항목이 목표인지 지정합니다:
    <ul>
      <li><a href="GuiControls.htm#ListBox">ListBox</a> 또는 <a href="ListView.htm">ListView</a>: A_EventInfo에는 현재 초점이 있는 행의 번호가 담겨 있습니다 (없으면 0).</li>
      <li><a href="TreeView.htm">TreeView</a>: 우클릭에 대하여, A_EventInfo에는 클릭된 항목의 ID 번호가 담깁니다 (또는 사용자가 항목 말고 다른 곳을 클릭 했다면 0입니다). <kbd>Menu</kbd>와 <kbd>Shift</kbd>+<kbd>F10</kbd>,에 대하여, A_EventInfo에는 선택된 항목의 ID 번호가 담깁니다.</li>
    </ul></li>
  <li>A_GuiX 그리고 A_GuiY, 여기에는 스크립트가 메뉴를 보여줄 X 좌표와 Y 좌표가 담깁니다 (예, <code><a href="Menu.htm">Menu</a>, MyContext, Show, %A_GuiX%, %A_GuiY%</code>). 좌표는 창의 조상단 모서리에 상대적입니다.</li>
  <li>A_GuiEvent, 사용자가 우클릭하면 단어 RightClick이 담기고 메뉴가 <kbd>Menu</kbd> 키 또는 <kbd>Shift</kbd>+<kbd>F10</kbd>에 의하여 촉발되었다면 Normal이 담깁니다.</li>
</ol>
<p class="note"><strong>주의</strong>: <a href="GuiControls.htm#Edit">Edit</a> 그리고 <a href="GuiControls.htm#MonthCal">MonthCal</a> 콘트롤은 자신만의 문맥이 있기 때문에, 그 중에 하나에 우클릭하더라도 GuiContextMenu는 기동되지 않습니다.</p>
<p><span class="ver">[v1.1.20+]:</span> GuiContextMenu가 함수이면, 그의 매개변수는 다음과 같습니다:</p>
<pre class="Syntax"><span class="func">GuiContextMenu</span>(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y)</pre>
<p><em>CtrlHwnd</em>는 콘트롤이 이벤트를 받지 않았으면 비어 있습니다. <em>IsRightClick</em>은 A_GuiEvent가 RightClick이면 참입니다.</p>

<h3 id="GuiDropFiles">GuiDropFiles</h3>
<p>끌어 떨구기 연산의 일부로 파일/폴더가 창에 떨구어질 때마다 기동됩니다 (그러나 라벨이 이미 실행 중이면, 떨구기 이벤트는 무시됩니다). 다음 내장 변수는 GuiDropFiles 안에서 사용가능 합니다:</p>
<ol>
  <li><a href="../Variables.htm#GuiControl">A_GuiControl</a>, 안에 파일이 떨구어진 콘트롤의 <a href="../Variables.htm#GuiControl">텍스트 또는 변수 이름</a>이 담겨 있습니다 (없으면 비어 있음).</li>
  <li><a href="../Variables.htm#EventInfo">A_EventInfo</a> 그리고 <a href="../misc/ErrorLevel.htm">ErrorLevel</a>, 둘 모두 안에 떨구어진 파일의 개수가 담겨 있습니다.</li>
  <li>A_GuiX 그리고 A_GuiY, 안에 파일이 떨구어진 곳의 X좌표와 Y 좌표가 각각 담겨 있습니다 (좌표는 창의 좌상 모서리에 상대적입니다).</li>
  <li>A_GuiEvent, 안에 떨구어진 파일의 이름이 들어 있습니다. 마지막을 제외하고 각각의 파일이름은 라인피드 (`n)로 끝닙니다.</li>
</ol>
<p>개별 파일을 추출하려면, 아래에 보여주는 바와 같이 <a href="LoopParse.htm">파싱 회돌이</a>를 사용하십시오:
</p>
<pre><em>; 예제 #1:</em>
Loop, Parse, A_GuiEvent, `n
{
    MsgBox, 4,, File number %A_Index% is:`n%A_LoopField%.`n`nContinue?
    IfMsgBox, No, break
}

<em>; 예제 #2: 첫 파일만 추출하려면, 다음 예제를 따르십시오:</em>
Loop, Parse, A_GuiEvent, `n
{
    FirstFile := A_LoopField
    break
}

<em>; 예제 #3: 알파벳 순으로 파일을 처리하려면, 다음 예제를 따르십시오:</em>
FileList := A_GuiEvent
Sort, FileList
Loop, Parse, FileList, `n
    MsgBox File number %A_Index% is:`n%A_LoopField%.</pre>
<p>창에 대하여 끌어 떨구기를 잠시 끄려면, <code>Gui -E0x10</code>를 통하여 WS_EX_ACCEPTFILES 스타일을 제거하십시오. 나중에 다시 활성화하려면, <code>Gui +E0x10</code>를 사용하십시오.</p>
<p><span class="ver">[v1.1.20+]:</span> GuiDropFiles이 함수이면, 그 매개변수는 아래 예제에 보여주는 바와 같습니다. <em>CtrlHwnd</em>는 파일이 GUI 자체에 떨구어지면 비어 있습니다. <em>FileArray</em>는파일이름의 <a href="../Objects.htm#Usage_Simple_Arrays">배열 (객체)</a>입니다. 여기에서 <code>FileArray[1]</code>은 첫 번째 파일이고 <code>FileArray.MaxIndex()</code>는 파일의 개수를 돌려줍니다. <a href="For.htm">for-회돌이</a>를 사용하면 파일을 반복할 수 있습니다:</p>
<pre>GuiDropFiles(GuiHwnd, FileArray, CtrlHwnd, X, Y) {
    for i, file in FileArray
        MsgBox File %i% is:`n%file%
}
</pre>

<h3 id="OtherEvents">Other Events</h3>
<p>다른 유형의 GUI 이벤트는 <a href="OnMessage.htm">OnMessage()</a>를 통하여 탐지하고 처리할 수 있습니다. 예를 들어, 사용자가 마우스를 창의 특정 콘트롤에 올려 놓을 때마다 스크립트는 문맥-감지 도움말을 툴팁을 통하여 보여줄 수 있습니다. 이것은 <a href="#ExToolTip">GUI ToolTip 예제</a>에서 시연합니다.</p>

<h2 id="MultiWin">여러 GUI 창 만들기</h2>
<p><a href="#DefaultWin">기본 창</a> 말고 다른 창을 처리하려면, 그의 이름 또는 번호 (또는 <span class="ver">[v1.1.03+]</span>이라면, 그의 <a href="#GuiHwndOutputVar">HWND</a>) 그리고 다음에 쌍점을 두고 부-명령어를 다음 예제와 같이 포함하십시오:</p>
<pre>Gui, <strong>MyGui:</strong>Add, Text,, Text for about-box.
Gui, <strong>MyGui:</strong>Show</pre>
<p><code><a href="#Default">Gui MyGui:Default</a></code>을 사용하면 위의 "MyGui:" 접두사가 필요 없습니다. 게다가, 이 접두사는 <a href="#DefaultWin">GUI 쓰레드가</a> 그 쓰레드를 기동한 같은 창에 작동하면 필요가 없습니다.</p>
<p id="Name"><span class="ver">[v1.1.03+]:</span> Gui 이름은 반드시 <a href="../Concepts.htm#names">변수 이름</a>과 같은 규칙을 지겨야 합니다. 1과 99 사이의 숫자가 아닌 숫자 또는 두 자리 문자보다 더 긴 숫자는 (예를 들어 0x01) 반드시 기존의 Gui의 HWND이어야 합니다. 그렇지 않으면 명령어는 실패합니다. 취급할 수 있는 창의 개수는 운영 체제의 자원에만 제한됩니다.</p>
<p><span class="ver">[v1.1.04+]:</span> 이름 없는 GUI 창의 번호는 <a href="#New">Gui, New</a>를 사용하여 만들 수 있습니다.</p>

<h2 id="DefaultWin">GUI 이벤트, 쓰레드 그리고 서브루틴</h2>
<p>GUI <a href="../misc/Threads.htm">쓰레드</a>는 GUI 행위의 결과로 기동된 쓰레드로 정의됩니다. GUI 행위에는 GUI 창의 <a href="#Menu">메뉴 바</a>로부터 항목을 선택하는 것, 또는 그의 <a href="#label">g-labels</a>중 하나를 (버튼을 눌러서) 촉발시키는 일이 포함됩니다.</p>
<p>GUI 쓰레드의 <strong>기본 <a href="#MultiWin">창 이름</a></strong>은 그 쓰레드를 기동한 창의 이름입니다. 비-GUI 쓰레드는 1을 기본값으로 사용합니다.</p>
<p>GUI <a href="../misc/Threads.htm">쓰레드</a>가 기동할 때마다, 그 쓰레드의 <a href="../misc/WinTitle.htm#LastFoundWindow">마지막 발견 창</a>은 그 GUI 창 자체로 시작합니다. 이 덕분에 창과 콘트롤에 대한 명령어들이 -- 예를 들어 <a href="WinMove.htm">WinMove</a>, <a href="WinHide.htm">WinHide</a>, <a href="WinSet.htm">WinSet</a>, <a href="WinSetTitle.htm">WinSetTitle</a>, 그리고 <a href="ControlGetFocus.htm">ControlGetFocus</a> 명령어가 -- GUI 창 자신에게 작동할 때는 WinTitle과 WinText를 생략할 수 있습니다 (심지어 숨어 있어도 작동합니다).</p>
<p>앞에서 클릭해서 그의 <a href="#label">g-label</a>이 이미 실행 중인 동안에 콘트롤을 클릭하면 아무 효과도 없고 그 이벤트는 폐기됩니다. 이를 피하려면, <a href="Critical.htm">Critical</a>을 서브루틴의 첫 줄에 사용하십시오 (그렇지만, 이렇게 하면 핫키 누름과 같이 다른 <a href="../misc/Threads.htm">쓰레드</a>도 버퍼처리 또는 지연될 것입니다.).</p>
<p>내장 변수 A_Gui와 A_GuiControl 안에는 현재 쓰레드를 기동한 창 이름과 콘트롤 ID가 담겨 있습니다. 더 자세한 것은 <a href="../Variables.htm#Gui">A_Gui</a> 그리고 <a href="../Variables.htm#GuiControl">A_GuiControl</a>를 참조하십시오.</p>
<p>여러 이벤트가 같은 서브루틴을 수행하도록 만들려면, 라벨들을 연속적으로 서브루틴 위에 지정하십시오. 예를 들어:</p>
<pre>GuiEscape:
GuiClose:
ButtonCancel:
ExitApp  <em>; 위의 모든 라벨은 이것을 수행합니다.</em></pre>
<p>모든 GUI <a href="../misc/Threads.htm">쓰레드는</a> <a href="SendMode.htm">SendMode</a>와 같은 설정에 대하여 기본 값을 가지고 새롭게 시작합니다. 이 기본 값은 <a href="../Scripts.htm#auto">자동-실행 섹션</a>에서 변경할 수 있습니다.</p>

<h2 id="Navigate">키보드 항해</h2>
<p>GUI 창은 <kbd>Tab</kbd>로 항해할 수 있습니다. 탭 키는 초점을 다음 입력-가능 콘트롤로 이동시킵니다l (<a href="#Tabstop">Tabstop</a> 스타일이 제거된 콘트롤은 건너 뜁니다). 항해의 순서는 콘트롤이 원래 추가된 순서로 결정됩니다. 창이 처음 보이면, Tabstop 스타일을 가지고 있는 첫 번째 입력-가능 콘트롤이 키보드 초점을 가집니다 (대부분의 콘트롤 유형은 기본으로 탭스탑 스타일을 가지고 있습니다).</p>
<p id="ShortcutKey">어떤 콘트롤은 키보드 단축키를 만드는 앰퍼센드가 포함되어 있을 수 있습니다 (&amp;). 이 단축 키는 콘트롤의 텍스트에 밑줄 문자로 보여집니다 (시스템 설정에 따라 다름). 사용자는 <kbd>Alt</kbd>를 누른 채로 상응하는 문자를 타자하여 그 단축키를 활성화 합니다. 버튼, 체크박스, 그리고 라디오 버튼에 대하여, 단축키를 누르는 것은 콘트롤을 클릭하는 것과 동일합니다. GroupBoxes와 Text controls에 대하여, 단축키를 누르면 키보드 초점이 첫 번째 입력-가능 <a href="#Tabstop">tabstop</a> 콘트롤로 점프합니다. 그렇지만 여러 콘트롤이 같은 단축키를 가지고 있는 경우, 단축 키를 누르면 같은 단축키를 가지고 있는 모든 콘트롤 중에 하나를 골라 무작위로 점프합니다.</p>
<p>앰퍼센드를 글자 그대로 위에 언급한 콘트롤 유형에 보여주려면, 두 개의 앰퍼센드를 연속으로 다음 예제와 같이 지정하십시오: <code>Gui, Add, Button,, Save &amp;&amp; Exit</code>.</p>

<h2 id="Appear">창의 모습</h2>
<p>아이콘에 대하여 GUI 창은 창이 만들어지는 순간 효과가 있던 트레이 아이콘을 사용합니다. 그래서, 다른 아이콘을 가지려면, 트레이 아이콘을 바꾸고 나서 창을 만드십시오. 예를 들어: <code><a href="Menu.htm">Menu</a>, Tray, Icon, MyIcon.ico</code>. 또 작은 아이콘 말고 큰 아이콘을 가지는 것도 가능합니다 (큰 아이콘은 알트-탭 태스크 전환기에 보여집니다.). 이것은 <a href="LoadPicture.htm">LoadPicture()</a>과 <a href="PostMessage.htm">SendMessage</a>를 통하여 달성할 수 있습니다; 예를 들어:</p>
<pre>iconsize := 32  <em>; Ideal size for alt-tab varies between systems and OS versions.</em>
hIcon := LoadPicture("My Icon.ico", "Icon1 w" iconsize " h" iconsize, imgtype)
Gui +LastFound
SendMessage 0x0080, 1, hIcon  <em>; 0x0080는 WM_SETICON입니다; 그리고 1은 ICON_BIG이는 뜻입니다 ( 0이면 ICON_SMALL을 의미함).</em>
Gui Show</pre>
<p>OS의 제한 때문에, 비-기본 텍스트 컬러가 지정된 체크박스, 라디오 버튼, 그리고 그룹박스는 Windows XP 이상에서 고전 테마의 겉모습을 가집니다.</p>
<p>관련 주제: <a href="#Margin">창의 여백</a>.</p>

<h2 id="GenRemarks">총평</h2>
<p><a href="GuiControl.htm">GuiControl</a>과 <a href="GuiControlGet.htm">GuiControlGet</a>을 사용하면 GUI 창의 콘트롤을 개별적으로 처리할 수 있습니다.</p>
<p>각 GUI 창은 최대 11,000 개의 콘트롤을 가질 수 있습니다. 그렇지만, 5000 개가 넘는 콘트롤을 만들 때 조심하십시오. 왜냐하면 어떤 콘트롤 유형에 대해서는 시스템의 안정성에 문제가 생길 수 있기 때문입니다.</p>
<p>스크립트 어디서든 GUI 명령어를 사용하면 자동으로 <a href="_Persistent.htm">영속적</a>이 됩니다 (그 GUI 명령어가 실제로 실행되지 않더라도 상관 없습니다). 또 단일 실체이기도 합니다. 단, <a href="_SingleInstance.htm">#SingleInstance</a> 지시어를 사용해 오버라이드 한 경우는 예외입니다.</p>

<h2 id="Related">관련 항목</h2>
<p><a href="GuiControl.htm">GuiControl</a>, <a href="GuiControlGet.htm">GuiControlGet</a>, <a href="Menu.htm">Menu</a>, <a href="GuiControls.htm">콘트롤 유형</a>, <a href="ListView.htm">ListView</a>, <a href="TreeView.htm">TreeView</a>, <a href="Control.htm">Control</a>, <a href="ControlGet.htm">ControlGet</a>, <a href="Progress.htm">SplashImage</a>, <a href="MsgBox.htm">MsgBox</a>, <a href="FileSelectFile.htm">FileSelectFile</a>, <a href="FileSelectFolder.htm">FileSelectFolder</a></p>

<h2 id="Examples">예제</h2>

<div class="ex" id="ExPopup">
<p><a class="ex_number" href="#ExPopup"></a> Creates a popup window similar to <a href="SplashTextOn.htm">SplashTextOn</a>.</p>
<pre>Gui, +AlwaysOnTop +Disabled -SysMenu +Owner  <em>; +Owner를 사용하면 태스크 바 버튼이 보이지 않습니다.</em>
Gui, Add, Text,, Some text to display.
Gui, Show, NoActivate, Title of Window  <em>; NoActivate는 현재 활성 창을 비활성화하지 못하도록 합니다.</em></pre>
</div>

<div class="ex" id="ExInputBox">
<p><a class="ex_number" href="#ExInputBox"></a> Creates a simple input-box that asks for the first and last name.</p>
<pre>Gui, Add, Text,, First name:
Gui, Add, Text,, Last name:
Gui, Add, Edit, vFirstName ym  <em>; ym 옵션은 콘트롤의 새 열을 시작합니다.</em>
Gui, Add, Edit, vLastName
Gui, Add, Button, default, OK  <em>; 라벨 ButtonOK는 (존재하면) 버튼이 눌릴 때 실행됩니다.</em>
Gui, Show,, Simple Input Example
return  <em>; 자동-실행 섹션의 끝. 스크립트는 사용자가 무언가 일을 할 때 까지 휴식 상태에 들어갑니다.</em>

GuiClose:
ButtonOK:
Gui, Submit  <em>; 각 콘트롤의 연관 변수에 사용자의 입력을 저장합니다.</em>
MsgBox You entered "%FirstName% %LastName%".
ExitApp</pre>
</div>

<div class="ex" id="ExTab">
<p><a class="ex_number" href="#ExTab"></a> Creates a tab control with multiple tabs, each containing different controls to interact with.</p>
<pre>Gui, Add, Tab2,, First Tab|Second Tab|Third Tab  <em>; Tab2 vs. Tab는 <span class="ver">[v1.0.47.05+]</span>를 요구합니다.</em>
Gui, Add, Checkbox, vMyCheckbox, Sample checkbox
Gui, Tab, 2
Gui, Add, Radio, vMyRadio, Sample radio1
Gui, Add, Radio,, Sample radio2
Gui, Tab, 3
Gui, Add, Edit, vMyEdit r5  <em>; r5는 높이가 5 행 이라는 뜻입니다.</em>
Gui, Tab  <em>; 즉, 이어서 추가되는 콘트롤들은 탭 콘트롤에 속하지 않습니다.</em>
Gui, Add, Button, default xm, OK  <em>; xm은 버튼을 좌하 모서리에 배치합니다.</em>
Gui, Show
return

ButtonOK:
GuiClose:
GuiEscape:
Gui, Submit  <em>; 각 콘트롤의 내용을 그의 연관 변수에 저장합니다.</em>
MsgBox You entered:`n%MyCheckbox%`n%MyRadio%`n%MyEdit%
ExitApp</pre>
</div>

<div class="ex" id="ExListBox">
<p><a class="ex_number" href="#ExListBox"></a> Creates a ListBox control containing files in a directory.</p>
<pre>Gui, Add, Text,, Pick a file to launch from the list below.`nTo cancel, press ESCAPE or close this window.
Gui, Add, ListBox, vMyListBox gMyListBox w640 r10
Gui, Add, Button, Default, OK
Loop, C:\*.*  <em>; 이 폴더와 와일드카드 패턴을 여러분의 기호에 맞게 바꾸십시오.</em>
{
    GuiControl,, MyListBox, %A_LoopFileFullPath%
}
Gui, Show
return

MyListBox:
if (A_GuiEvent != "DoubleClick")
    return
<em>; 그렇지 않으면, 사용자가 리스트 항목을 더블클릭한 것입니다. 그래서 OK를 클릭한 것과 똑같이 취급합니다.
; 그래서 다음 라벨로 빠져 나갑니다.</em>
ButtonOK:
GuiControlGet, MyListBox  <em>; ListBox의 현재 선택을 열람합니다.</em>
MsgBox, 4,, Would you like to launch the file or document below?`n`n%MyListBox%
IfMsgBox, No
    return
<em>; 그렇지 않으면, 기동을 시도합니다:</em>
Run, %MyListBox%,, UseErrorLevel
if (ErrorLevel = "ERROR")
    MsgBox Could not launch the specified file. Perhaps it is not associated with anything.
return

GuiClose:
GuiEscape:
ExitApp</pre>
</div>

<div class="ex" id="ExToolTip">
<p><a class="ex_number" href="#ExToolTip"></a> 사용자가 마우스를 특정 콘트롤에 올려 놓을 때마다 (툴팁을 통하여) 문맥-감지 도움말을 보여줍니다.</p>
<pre>Gui, Add, Edit, v<strong>MyEdit</strong>
<strong>MyEdit</strong>_TT := "This is a tooltip for the control whose variable is MyEdit."
Gui, Add, DropDownList, v<strong>MyDDL</strong>, Red|Green|Blue
<strong>MyDDL</strong>_TT := "Choose a color from the drop-down list."
Gui, Add, Checkbox, vMyCheck, This control has no tooltip.
Gui, Show
<a href="OnMessage.htm">OnMessage</a>(0x0200, "WM_MOUSEMOVE")
return

WM_MOUSEMOVE()
{
    static CurrControl, PrevControl, _TT  <em>; _TT는 아래의 ToolTip 명령어에 사용하기 위해 빈 상태를 유지합니다.</em>
    CurrControl := A_GuiControl
    if (CurrControl != PrevControl and not InStr(CurrControl, " "))
    {
        ToolTip  <em>; 이전의 툴팁을 모두 끕니다.</em>
        SetTimer, DisplayToolTip, 1000
        PrevControl := CurrControl
    }
    return

    DisplayToolTip:
    SetTimer, DisplayToolTip, Off
    <a href="ToolTip.htm">ToolTip</a> % %CurrControl%_TT  <em>; 앞의 퍼센트 사인은 표현식을 사용하라고 알립니다.</em>
    SetTimer, RemoveToolTip, 3000
    return

    RemoveToolTip:
    SetTimer, RemoveToolTip, Off
    ToolTip
    return
}


GuiClose:
ExitApp</pre>
</div>

<div class="ex" id="OSD">
<p><a class="ex_number" href="#OSD"></a> Creates an On-screen display (OSD) via transparent window.</p>
<pre>CustomColor := "EEAA99"  <em>; RGB 색 가능 (아래에서 투명하게 만들 것입니다).</em>
Gui +LastFound +AlwaysOnTop -Caption +ToolWindow  <em>; +ToolWindow는 태스크바 버튼과 알트-탭 메뉴 항목을 회피합니다.</em>
Gui, Color, %CustomColor%
Gui, Font, s32  <em>; 커다란 글꼴 크기를 설정합니다 (32-포인트).</em>
Gui, Add, Text, vMyText cLime, XXXXX YYYYY  <em>; XX &amp; YY는 자동-크기 조절 창으로 기여합니다.
; 이 색을 가진 모든 픽셀을 투명하게 만들고 텍스트 자체는 반투명하게 만듭니다 (150):</em>
WinSet, TransColor, %CustomColor% 150
SetTimer, UpdateOSD, 200
Gosub, UpdateOSD  <em>; 타이머를 기다리지 않고 먼저 즉시 갱신합니다.</em>
Gui, Show, x0 y400 NoActivate  <em>; NoActivate는 현재 활성 창을 비활성화하지 못하도록 합니다.</em>
return

UpdateOSD:
MouseGetPos, MouseX, MouseY
GuiControl,, MyText, X%MouseX%, Y%MouseY%
return</pre>
</div>

<div class="ex" id="ExProgressBar">
<p><a class="ex_number" href="#ExProgressBar"></a> Creates a moving progress bar overlayed on a background image.</p>
<pre>Gui, Color, White
Gui, Add, Picture, x0 y0 h350 w450, %A_WinDir%\system32\ntimage.gif
Gui, Add, Button, Default xp+20 yp+250, Start the Bar Moving
Gui, Add, Progress, vMyProgress w416
Gui, Add, Text, vMyText wp  <em>; wp는 "이전의 너비를 사용하라"는 뜻입니다.</em>
Gui, Show
return

ButtonStartTheBarMoving:
Loop, %A_WinDir%\*.*
{
    if (A_Index &gt; 100)
        break
    GuiControl,, MyProgress, %A_Index%
    GuiControl,, MyText, %A_LoopFileName%
    Sleep 50
}
GuiControl,, MyText, Bar finished.
return

GuiClose:
ExitApp</pre>
</div>

<div class="ex" id="ExImageViewer">
<p><a class="ex_number" href="#ExImageViewer"></a> Creates a simple image viewer.</p>
<pre>Gui, +Resize
Gui, Add, Button, default, &amp;Load New Image
Gui, Add, Radio, ym+5 x+10 vRadio checked, Load &amp;actual size
Gui, Add, Radio, ym+5 x+10, Load to &amp;fit screen
Gui, Add, Pic, xm vPic
Gui, Show
return

ButtonLoadNewImage:
FileSelectFile, file,,, Select an image:, Images (*.gif; *.jpg; *.bmp; *.png; *.tif; *.ico; *.cur; *.ani; *.exe; *.dll)
if not file
    return
Gui, Submit, NoHide <em>; 라디오 버튼의 값을 저장합니다.</em>
if (Radio = 1)  <em>; 이미지를 그의 실제 크기로 보여줍니다.</em>
{
    Width := 0
    Height := 0
}
else <em>; Second radio is selected: 이미지를 화면 크기에 맞게 조절합니다.</em>
{
    Width := A_ScreenWidth - 28  <em>; 마이너스 28 만큼 테투리와 여백 안에  여유가 있습니다.</em>
    Height := -1  <em>; "화면 비율 유지"가 가장 좋아 보입니다.</em>
}
GuiControl,, Pic, *w%width% *h%height% %file%  <em>; 이미지를 적재합니다.</em>
Gui, Show, xCenter y0 AutoSize, %file%  <em>; 그림 크기에 맞게 창을 조절합니다.</em>
return

GuiClose:
ExitApp</pre>
</div>

<div class="ex" id="ExEditor">
<p><a class="ex_number" href="#ExEditor"></a> Creates a simple text editor with menu bar.</p>
<pre><em>; 메뉴 바를 위하여 부-메뉴를 생성합니다:</em>
Menu, FileMenu, Add, &amp;New, FileNew
Menu, FileMenu, Add, &amp;Open, FileOpen
Menu, FileMenu, Add, &amp;Save, FileSave
Menu, FileMenu, Add, Save &amp;As, FileSaveAs
Menu, FileMenu, Add  <em>; Separator line.</em>
Menu, FileMenu, Add, E&amp;xit, FileExit
Menu, HelpMenu, Add, &amp;About, HelpAbout

<em>; 부-메뉴를 메뉴 바에 부착해 메뉴 바를 생성합니다:</em>
Menu, MyMenuBar, Add, &amp;File, :FileMenu
Menu, MyMenuBar, Add, &amp;Help, :HelpMenu

<em>; 메뉴 바를 창에 부착합니다:</em>
Gui, Menu, MyMenuBar

<em>; 메인 편집 콘트롤을 생성하고 그 창을 보여줍니다:</em>
Gui, +Resize  <em>; 창을 크기가 변경가능하게 만듭니다.</em>
Gui, Add, Edit, vMainEdit WantTab W600 R20
Gui, Show,, Untitled
CurrentFileName := ""  <em>; 현재 파일이 없음을 나타냅니다.</em>
return

FileNew:
GuiControl,, MainEdit  <em>; 편집 콘트들을 비웁니다.</em>
return

FileOpen:
Gui +OwnDialogs  <em>; 사용자가 FileSelectFile 대화상자를 포기하도록 만들고 나서 메인 창으로 되돌아 옵니다.</em>
FileSelectFile, SelectedFileName, 3,, Open File, Text Documents (*.txt)
if not SelectedFileName  <em>; 파일이 선택되지 않았습니다.</em>
    return
Gosub FileRead
return

FileRead:  <em>; 호출자는 변수 SelectedFileName을 우리 대신에 설정합니다.</em>
FileRead, MainEdit, %SelectedFileName%  <em>; 파일의 내용을 변수 안으로 읽어 들입니다.</em>
if ErrorLevel
{
    MsgBox Could not open "%SelectedFileName%".
    return
}
GuiControl,, MainEdit, %MainEdit%  <em>; 텍스트를 콘트롤 안에 넣습니다.</em>
CurrentFileName := SelectedFileName
Gui, Show,, %CurrentFileName%   <em>; 파일 이름을 제목 바에 보여줍니다.</em>
return

FileSave:
if not CurrentFileName   <em>; 아직 파일이름이 선택되지 않았습니다. 그래서 대신 Save-As를 수행합니다.</em>
    Goto FileSaveAs
Gosub SaveCurrentFile
return

FileSaveAs:
Gui +OwnDialogs  <em>; 사용자가 FileSelectFile 대화상자를 포기하도록 만들고 나서 메인 창으로 되돌아 옵니다.</em>
FileSelectFile, SelectedFileName, S16,, Save File, Text Documents (*.txt)
if not SelectedFileName  <em>; 파일이 선택되지 않았습니다.</em>
    return
CurrentFileName := SelectedFileName
Gosub SaveCurrentFile
return

SaveCurrentFile:  <em>; 호출자는 CurrentFileName이 비어 있지 않음을 확인합니다.</em>
if FileExist(CurrentFileName)
{
    FileDelete %CurrentFileName%
    if ErrorLevel
    {
        MsgBox The attempt to overwrite "%CurrentFileName%" failed.
        return
    }
}
GuiControlGet, MainEdit  <em>; 편집 콘트롤의 내용을 열람합니다.</em>
FileAppend, %MainEdit%, %CurrentFileName%  <em>; 내용을 파일에 저장합니다.
; 성공하면, 파일 이름을 제목 바에 보여줍니다 (FileSaveAs에 의하여 호출되는 경우):</em>
Gui, Show,, %CurrentFileName%
return

HelpAbout:
Gui, About:+owner1  <em>; 메인 창을 (Gui #1) "about box"의 소유자로 만듭니다.</em>
Gui +Disabled  <em>; 메인 창을 비활성화 합니다.</em>
Gui, About:Add, Text,, Text for about box.
Gui, About:Add, Button, Default, OK
Gui, About:Show
return

AboutButtonOK:  <em>; 이 섹션은 위의 "about box"가 사용합니다.</em>
AboutGuiClose:
AboutGuiEscape:
Gui, 1:-Disabled  <em>; 메인 창을 다시 활성화 합니다 (다음 단계로 나아가기 전에 반드시 활성화 해야 함).</em>
Gui Destroy  <em>; about box를 파괴합니다.</em>
return

GuiDropFiles:  <em>; 끌어 &amp; 떨구기를 지원합니다.</em>
Loop, Parse, A_GuiEvent, `n
{
    SelectedFileName := A_LoopField  <em>; 첫 번째 파일만 얻습니다 (여러 파일이 있을 경우에).</em>
    break
}
Gosub FileRead
return

GuiSize:
if (ErrorLevel = 1)  <em>; 창은 최소화되어 있습니다. 아무 필요도 없습니다.</em>
    return
<em>; 그렇지 않으면, 창은 크기가 변경되거나 최대화됩니다. 편집 콘트롤의 크기를을 그에 맞게 조절합니다.</em>
NewWidth := A_GuiWidth - 20
NewHeight := A_GuiHeight - 20
GuiControl, Move, MainEdit, W%NewWidth% H%NewHeight%
return

FileExit:     <em>; 사용자가 File 메뉴에서 "Exit"을 선택했습니다.</em>
GuiClose:  <em>; 사용자가 창을 닫았습니다.</em>
ExitApp</pre>
</div>
</body>
</html>
