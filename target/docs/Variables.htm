<!DOCTYPE HTML>
<html lang="ko">
<head>
<title>Variables and Expressions - Definition &amp; Usage | AutoHotkey</title>
<meta name="description" content="Learn details about variables, expressions, operators, built-in variables and capacity and memory of variables." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>변수와 표현식</h1>

<h2 id="toc">목차</h2>
<ul>
  <li><a href="#Intro">변수</a></li>
  <li><a href="#Expressions">표현식</a></li>
  <li><a href="#Operators">표현식 안의 연산자</a></li>
  <li><a href="#BuiltIn">내장 변수</a></li>
  <li><a href="#cap">변수의 가용성과 메모리</a></li>
</ul>
<span id="Variables"></span><h2 id="Intro">변수</h2>
<p>See <a href="Concepts.htm#variables">Variables</a> for general explanation and details about how variables work.</p>
<p id="assigning"><strong>변수 안에 변수를 저장하기</strong>: 문자열이나 숫자를 변수에 저장하려면, <a href="Language.htm#legacy-syntax">legacy</a> and <a href="Language.htm#expressions">expression</a>. The legacy method uses the <a href="commands/SetEnv.htm">equal sign operator (=)</a> to assign <a href="Language.htm#unquoted-text"><strong>unquoted</strong> literal strings</a> or variables enclosed in percent signs. 예를 들어:</p>
<pre>MyNumber = 123
MyString = 이것은 문자열입니다.
CopyOfVar = %Var%  <em>; 변수의 내용을 열람하려면 등호(=) 연산자와 함께 퍼센트 사인이 필요합니다.</em></pre>
<p>대조적으로, 표현식 할당은 <a href="commands/SetExpression.htm">쌍점-등호 연산자 (:=)</a>를 사용하여, 숫자와 <a href="Language.htm#strings"><strong>겹따옴표 붙인</strong> 문자열</a> 그리고 기타 유형의 <a href="Language.htm#expressions">표현식</a>을 저장합니다. 다음 예제는 기능적으로 앞의 예제와 동일합니다:</p>
<pre>MyNumber := 123
MyString := "이것은 기호 문자열입니다."
CopyOfVar := Var  <em>; 앞의 예와 다르게, 퍼센트 사인이  := 연산자에 사용되지 않습니다.</em></pre>
<p>더 명료하기 때문에 표현식 할당을 많은 사람들이 선호합니다. 그리고 표현식 할당이 지원하는 <a href="Language.htm#expressions">표현식 구문</a>이 다른 많은 언어의 표현식 구문과 거의 동일하기 때문입니다.</p>
<p>위에서 눈치 채셨겠지만 변수의 내용을 지우는 데에도 두 가지 방법이 있습니다 (즉, 변수를 비우려면):</p>
<pre>MyVar =
MyVar := ""</pre>
<p>위에서 빈 겹따옴표 쌍은 := 연산자에만 사용해야 하는데 = 연산자와 사용하면 변수 안에 두 개의 겹따옴표 문자가 기호 그대로 저장되어 버리기 때문입니다.</p>
<p id="retrieving"><strong>변수의 내용 열람하기</strong>: 값을 저장하는 두 가지 방법과 마찬가지로, 값을 열람하는 방법도 역시 <a href="Language.htm#legacy-syntax">legacy</a> and <a href="Language.htm#variables">expression</a>. The legacy method requires that each variable name be enclosed in percent signs to retrieve its contents. 예를 들어:</p>
<pre><a href="commands/MsgBox.htm">MsgBox</a> Var 변수의 값은 %Var% 입니다.
CopyOfVar = %Var%</pre>
<p>대조적으로, 표현식 열람은 변수 이름 둘레에 퍼센트 기호를 생략하지만, <a href="Language.htm#strings">기호 문자열</a>은 겹따옴표로 둘러야 합니다. 그래서, 다음은 앞 에제의 동등한 표현식입니다:</p>
<pre>MsgBox % "Var 변수의 값은 " . Var . " 입니다."  <em>; 두 개의 문자열을 결합하는데 마침표가 사용되었습니다.</em>
CopyOfVar := Var</pre>
<p>In the MsgBox line above, <a href="Language.htm#-expression">a percent sign and a space</a> is used to change the parameter from legacy to expression mode. This is necessary because the legacy method is used by default by all commands, except where otherwise documented.</p>
<p><strong>변수 비교하기</strong>: 다양한 종류의 비교에 관한 중요한 고지 사항, 특히 언제 괄호를 사용해야 하는가에 관한 정보는 아래의 표현식 섹션을 읽어 보십시오.</p>

<h2 id="Expressions">표현식</h2>
<p class="note">See <a href="Language.htm#expressions">Expressions</a> for a structured overview and further explanation.</p>
<p>표현식은 일련의 변수, 기호 문자열, 그리고/또는 기호 숫자에 하나 이상의 연산을 수행하는 데 사용됩니다.</p>
<p>변수 이름은 표현식에서 퍼센트 사인으로 둘러싸지 않습니다 (<a href="misc/Arrays.htm#pseudo">의사-배열</a>과 기타 <a href="#ref">이중 참조</a>는 제외합니다). 결과적으로, 기호 문자열은 겹따옴표로 둘러싸서 변수와 구별해야 합니다. 예를 들어:</p>
<pre>if (CurrentSetting &gt; 100 or FoundColor != "Blue")
    MsgBox 설정이 너무 높거나 잘못된 색이 존재합니다.</pre>
<p>위의 예제에서, "Blue"는 겹따옴표 안에 있는데 왜냐하면 기호 문자열이기 때문입니다. <em>실제로</em> 인용-문자를 기호 문자열 안에 포함하려면, 두 개의 겹따옴표를 연속으로 지정합니다. 다음 예와 같이 두 번 나타나야 합니다: <code>"She said, <span class="red">""</span>An apple a day.<span class="red">""</span>"</code>.</p>
<p class="warning"><strong>주의</strong>: There are several types of <a href="Language.htm#if-statement">If Statement</a> which look like expressions but are not.</p>
<p><strong>빈 문자열</strong>: 빈 문자열을 표현식에 지정하려면, 빈 겹따옴표 한 쌍을 사용합니다. 예를 들어, <code>if (MyVar != "")</code> 서술문은 <em>MyVar</em>가 비어 있지 않으면 참입니다. 그렇지만, <a href="commands/IfEqual.htm">전통적인-if</a>에서, 한 쌍의 빈 겹따옴표는 기호 그대로 간주합니다. 예를 들어 <code>if MyVar = ""</code>는 <em>MyVar</em>에 실제로 겹따옴표 쌍이 담겨 있을 경우에만 참입니다. 그래서, 변수가 비어있는지 전통적인-if로 점검하려면, 다음 예와 같이 오른쪽에 아무것도 없이 = 또는 !=를 사용하십시오: <code>if Var =</code>.</p>
<p>관련해서 말씀 드리자면, <code>(x +* 3)</code>와 같이 무효한 식은 빈 문자열을 산출합니다.</p>
<p><strong>표현식의 결과를 저장하기</strong>: 결과를 변수에 저장하려면, <a href="commands/SetExpression.htm">:= 연산자</a>를 사용합니다. 예를 들어:</p>
<pre>NetPrice := Price * (1 - Discount/100)</pre>
<p id="Boolean"><strong>불리언 값</strong>: 표현식을 참이나 거짓으로 평가할 필요가 있을 때 (IF-서술문처럼), 빈 또는 0인 결과는 거짓으로 간주되고 다른 모든 결과는 참으로 간주됩니다. 예를 들어, 서술문 <code>if ItemCount</code>는 ItemCount가 비어 있거나 0일 경우에만 거짓입니다. 비슷하게, 표현식 <code>if not ItemCount</code>는 그 반대 결과를 산출합니다.</p>
<p>NOT/AND/OR/&gt;/=/&lt;와 같은 연산자는 자동으로 참 또는 거짓 값을 생산합니다: 참에는 1 그리고 거짓에는 0을 산출합니다. 예를 들어, 다음 표현식에서, 변수 <em>Done</em>은 두 조건중 하나라도 참일 경우 1이 할당됩니다.:</p>
<pre>Done := A_Index &gt; 5 or FoundIt</pre>
<p>위에서 암시하듯이, 변수는 그냥 비우거나 0을 할당하면 거짓값을 담는데 사용할 수 있습니다. 이를 이용하여, 단축 서술문 <code>if Done</code>을 사용하면 변수 Done이 참인지 거짓인지 점검할 수 있습니다.</p>
<p><span id="True"></span><span id="False"></span>단어 <em>true</em>와 <em>false</em>는 내장 변수로서 각각 1과 0을 담고 있습니다. 다음 예제와 같이 스크립트를 더 읽기 쉽게 만들 수 있습니다:</p>
<pre>CaseSensitive := false
ContinueSearch := true</pre>
<p><strong>정수와 부동 소수점 수</strong>: 표현식 안에서, 숫자는 안에 소수점이 있으면 부동 소수점 수로 간주됩니다; 그렇지 않으면 정수로 취급합니다. 대부분의 연산자에 대하여 -- 예를 들어 덧셈과 곱셈 -- 두 입력중 하나라도 부동 소수점 수이면, 그 결과도 역시 부동 소수점 수가 됩니다.</p>
<p>표현식과 비-표현식 안에서 비슷하게 정수는 16진수나 십진수 형식으로 작성할 수 있습니다. 16진수는 모두 접두사 0x로 시작합니다. 예를 들어, <code>Sleep 0xFF</code>는 <code>Sleep 255</code>와 동등합니다. <span class="ver">[v1.0.46.11+]</span>: 과학적 표기법으로 작성된 부동 소수점 수를 인지합니다; 그러나 안에 소수점이 포함되어 있을 경우에만 인지합니다 (예, <code>1<strong>.</strong>0e4</code> 그리고 <code>-2<strong>.</strong>1E-4</code>).</p>
<p id="percent-space"><strong>강제로 표현식으로 만들기</strong>: 표현식은 매개변수에 사용할 수 있습니다. 직접적으로 지원하지 않더라도 (OutputVar 매개변수 제외) 표현식 앞에 퍼센트 사인과 스페이스 또는 퍼센트 사인과 탭을 두면 됩니다. <span class="ver">[v1.1.21+]</span>에서, 전통적인 IF 명령어를 제외하고 모든 명령어의 InputVar 매개변수에 이 접두사를 사용할 수 있습니다 (대신에 <a href="commands/IfExpression.htm">If (표현식)</a>을 사용하십시오). 이 테크닉은 종종 <a href="misc/Arrays.htm">배열</a>에 접근하는 데 사용됩니다. 예를 들어:</p>
<pre><a href="commands/FileAppend.htm">FileAppend</a>, % MyArray[i], My File.txt
<a href="commands/FileAppend.htm">FileAppend</a>, % MyPseudoArray%i%, My File.txt
<a href="commands/MsgBox.htm">MsgBox</a> % "The variable MyVar contains " . MyVar . "."
<a href="commands/Loop.htm">Loop</a> % Iterations + 1
<a href="commands/WinSet.htm">WinSet</a>, Transparent, % X + 100
<a href="commands/Control.htm">Control</a>, Choose, % CurrentSelection - 1</pre>

<h2 id="Operators">표현식 안의 연산자</h2>
<p class="note">See <a href="Language.htm#operators">Operators</a> for general information about operators.</p>
<p>Except where noted below, any blank value (empty string) or non-numeric value involved in a math operation is <strong>not</strong> assumed to be zero. 대신에, 에러로 취급합니다. 그 때문에 표현식의 일부가 빈 문자열로 평가됩니다. 예를 들어, 변수 X가 비어 있으면, 표현식 X+1은 1이 아니라 빈 값을 산출합니다.</p>
<p>For historical reasons, <em>quoted</em> numeric strings such as <code>"123"</code> are always considered non-numeric when used directly in an expression (but not when stored in a variable or returned by a function). This non-numeric attribute is propagated by <a href="#concat">concatenation</a>, so expressions like <code>"0x" n</code> also produce a non-numeric value (even when n contains valid hexadecimal digits). This problem can be avoided by assigning the value to a variable or passing it through a function like <a href="Functions.htm#Round">Round()</a>. Scripts should avoid using quote marks around literal numbers, as the behavior may change in a future version.</p>

<h3 id="operators">표현식 연산자 (우선순위가 높은 순서부터 나열합니다)</h3>
<table class="info">
  <tr>
    <th class="center">연산자</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="ref">
    <td class="center bold">%Var%</td>
    <td><p>변수가 표현식 안에서 퍼센트 사인에 둘러 싸여 있으면 (예, %Var%), 그 변수에 <u>들어 있는 것은 어떤 것이든 </u> 또다른 변수의 이름이나 부분 이름으로 간주합니다 (그런 변수가 없다면, %Var%는 빈 문자열로 결정됩니다). 이런 일은 다음 예와 같이 <a href="misc/Arrays.htm#pseudo">의사-배열</a>을 참조하는 데 자주 사용됩니다:</p>
      <pre>Var := MyArray%A_Index% + 100</pre>
      <p>하위 호환을 위해, "표현식일 수 있음"으로 문서화되어 있는 명령어 매개변수는 퍼센트 기호 안에 이름만 있는 변수에서 마치 퍼센트 사인이 없는 것처럼 취급합니다 (예, %Var%, 그러나 Array%i%는 아님). 괄호 안에 그 참조를 둘러싸면 이런 일을 피할 수 있습니다; 예, <code>Sleep (%Var%)</code>.</p>
      <p><span class="ver">[AHK_L 52+]:</span> 보통 변수 외에도, %Var%는 <a href="Concepts.htm#environment-variables">환경 변수</a>, 클립보드, 또는 <a href="#BuiltIn">예약/읽기-전용 변수</a>로 결정될 수 있습니다. revision 52이전에서, 이런 경우 %Var%는 빈 문자열을 산출했었습니다.</p></td>
  </tr>
  <tr>
    <td class="center bold">x.y</td>
    <td><span class="ver">[AHK_L 31+]:</span> <strong>객체 접근</strong>. <i>x</i> 객체에 메쏘드를 호출하거나 값을 설정하고 얻습니다. 여기에서 <i>y</i>는 기호 그대로의 값입니다. <a href="Objects.htm#Usage_Objects">객체 구문</a>을 참조하십시오.</td>
  </tr>
  <tr id="new">
    <td class="center bold">new</td>
    <td><span class="ver">[v1.1.00+]:</span> 또다른 객체로부터 상속받아 새 객체를 생성합니다. 예를 들어, <code>x := new y</code>는 종종 <code>x := {base: y}</code>와 동등합니다. <code>new</code>는 다음에 <code>GlobalClass.NestedClass</code>의 형태로 변수나 간단한 클래스 이름이 따라와야 합니다. 그리고 선택적으로 <code>x := new y(z)</code>에서와 같이 매개변수가 따라 옵니다 (여기에서 <code>y</code>는 사용가능하지만, 함수 이름은 아닙니다). 자세한 것은 <a href="Objects.htm#Custom_Objects">맞춤 객체</a>를 참조하십시오.</td>
  </tr>
  <tr id="IncDec">
    <td class="center bold">++<br>
    --</td>
    <td><strong>전위/후위 증감</strong>. 변수에서 1을 더하거나 뺍니다 (그러나 1.0.46 이전 버전이면, 이것은 오직 그 자체로 한 줄에 사용해야 합니다; 다른 연산자가 없어야 합니다). 연산자는 변수 이름의 앞이나 뒤에 나타납니다. 이름 <em>앞</em>에 나타나면, 연산이 즉시 수행되고 그 결과가 다음 연산에 사용됩니다. 예를 들어, <code>Var := ++X</code>는 X를 즉시 증가시킨 다음 그의 값을 <em>Var</em>에 할당합니다. 반대로, 증감 연산자가 변수 이름 <em>뒤에</em> 있으면 그 변수가 다음 연산에 사용되고 난 <em>후에</em> 연산이 수행됩니다. 예를 들어, <code>Var := X++</code>는 현재 X값을 <em>Var</em>에 할당하고 난 후에 X를 증가시킵니다. 하위 호환의 문제 때문에, ++ 과 -- 증감 연산자는 빈 변수를 0으로 취급합니다. 그러나 한 줄에 홀로 있을 때만 그렇습니다; 예를 들어, <code>y:=1, ++x</code> 그리고 <code>MsgBox % ++x</code>는 둘 다 x 가 비어 있을 때 빈 결과를 산출합니다.</td>
  </tr>
  <tr id="pow">
    <td class="center bold">**</td>
    <td>
      <p><strong>Power</strong>. 밑수와 지수 모두 십진 소수점을 담을 수 있습니다. 지수가 음수이면, 그 결과는 부동 소수점 수로 포맷됩니다. 밑수와 지수 둘 모두 정수일지라도 그렇습니다. **는 우선 순위가 단항 마이너스 보다 높기 때문에, <code>-2**2</code>는 <code>-(2**2)</code>로 평가되고 그래서 -4를 산출합니다. 그러므로, 기호 음수를 제곱하려면, <code>(-2)**2</code>와 같이 괄호로 둘러싸십시오.</p>
      <p class="note"><strong>주의</strong>: <code>(-2)**0.5</code>와 같이 음의 밑수가 분수 지수와 결합하는 것은 지원하지 않습니다; 빈 문자열이 산출될 것입니다. 그러나 <code>(-2)**2</code>와 <code>(-2)**2.0</code>는 둘 모두 지원합니다.</p>
      <p class="warning"><strong>주의</strong>: Unlike its mathematical counterpart, ** is left-associative in AutoHotkey v1. For example, <code>x ** y ** z</code> is evaluated as <code>(x ** y) ** z</code>.</p>
    </td>
  </tr>
  <tr id="unary">
    <td class="center bold">-<br>
    !<br>
    ~<br>
    &amp; *</td>
    <td><p><strong>Unary minus (-)</strong>: 뺄셈 연산자와 같은 심볼을 사용하지만, 단항 마이너스는 오직 하나의 항목에만 적용됩니다. 또는 다음 두 예제에서 보여주는 바와 같이 부분-표현식에만 적용됩니다: <code><strong>-</strong>(3 / <strong>-</strong>x)</code>. 관련하여 덧붙인다면, 표현식 안에서 단항 플러스 사인(+)은 무시됩니다.</p>
      <p><strong>Logical-not (!)</strong>: 피연산자가 비어 있거나 0이면, 논리적-not을 적용한 결과는 1입니다. 참("true")이라는 뜻입니다. 그렇지 않으면 그 결과는 0입니다 (false). 예를 들어: <code>!x or !(y and z)</code>. 주의: 단어 NOT은 <strong>!</strong>와 동의어입니다. 단 <strong>!</strong>가 더 우선 순위가 높습니다. <span class="ver">[v1.0.46+]</span>: <code><strong>!!</strong>Var</code>와 같이 연속적인 단항 연산자가 허용됩니다. 왜냐하면 오른쪽에서 왼쪽 순서로 평가되기 때문입니다.</p>
      <p><strong>Bitwise-not (~)</strong>: 피연산자의 각 비트를 뒤집습니다. 피연산자가 부동소수점 값이면, 먼저 정수로 자르고 나서 계산합니다. 피연산자가 0부터 4294967295 (0xffffffff) 사이이면, <u>부호 없는</u> 32-비트 값으로 취급됩니다. 그렇지 않으면 <u>부호 있는</u> 64-비트 값으로 취급됩니다. 예를 들어, <code>~0xf0f</code>는 0xfffff0f0 (4294963440)으로 평가됩니다.</p>
      <p id="amp"><strong>Address (&amp;)</strong>: <code>&amp;MyVar</code>는 메모리에서 <em>MyVar</em>의 내용이 있는 주소를 열람합니다. 이 주소는 전형적으로 <a href="commands/DllCall.htm#struct">DllCall 구조</a>에 사용됩니다. <code>&amp;MyVar</code>는 또 그 변수에 대한 이진 숫자를 캐싱하는 것을 불능으로 만듭니다. 수학 계산이나 숫치 비교에 사용되기라도 하면 수행성능이 떨어질 수 있기 때문입니다. 캐싱은 그의 주소가 바뀔 때마다 (예, <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a>를 통하여) 재활성화됩니다.</p>
      <p><strong>Dereference (*)</strong>: <code>*Expression</code>는 <code>Expression</code>이 숫치형 메모리 주소로 결정될 것이라고 간주합니다; 그 주소의 바이트를 0부터 255 사이의 숫자로 열람합니다 (주소가 0이면 언제나 0이 열람됩니다; 그러나 다른 무효한 주소는 모두 스크립트가 충돌할 수 있기 때문에 피해야 합니다). 그렇지만, <a href="commands/NumGet.htm">NumGet()</a>은 일반적으로 이진 숫자를 열람할 때 훨씬 더 수행성능이 좋습니다.</p></td>
  </tr>
  <tr id="MulDiv">
    <td class="center bold">*<br>
    /<br>
    //
    </td>
    <td><p><strong>곱셈 (*)</strong>: 입력이 모두 정수이면 그 결과도 정수입니다; 그렇지 않으면, 부동 소수점 수입니다.</p>
      <p id="divide"><strong>실수 나눗셈 (/)</strong>: <a href="commands/EnvDiv.htm">EnvDiv</a>와 다르게, 실수 나눗셈(true division)은 두 입력이 모두 정수라도 부동 소수점 수를 결과로 산출합니다. 예를 들어, <code>3/2</code>는 1이 아니라 1.5를 산출하고, <code>4/2</code>는 2가 아니라 2.0을 산출합니다.</p>
      <p id="FloorDivide"><strong>Floor divide (//)</strong>: 이중-정사선 연산자는 두 입력이 모두 정수이면 성능이 높은 정수 나눗셈을 수행합니다. 예를 들어, <code>5//3</code>는 1이고 <code>5//-3</code>은 -1입니다. 입력 중 하나가 부동 소수점 형식이면, 부동 소수점 나눗셈이 수행되고 그 결과는 왼쪽으로 가장 가까운 정수로 잘라냅니다. 예를 들면, <code>5//3.0</code>은 1.0이고 <code>5.0//-3</code>은 -2.0입니다. 이 부동 소수점 나누셈이 결과가 정수임에도 불구하고, 부동 소수점 형식으로 저장됩니다. 그래서 그 값을 사용하는 것들은 모두 부동 소수점 수라고 인식합니다. 나머지 연산자(modulo)에 관한 것은 <a href="commands/Math.htm#Mod">mod()</a>를 참조합니다.</p>
    <p><a href="#AssignOp">*= 연산자와 /= 연산자</a>는 간략하게 한 변수 안의 값을 다른 값으로 곱하거나 나누는 방법입니다. 예를 들어, <code>Var*=2</code>는 <code>Var:=Var*2</code>와 같은 결과를 산출합니다 (그렇지만 전자가 수행성능이 더 좋습니다).</p>
    <p>0으로 나누면 빈 결과 (빈 문자열)이 산출됩니다.</p></td>
  </tr>
  <tr id="AddSub">
    <td class="center bold">+<br>
    -</td>
    <td><p><strong>더하고(+)</strong> <strong>뺍니다 (-)</strong>. 관련해서 말씀 드리자면, <a href="#AssignOp">+= 그리고 -= 연산자</a>는 간략하게 변수를 증가시키거나 감소시키는 방법입니다. 예를 들어, <code>Var+=2</code>는 <code>Var:=Var+2</code>와 같은 결과를 생산합니다 (그렇지만 전자가 더 수행성능이 좋습니다). 비슷하게, <a href="#IncDec">Var++, Var--, ++Var, 또는 --Var</a>을 사용하면 변수를 1씩 증가시키거나 감소시킬 수 있습니다.</p>
    </td>
  </tr>
  <tr id="bitwise">
    <td class="center bold">&lt;&lt;<br>
    &gt;&gt;</td>
    <td><strong>왼쪽으로 비트 이동 (&lt;&lt;)</strong> 그리고 <strong>오른쪽으로 비트 이동 (&gt;&gt;)</strong>. 예를 들어: <code>Value1 &lt;&lt; Value2</code>. 부동 소수점 수 입력은 먼저 정수로 잘라내고 나서 계산됩니다. 왼쪽으로 이동 (<strong>&lt;&lt;</strong>)은 <em>Value1</em>을 "<em>Value2</em>의 제곱". 만큼 곱하는 것과 동등합니다. 오른쪽으로 이동은 (<strong>&gt;&gt;</strong>) <em>Value1</em>을 "<em>Value2</em>의 제곱" 만큼 나누고 그 결과를 왼쪽으로 가장 가까운 정수로 결정하는 것과 동등합니다; 예를 들어, <code>-3&gt;&gt;1</code>은 -2입니다.</td>
  </tr>
  <tr>
    <td class="center bold">&amp;<br>
    ^<br>
    |
    </td>
    <td><strong>비트별-and (&amp;)</strong>, <strong>비트별-배타적-or (^)</strong>, 그리고 <strong>비트별-or (|)</strong>. 계통도에서, <strong>&amp;</strong>가 우선 순위가 제일 높고 <strong>|</strong>가 제일 낮습니다. 부동 소수점 수 입력은 먼저 정수로 잘라내고 나서 계산됩니다.</td>
  </tr>
  <tr id="concat">
    <td class="center bold">.</td>
    <td><p><strong>결합</strong>. 점(dot) 연산자는 두 개의 항목을 하나의 문자열로 결합하는 데 사용됩니다 (점의 양쪽에 적어도 하나의 공간이 있어야 합니다). 점을 생략해도 같은 결과를 얻을 수 있습니다 (단 <code>x <strong>-</strong>y</code>와 같이 애매하거나, 오른쪽에 있는 항목 앞에 ++ 또는 --이 있는 경우는 제외합니다.). 점이 생략되면, 병합될 항목 사이에 적어도 공간 하나가 있어야 합니다.<br>
      예제 (표현식 방법): <code>Var := "The color is " <strong>.</strong> FoundColor</code><br>
      예제 (전통적 방법): <code>Var = The color is %FoundColor%</code></p>
        <p>하위-표현식도 역시 결합할 수 있습니다. 예를 들어: <code>Var := "The net price is " <strong>.</strong> Price * (1 - Discount/100)</code>.</p>
        <p>점으로 (또는 기타 다른 연산자로) 시작하는 줄은 자동으로 윗 줄에 <a href="Scripts.htm#continuation">추가됩니다</a>.</p></td>
  </tr>
  <tr id="regex">
    <td class="center bold">~=</td>
    <td><span class="ver">[AHK_L 31+]:</span> <a href="commands/RegExMatch.htm">RegExMatch()</a>에 대한 약자입니다. 예를 들어, <code>"abc123" ~= "\d"</code>는 ErrorLevel을 0으로 설정하고 (첫 번째 숫자의 위치) 4를 산출합니다. <span class="ver">[v1.1.03]</span> 이전 버전에서, 이 연산자는 <em>등호</em> (=) 연산자와 우선순위가 같았고 완벽하게 문서화되어 있지 않았습니다.</td>
  </tr>
  <tr id="compare">
    <td class="center bold">&gt;&nbsp;&nbsp;&nbsp;&lt;<br>
    &gt;= &lt;=</td>
    <td>
      <p><strong>초과 (&gt;)</strong>, <strong>미만 (&lt;)</strong>, <strong>이상 (&gt;=)</strong>, 그리고 <strong>이하 (&lt;=)</strong>. If both inputs are <a href="Concepts.htm#numbers">numbers</a> or <a href="Concepts.htm#numeric-strings">numeric strings</a>, they are compared numerically; otherwise they are compared alphabetically. 비교는 대소문자를 구분하지 않습니다. <a href="commands/StringCaseSense.htm">StringCaseSense</a>가 켜져 있으면 대소문자를 구분해서 비교합니다. 다음 참조: <a href="commands/Sort.htm">Sort</a></p>
      <p class="note"><strong>주의</strong>: In AutoHotkey v1, a quoted string (or the result of concatenating with a quoted string) is never considered numeric when used directly in an expression.</p>
    </td>
  </tr>
  <tr id="equal">
    <td class="center bold">=<br>
    ==<br>
    &lt;&gt; !=</td>
    <td>
      <p><strong>등호 (=)</strong>, <strong>대소문자-구분-등호 (==)</strong>, 그리고 <strong>같지-않음 (&lt;&gt; 또는 !=)</strong>. If both inputs are <a href="Concepts.htm#numbers">numbers</a> or <a href="Concepts.htm#numeric-strings">numeric strings</a>, they are compared numerically; otherwise they are compared alphabetically. 연산자 <strong>!=</strong>와 <strong>&lt;&gt;</strong>는 기능면에서 동일합니다. <strong>==</strong> 연산자는 <strong>=</strong>와 동일하게 행위합니다. 입력 중 하나라도 숫자가 아닌 경우는 제외하는데, 그 경우 <strong>==</strong>는 언제나 대소문자를 구분하고 <strong>=</strong>는 언제나 대소문자를 구분하지 않습니다 (대소문자의 구분은 <a href="commands/StringCaseSense.htm">StringCaseSense</a>에 달려 있습니다). 대조적으로, <strong>&lt;&gt;</strong>와 <strong>!=</strong>는 <a href="commands/StringCaseSense.htm">StringCaseSense</a>에 순종합니다.</p>
      <p class="note"><strong>주의</strong>: In AutoHotkey v1, a quoted string (or the result of concatenating with a quoted string) is never considered numeric when used directly in an expression.</p>
      <p class="warning"><strong>비추천:</strong> 이 &lt;&gt; 연산자는 새 스크립트에 사용을 추천하지 않습니다. 대신 != 연산자을 사용하십시오.</p>
    </td>
  </tr>
  <tr id="not">
    <td class="center bold">NOT</td>
    <td><strong>논리적-NOT</strong>. 우선 순위가 낮은 점을 빼고는 <strong>!</strong> 연산자와 동일합니다 예를 들어, <code>not (x = 3 or y = 3)</code>는 <code><strong>!</strong>(x = 3 or y = 3)</code>와 같습니다.</td>
  </tr>
  <tr id="and">
    <td class="center bold">AND<br>
    &amp;&amp;</td>
    <td>둘 모두 <strong>논리적-AND</strong>입니다. 예를 들어: <code>x &gt; 3 and x &lt; 10</code>. 수행성능을 개선하기 위해, <a href="Functions.htm#ShortCircuit">단축-회로 평가</a>가 적용됩니다. 또한, AND/OR/&amp;&amp;/|| (또는 기타 다른 연산자)로 시작하는 줄은 자동으로 윗 줄에 <a href="Scripts.htm#continuation">추가됩니다</a>.</td>
  </tr>
  <tr id="or">
    <td class="center bold">OR<br>
    ||</td>
    <td>둘 모두 <strong>논리적-OR</strong>입니다. 예를 들어: <code>x &lt;= 3 or x &gt;= 10</code>. 수행성능을 개선하기 위해, <a href="Functions.htm#ShortCircuit">단축-회로 평가</a>가 적용됩니다.</td>
  </tr>
  <tr id="ternary">
    <td class="center bold">?:</td>
    <td><strong>삼진 연산자</strong> <span class="ver">[v1.0.46+]</span>. 이 연산자는 <a href="commands/IfExpression.htm">if-else 서술문</a>을 간략하게 교체한 것입니다. 왼쪽의 조건을 평가해 보고 두 분기 중에서 어느 쪽을 최종 결과로 할지 결정합니다. 예를 들어, <code>var := x&gt;y ? 2 : 3</code>는 x가 y보다 크면 2를 <em>Var</em>에 저장하고; 그렇지 않으면 3을 저장합니다. 수행 성능을 개선하기 위하여, 오직 참인 분기만 평가됩니다 (<a href="Functions.htm#ShortCircuit">단축-회로 평가</a>를 참조하십시오).</td>
  </tr>
  <tr id="AssignOp">
    <td class="center bold">:=<br>
        +=<br>
        -=<br>
        *=<br>
        /=<br>
        //=<br>
        .=<br>
        |=<br>
        &amp;=<br>
        ^=<br>
        &gt;&gt;=<br>
        &lt;&lt;=
    </td>
    <td><p><strong>할당</strong>. 변수의 내용에 연산을 수행하고 그 결과를 다시 같은 변수에 저장합니다 (그러나 1.0.46 이전 버전에서는 한 줄 위에서 가장 왼쪽 연산자로만 사용할 수 있었습니다. 그리고 연산자를 앞쪽 다섯 개까지만 지원했습니다.). 가장 단순한 할당 연산자는 <a href="commands/SetExpression.htm">쌍점-등호 (:=)</a>입니다. 표현식의 결과를 변수에 저장합니다. 다른 연산자들이 어떤 일을 하는지 그 설명은 이 표에서 관련 엔트리를 참조하십시오. 예를 들어, <code>Var //= 2</code>는 <a href="#FloorDivide">바닥 나눗셈</a>을 수행하여 <em>Var</em>를 2로 나눈 다음, 그 결과를 다시 <em>Var</em>에 저장합니다. 비슷하게, <code>Var <strong>.=</strong> "abc"</code>는<code>Var := Var <strong>.</strong> "abc"</code>를 간략하게 작성한 것입니다.</p>
      <p>대부분의 다른 연산자와 다르게, 할당은 오른쪽에서 왼쪽으로 평가됩니다. 결과적으로 <code>Var1 := Var2 := 0</code>와 같은 줄은 제일 먼저 0을 <em>Var2</em>에 할당한 다음 <em>Var2</em>를 <em>Var1</em>에 할당합니다.</p>
    <p>할당을 다른 연산자의 입력으로 사용하면, 그의 값은 변수 자체입니다. 예를 들어, 표현식 <code>(Var+=2) &gt; 50</code>는 <em>Var</em>에 새로-증가된 값이 50을 초과할 경우에만 참입니다. 이렇게 하면 할당을 <a href="Functions.htm#ByRef">ByRef</a>로 건넬 수 있는데, 즉, 그의 <a href="#amp">주소</a>로 건넬 수 있습니다; 예를 들어: <code>&amp;(x:="abc")</code>.</p>
    <p>할당 연산자의 우선순위는 구문 에러를 피하거나 보다 직관적인 행위를 제공하면 자동으로 높아집니다. 예를 들어: <code>not x:=y</code>는 <code>not (x:=y)</code>로 평가됩니다. 비슷하게, <code>++Var := X</code>는 <code>++(Var := X)</code>으로 평가됩니다; 그리고 <code>Z&gt;0 ? X:=2 : Y:=2</code>는 <code>Z&gt;0 ? (X:=2) : (Y:=2)</code>으로 평가됩니다.</p>
    <p>하위 호환의 문제 때문에 야기되는 알려진 제한이 있습니다 (미래의 버전에서는 해결될 수 있습니다): 1) <strong>/=</strong>가 표현식에서 가장 왼쪽의 연산자이고 <a href="#comma">다중-서술문 표현식</a>의 일부가 아니면, <a href="#FloorDivide">바닥 나눗셈(floor division)</a>을 수행합니다. 입력 중 하나라도 부동 소수점 수가 아니어야 합니다 (다른 경우는 모두, <strong>/=</strong>는 <a href="#divide">실수 나눗셈(true division)</a>을 합니다.); 2) <a href="commands/EnvAdd.htm">날짜/시간 계산</a>을 <strong>+=</strong>과 <strong>-=</strong> 이 지원합니다. 그러나 오직 그 연산자가 한 줄의 가장 왼쪽에 홀로 있을 때만 지원합니다; 3) 연산자 <strong>+=</strong>, <strong>-=</strong>, 그리고 <strong>*=</strong> 는 빈 변수를 0으로 취급합니다. 그러나 한 줄에 홀로 있을 경우에만 그렇습니다; 예를 들어, <code>y:=1, x+=1</code>와 <code>MsgBox % x-=3</code>는 둘 다 x가 비어 있을 때 빈 결과를 산출합니다.</p></td>
  </tr>
  <tr id="comma">
    <td class="center bold">,</td>
    <td><p><strong>쉼표 (다중-서술문)</strong> <span class="ver">[v1.0.46+]</span>. 쉼표를 사용하면 여러 하위 표현식을 한 줄에 작성할 수 있습니다. 다중 할당이나 함수 호출을 그룹짓는데 자주 사용됩니다. 예를 들어: <code>x:=1<strong>,</strong> y+=2<strong>,</strong> ++index, MyFunc()</code>. 그런 서술문들은 왼쪽에서 오른쪽으로 순서대로 실행됩니다.</p>
      <p class="note"><strong>주의</strong>: 쉼표로 (또는 다른 연산자로) 시작하는 줄은 자동으로 윗 줄에 <a href="Scripts.htm#continuation">추가됩니다</a>. 다음 참조: <a href="#CommaPerf">쉼표의 연산 성능</a>.</p>
      <p><span class="ver">[v1.0.46.01+]</span>: 쉼표 다음에 곧바로 변수가 따라 오고 다음에 등호 사인이 오면, 그 등호 사인은 자동으로 <a href="commands/SetExpression.htm">할당 (:=)</a>으로 취급됩니다. 예를 들어, 다음은 모두 할당입니다: <code>x:=1, y=2, a=b=c</code>. 새 스크립트는 이 행위에 의존하면 안됩니다. 나중에 변경될 수도 있기 때문입니다. 규칙은 오직 평범한 변수에만 적용될 뿐 <a href="#ref">이중-참조(double-derefs)</a>에는 적용되지 않습니다. 그래서 다음은 오직 하나의 할당만 담겨 있습니다: <code>x:=1, %y%=2</code></p></td>
  </tr>
</table>
<p>The following types of sub-expressions override precedence/order of evaluation:</p>
<table class="info">
  <tr>
    <th class="center">Expression</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td class="center"><strong>(</strong><em>expression</em><strong>)</strong></td>
    <td><p>Any sub-expression enclosed in parentheses. For example, <code>(3 + 2) * 2</code> forces <code>3 + 2</code> to be evaluated first.</p></td>
  </tr>
  <tr>
    <td class="center"><p><strong>mod()<br>
        round()<br>
    abs()</strong></p></td>
    <td><strong>Function call</strong>. The function name must be immediately followed by an open-parenthesis, without any spaces or tabs in between. For details, see <a href="Functions.htm">Functions</a>.</td>
  </tr>
  <tr>
    <td class="center"><p><strong>%</strong><em>func</em><strong>%()</strong></p></td>
    <td>See <a href="Functions.htm#DynCall">Dynamically Calling a Function</a>.</td>
  </tr>
  <tr>
    <td class="center"><em>func</em><strong>.()</strong></td>
    <td><p><strong>Deprecated:</strong> This syntax is not recommended for use. Use <code>%func%()</code> (for function names and objects) or <code>func.Call()</code> (for function objects) instead.</p>
    <p><span class="ver">[AHK_L 48+]:</span> 객체 <i>func</i>에서 빈 이름의 메쏘드를 호출하려고 시도합니다. 관례적으로, 객체의 "기본" 메쏘드가 호출됩니다. <i>func</i>에 객체가 없다면, 대신에 <a href="Objects.htm#Default_Base_Object">기본 베이스 객체</a>가 요청됩니다.</p>
    <p><span class="ver">[v1.0.95+]:</span> <i>func</i>에 함수 이름이 있다면, 그 함수가 호출됩니다.</p></td>
  </tr>
  <tr>
    <td class="center">Fn(<strong><em>Params</em>*</strong>)</td>
    <td><p><span class="ver">[AHK_L 60+]:</span> <a href="Functions.htm#VariadicCall">Variadic function call</a>. <em>Params</em> is an array (object) containing parameter values.</p></td>
  </tr>
  <tr>
    <td class="center"><strong>x[y]<br>[a, b, c]</strong></td>
    <td>
      <p><span class="ver">[AHK_L 31+]:</span> <strong>Member access</strong>. Get or set a value or call a method of object <i>x</i>, where <i>y</i> is a parameter list (typically an array index or key) or an expression which returns a method name.</p>
      <p><span class="ver">[v1.0.97+]:</span> <strong>Array literal</strong>. If the open-bracket is not preceded by a value (or a sub-expression which yields a value), it is interpreted as the beginning of an array literal. For example, <code>[a, b, c]</code> is equivalent to <code>Array(a, b, c)</code> (a, b and c are variables).</p>
      <p>See <a href="Objects.htm#Usage_Simple_Arrays">array syntax</a> and <a href="Objects.htm#Usage_Objects">object syntax</a> for more details.</p>
    </td>
  </tr>
  <tr>
    <td class="center"><strong>{a: b, c: d}</strong></td>
    <td><p><span class="ver">[v1.0.97+]:</span> <strong>Object literal</strong>. Create an object or associative array. For example, <code>x := {a: b}</code> is equivalent to <code>x := Object("a", b)</code> or <code>x := Object(), x.a := b</code>. See <a href="Objects.htm#Usage_Associative_Arrays">Associative Arrays</a> for details.</p></td>
  </tr>
</table>
<br>
<p id="CommaPerf"><strong>수행 성능</strong>: <span class="ver">[v1.0.48+]</span>: 쉼표 연산자는 보통 별도의 표현식을 작성하는 것보다 더 빠릅니다. 특히 한 변수를 또다른 변수에 할당할 때 그렇습니다 (예, <code>x:=y, a:=b</code>). 표현식이 모이고 모여 하나의 표현식으로 결합될 수록 수행성능이 향상됩니다; 예를 들어, 다섯개나 열 개의 단순한 표현식을 하나의 표현식으로 결합하면 35% 정도 더 빠릅니다.</p>

<h2 id="BuiltIn">내장 변수</h2>
<p>The variables below are built into the program and can be referenced by any script.</p>
<p class="note">See <a href="Concepts.htm#built-in-variables">Built-in Variables</a> for general information.</p>
<h3 id="BuiltIn_TOC">목차</h3>
<ul>
  <li>특수 문자: <a href="#Space">A_Space</a>, <a href="#Tab">A_Tab</a></li>
  <li>스크립트 특성: <a href="#CommandLine">명령줄 매개변수</a>, <a href="#WorkingDir">A_WorkingDir</a>, <a href="#ScriptDir">A_ScriptDir</a>, <a href="#ScriptName">A_ScriptName</a>, <a href="#prop">(...기타 등등...)</a></li>
  <li>날짜와 시간: <a href="#YYYY">A_YYYY</a>, <a href="#MM">A_MM</a>, <a href="#DD">A_DD</a>, <a href="#Hour">A_Hour</a>, <a href="#Min">A_Min</a>, <a href="#Sec">A_Sec</a>, <a href="#date">(...기타 등등...)</a></li>
  <li>스크립트 설정: <a href="#IsSuspended">A_IsSuspended</a>, <a href="#BatchLines">A_BatchLines</a>, <a href="#ListLines">A_ListLines</a>, <a href="#TitleMatchMode">A_TitleMatchMode</a>, <a href="#settings">(...기타 등등...)</a></li>
  <li>User Idle Time: <a href="#TimeIdle">A_TimeIdle</a>, <a href="#TimeIdlePhysical">A_TimeIdlePhysical</a>, <a href="#TimeIdleKeyboard">A_TimeIdleKeyboard</a>, <a href="#TimeIdleMouse">A_TimeIdleMouse</a></li>
  <li>GUI 창과 메뉴 바: <a href="#Gui">A_Gui</a>, <a href="#GuiControl">A_GuiControl</a>, <a href="#GuiEvent">A_GuiEvent</a>, <a href="#EventInfo">A_EventInfo</a>, <a href="#gui">(...기타 등등...)</a></li>
  <li>핫키, 핫스트링, 그리고 맞춤 메뉴 항목: <a href="#ThisHotkey">A_ThisHotkey</a>, <a href="#EndChar">A_EndChar</a>, <a href="#ThisMenuItem">A_ThisMenuItem</a>, <a href="#h">(...기타 등등...)</a></li>
  <li>운영 체제와 사용자 정보: <a href="#OSVersion">A_OSVersion</a>, <a href="#Screen">A_ScreenWidth</a>, <a href="#Screen">A_ScreenHeight</a>, <a href="#os">(...기타 등등...)</a></li>
  <li>기타: <a href="#Cursor">A_Cursor</a>, <a href="#Caret">A_CaretX</a>, <a href="#Caret">A_CaretY</a>, <a href="#Clipboard">Clipboard</a>, <a href="#ClipboardAll">ClipboardAll</a>, <a href="#ErrorLevel">ErrorLevel</a>, <a href="#misc">(...기타 등등...)</a></li>
  <li>회돌이: <a href="#Index">A_Index</a>, <a href="#loop">(...기타 등등...)</a></li>
</ul>
<h3 id="Special_Characters">특수 문자</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="Space">
    <td>A_Space</td>
    <td>이 변수는 스페이스 문자가 하나 담겨 있습니다. 자세한 것은 <a href="commands/AutoTrim.htm">AutoTrim</a>을 참조하십시오.</td>
  </tr>
  <tr id="Tab">
    <td>A_Tab</td>
    <td>이 변수는 탭 문자 하나가 담겨 있습니다. 자세한 것은 <a href="commands/AutoTrim.htm">AutoTrim</a>을 참조하십시오.</td>
  </tr>
</table>
<h3 id="prop">스크립트 특성</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="CommandLine">
    <td>1, 2, 3, 등등.</td>
    <td>이 변수들은 스크립트가 명령어줄 매개변수와 함께 기동할 때마다 자동으로 생성됩니다. 마치 보통의 변수 이름처럼 똑같이 참조하고 변경할 수 있습니다 (예: %1%), but cannot be referenced directly in an <a href="#Expressions">expression</a>. 변수 %0%에는 건네어진 매개변수의 개수가 담겨 있습니다 (아무것도 없으면 0입니다). 자세한 것은 <a href="Scripts.htm#cmd">명령어 줄 매개변수</a>를 참조하십시오.</td>
  </tr>
  <tr id="Args">
    <td>A_Args<br><span class="ver">[v1.1.27+]</span></td>
    <td>Contains an <a href="Objects.htm#Usage_Simple_Arrays">array</a> of command line parameters. For details, see <a href="Scripts.htm#cmd">Passing Command Line Parameters to a Script</a>.</td>
  </tr>
  <tr id="WorkingDir">
    <td>A_WorkingDir</td>
    <td>스크립트의 현재 작업 디렉토리로서, 기본값으로 여기에서 파일에 접근합니다. 마지막의 역사선은 루트 디렉토리가 아닌 한 포함되지 않습니다. 다음은 두 개의 예입니다: C:\ 그리고 C:\My Documents. <a href="commands/SetWorkingDir.htm">SetWorkingDir</a>를 사용하면 작업 디렉토리를 바꿀 수 있습니다.</td>
  </tr>
  <tr id="ScriptDir">
    <td>A_ScriptDir</td>
    <td>현재 스크립트가 위치한 디렉토리의 완전한 경로입니다. 마지막의 역사선은 생략합니다 (루트 디렉토리도 마찬가지로 생략합니다).</td>
  </tr>
  <tr id="ScriptName">
    <td>A_ScriptName</td>
    <td>
      <p>현재 스크립트의 파일 이름입니다. 경로가 없습니다. 예, MyScript.ahk</p>
      <p>If the script is <a href="Scripts.htm#ahk2exe">compiled</a> or <a href="Program.htm#embedded-scripts">embedded</a>, this is the name of the current executable file.</p>
    </td>
  </tr>
  <tr id="ScriptFullPath">
    <td>A_ScriptFullPath</td>
    <td>
      <p>The full path of the current script, e.g. C:\Scripts\My Script.ahk</p>
      <p>If the script is <a href="Scripts.htm#ahk2exe">compiled</a> or <a href="Program.htm#embedded-scripts">embedded</a>, this is the full path of the current executable file.</p>
    </td>
  </tr>
  <tr id="ScriptHwnd">
    <td>A_ScriptHwnd<br><span class="ver">[v1.1.01+]</span></td>
    <td>스크립트의 숨은 <a href="Program.htm#main-window">메인 창</a>의 유일한 ID (HWND/핸들).</td>
  </tr>
  <tr id="LineNumber">
    <td>A_LineNumber</td>
    <td><p>스크립트 안에서 현재 실행중인 줄의 번호입니다 (또는 그의 <a href="commands/_Include.htm">#Include 파일 중 하나입니다</a>). 이 줄 번호는 <a href="commands/ListLines.htm">ListLines</a>이 보여주는 줄 번호와 일치합니다; 다음 예제와 같이 에러를 보고할 경우에 유용하게 사용할 수 있습니다: <code>MsgBox 로그 파일에 기록할 수 없었음 (줄 번호: %A_LineNumber%)</code>.</p>
    <p><a href="Scripts.htm#ahk2exe">컴파일된 스크립트는</a> 자신의 모든 <a href="commands/_Include.htm">#Include 파일</a>들을 하나의 커다란 스크립트로 병합해 넣기 때문에, 비-컴파일 모드에서 실행할 때와 줄 번호가 다를 수 있습니다.</p></td>
  </tr>
  <tr id="LineFile">
    <td>A_LineFile</td>
    <td>
      <p>The full path and name of the file to which <a href="#LineNumber">A_LineNumber</a> belongs. If the script was loaded from an external file, this is the same as <a href="#ScriptFullPath">A_ScriptFullPath</a> unless the line belongs to one of the script's <a href="commands/_Include.htm">#Include files</a>.</p>
      <p>If the script was <a href="Scripts.htm#ahk2exe">compiled</a> based on a <a href="Scripts.htm#ahk2exe-base">.bin file</a>, this is the full path and name of the current executable file, the same as <a href="#ScriptFullPath">A_ScriptFullPath</a>.</p>
      <p><span class="ver">[v1.1.34+]:</span> If the script is <a href="Program.htm#embedded-scripts">embedded</a>, A_LineFile contains an asterisk (*) followed by the resource name; e.g. *#1</p>
    </td>
  </tr>
  <tr id="ThisFunc">
    <td>A_ThisFunc<br>
    <span class="ver">[v1.0.46.16+]</span></td>
    <td>현재 실행 중인 <a href="Functions.htm">사용자-정의 함수</a>의 이름입니다 (없으면 비어 있습니다); 예를 들어: MyFunction. 다음 참조: <a href="commands/IsFunc.htm">IsFunc()</a></td>
  </tr>
  <tr id="ThisLabel">
    <td>A_ThisLabel<br>
    <span class="ver">[v1.0.46.16+]</span></td>
    <td>현재 실행 중인 <a href="misc/Labels.htm">라벨</a> (서브루틴)의 이름입니다 (없으면 비어 있습니다); 예를 들어: MyLabel. 스크립트가 <a href="commands/Gosub.htm">Gosub</a>/<a href="commands/Return.htm">Return</a> 또는 <a href="commands/Goto.htm">Goto</a>를 실행할 때마다 갱신됩니다. 또 자동으로-호출되는 라벨에 대해서도 갱신됩니다. 여기에는 <a href="commands/SetTimer.htm">타이머</a>, <a href="commands/Gui.htm#DefaultWin">GUI 쓰레드</a>, <a href="commands/Menu.htm">메뉴 항목</a>, <a href="Hotkeys.htm">핫키</a>, <a href="Hotstrings.htm">핫스트링</a>, <a href="commands/OnClipboardChange.htm#label">OnClipboardChange 라벨</a>, 그리고 <a href="commands/OnExit.htm#command">OnExit 라벨</a>이 있습니다. 그렇지만, 실행이 위의 자동-호출 라벨로부터 또다른 라벨로 "떨어지는"경우 A_ThisLabel는 갱신되지 않습니다; 그런 일이 일어나면, A_ThisLabel은 이전의 값을 유지합니다. 다음 참조: <a href="#ThisHotkey">A_ThisHotkey</a> 그리고 <a href="commands/IsLabel.htm">IsLabel()</a></td>
  </tr>
  <tr id="AhkVersion">
    <td>A_AhkVersion</td>
    <td>1.0.22 이전 버전에서, 이 변수는 비어 있습니다. 그렇지 않으면, 스크립트를 실행하고 있는 오토핫키의 버전이 담깁니다. 예, 1.0.22. <a href="Scripts.htm#ahk2exe">컴파일된 스크립트</a>의 경우, 원래 컴파일에 사용된 버전이 보고됩니다. 버전 번호의 형식을 보고 스크립트는 A_AhkVersion이 다음 예와 같이 "&gt;" 또는 "&gt;="로 최소한의 버전 번호보다 큰지 점검할 수 있습니다: <code>if A_AhkVersion &gt;= 1.0.25.07</code>.</td>
  </tr>
  <tr id="AhkPath">
    <td>A_AhkPath</td>
    <td>
      <p>For non-compiled or <a href="Program.htm#embedded-scripts">embedded</a> scripts: 현재 스크립트를 실제로 실행중인 EXE 파일의 이름과 전체 경로입니다. 예를 들어: C:\Program Files\AutoHotkey\AutoHotkey.exe</p>
      <p>For <a href="Scripts.htm#ahk2exe">compiled scripts</a> based on a <a href="Scripts.htm#ahk2exe-base">.bin file</a>, the value is determined by reading the installation directory from the registry and appending "\AutoHotkey.exe". If AutoHotkey is not installed, the value is blank. The example below is equivalent:</p>
      <pre>RegRead InstallDir, HKLM\SOFTWARE\AutoHotkey, InstallDir
AhkPath := ErrorLevel ? "" : InstallDir "\AutoHotkey.exe"</pre>
      <p><span class="ver">[v1.1.34+]:</span> For compiled scripts based on an .exe file, A_AhkPath contains the full path of the compiled script. This can be used in combination with <a href="Scripts.htm#SlashScript">/script</a> to execute external scripts. To instead locate the installed copy of AutoHotkey, read the registry as shown above.</p>
    </td>
  </tr>
  <tr id="IsUnicode">
    <td>A_IsUnicode</td>
    <td><p>문자열이 유니코드 (16-비트)이면 1이 ANSI (8-비트)이면 빈 문자열이 담깁니다 (<a href="#Boolean">거짓</a>으로 간주됨). 문자열의 형식은 스크립트를 실행하는 데 사용된 AutoHotkey.exe 버전에 따라 다릅니다. 컴파일된 스크립트라면, 컴파일에 사용된 실행파일에 따라 다릅니다.</p>
    <p>For ANSI executables prior to <span class="ver">[v1.1.06]</span>, A_IsUnicode was left undefined; that is, the script could assign to it, and attempting to read it could trigger a <a href="commands/_Warn.htm">UseUnsetGlobal warning</a>. In later versions it is always defined and is read-only.</p></td>
  </tr>
  <tr id="IsCompiled">
    <td>A_IsCompiled</td>
    <td><p>스크립트가 <a href="Scripts.htm#ahk2exe">컴파일 된 EXE</a>로 실행되면 1이 그렇지 않으면 빈 문자열이 담깁니다 (<a href="#Boolean">거짓</a>으로 간주).</p>
    <p>For non-compiled scripts prior to <span class="ver">[v1.1.06]</span>, A_IsCompiled was left undefined; that is, the script could assign to it, and attempting to read it could trigger a <a href="commands/_Warn.htm">UseUnsetGlobal warning</a>. In later versions it is always defined and is read-only.</p></td>
  </tr>
  <tr id="ExitReason">
    <td>A_ExitReason</td>
    <td>스크립트를 끝내게 된 가장 최근의 이유입니다. 이 변수는 스크립트에 <a href="commands/OnExit.htm#command">OnExit</a> 서브루틴이 있고 그 서브루틴이 현재 실행중이거나 종료 시도로 적어도 한 번 호출된 적이 없는 한, 비어 있습니다. 자세한 것은 <a href="commands/OnExit.htm#command">OnExit</a>을 참조하십시오.</td>
  </tr>
</table>
<h3 id="date">날짜와 시간</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="YYYY">
    <td>A_YYYY</td>
    <td>
      <p>현재의 4-자리 년도입니다 (예, 2004). A_Year와 동의어입니다.</p>
      <p class="note"><strong>주의</strong>: 여러분의 로케일과 언어에 대하여 적절하게 포맷된 날짜와 시간을 열람하려면, <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar</code> (시간과 긴 날짜) 또는 <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar,, LongDate</code> (긴-형식의 날짜를 열람)를 사용하십시오.</p>
    </td>
  </tr>
  <tr id="MM">
    <td>A_MM</td>
    <td>현재의 2-자리 월입니다 (01-12). A_Mon와 동일합니다.</td>
  </tr>
  <tr id="DD">
    <td>A_DD</td>
    <td>현재 2-자리 월별 날짜입니다 (01-31). A_MDay와 동일합니다.</td>
  </tr>
  <tr id="MMMM">
    <td>A_MMMM</td>
    <td>현재 사용자 언어로 현재 달의 전체 이름입니다. 예, July</td>
  </tr>
  <tr id="MMM">
    <td>A_MMM</td>
    <td>현재 사용자 언어로 현재 달의 약자입니다. 예, Jul</td>
  </tr>
  <tr id="DDDD">
    <td>A_DDDD</td>
    <td>현재 사용자 언어로 현재 요일의 전체 이름입니다. 예, Sunday</td>
  </tr>
  <tr id="DDD">
    <td>A_DDD</td>
    <td>Current day of the week's abbreviation in the current user's language, e.g. Sun</td>
  </tr>
  <tr id="WDay">
    <td>A_WDay</td>
    <td>현재 요일의 1-자리 수입니다 (1-7). 1은 모든 로케일에서 일요일입니다.</td>
  </tr>
  <tr id="YDay">
    <td>A_YDay</td>
    <td>연별 현재 날짜입니다 (1-366). 값은 0으로 채워지지 않습니다. 예를 들어, 0이 열람되지, 009가 열람되는 것은 아닙니다. 0으로 덧대어진 값을 열람하려면, 다음을 사용합니다: <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar,, YDay0</code>.</td>
  </tr>
  <tr id="YWeek">
    <td>A_YWeek</td>
    <td>ISO 8601에 따른 현재 년도와 주 번호 (예. 200453). 년도와 주를 가르려면 <code>Year := <a href="commands/SubStr.htm">SubStr</a>(A_YWeek, 1, 4)</code> 그리고 <code>Week := <a href="commands/SubStr.htm">SubStr</a>(A_YWeek, -1)</code>를 사용합니다. A_YWeek의 정밀한 정의: 1월 1일을 포함한 주가 새 해에서 4 일 이상 포함되어 있으면, 첫 번째 주로 간주됩니다. 그렇지 않으면, 이전 해의 마지막 주로 간주됩니다. 그리고 그 다음 주가 새 해의 첫 주가 됩니다.</td>
  </tr>
  <tr id="Hour">
    <td>A_Hour</td>
    <td>24시간제로 현재의 2-자리 시 (00-23) (예를 들어, 17는 오후 5시). AM/PM 표시와 함께 12시간제로 열람하려면, 다음 예를 따르십시오: <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar, , h:mm:ss tt</code></td>
  </tr>
  <tr id="Min">
    <td>A_Min</td>
    <td><p>현재 2-자리 분 (00-59).</p></td>
  </tr>
  <tr id="Sec">
    <td>A_Sec</td>
    <td>현재 2-자리 초 (00-59).</td>
  </tr>
  <tr id="MSec">
    <td>A_MSec</td>
    <td>현재 3-자리 밀리초 (000-999). 앞의 0을 제거하려면 다음 예제를 따르십시오: <code>Milliseconds := A_MSec + 0</code>.</td>
  </tr>
  <tr id="Now">
    <td>A_Now</td>
    <td>
      <p><a href="commands/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a> 형식으로 현재 로컬 시간 입니다.</p>
      <p class="note"><strong>주의</strong>: 날짜와 시간 연산은 <a href="commands/EnvAdd.htm">EnvAdd</a> 그리고 <a href="commands/EnvSub.htm">EnvSub</a>로 수행할 수 있습니다. 또, <a href="commands/FormatTime.htm">FormatTime</a>으로 날짜와 시간을 여러분의 로케일 또는 기호에 맞게 포맷할 수 있습니다.</p>
    </td>
  </tr>
  <tr id="NowUTC">
    <td>A_NowUTC</td>
    <td>현재의 협정 세계시(Coordinated Universal Time (UTC))입니다. 형식은 <a href="commands/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a>입니다. UTC는 본질적으로 그리니치 표준시(Greenwich Mean Time (GMT))과 똑같습니다.</td>
  </tr>
  <tr id="TickCount">
    <td>A_TickCount</td>
    <td><p>The number of milliseconds that have elapsed since the system was started, up to 49.7 days. A_TickCount를 변수에 저장해 두고 나중에 가장 마지막 A_TickCount 값에서 빼어서 경과한 시간을 측정할 수 있습니다. 예를 들어:</p>
        <pre>StartTime := A_TickCount
Sleep, 1000
ElapsedTime := A_TickCount - StartTime
MsgBox,  %ElapsedTime% 밀리초가 경과하였습니다.</pre>
<p>A_TickCount의 밀리초보다 더 정밀해야 한다면, <a href="commands/DllCall.htm#QPC">QueryPerformanceCounter()</a>를 사용합니다.</p>
</td>
  </tr>
</table>
<h3 id="settings">스크립트 설정</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="IsSuspended">
    <td>A_IsSuspended</td>
    <td>스크립트가 <a href="commands/Suspend.htm">보류중이면(suspended)</a> 1이 그렇지 않으면 0이 담깁니다.</td>
  </tr>
  <tr id="IsPaused">
    <td>A_IsPaused<br>
    <span class="ver">[v1.0.48+]</span></td>
    <td>현재 쓰레드 바로 아래의 <a href="misc/Threads.htm">쓰레드</a>가 <a href="commands/Pause.htm">정지되어</a> 있으면 1이 담깁니다. 그렇지만 0이 담깁니다.</td>
  </tr>
  <tr id="IsCritical">
    <td>A_IsCritical<br>
    <span class="ver">[v1.0.48+]</span></td>
    <td><a href="misc/Threads.htm">현재 쓰레드</a>에 대하여 <a href="commands/Critical.htm">임계구역</a> 밖이면 0이 담깁니다. 그렇지 않으면 0보다 큰 정수값이 담깁니다. 즉, Critical에서 <a href="commands/Critical.htm#Interval">메시지-점검 빈도</a>를 사용중입니다. <code>Critical 0</code>이면 임계 구역 점검을 끄기 때문에, 임계 구역의 현재 상태를 저장하고 나중에 <code>Old_IsCritical := A_IsCritical</code>를 한 다음에 <code>Critical %Old_IsCritical%</code>를 통하여 복구할 수 있습니다.</td>
  </tr>
  <tr id="BatchLines">
    <td>A_BatchLines</td>
    <td>(A_NumBatchLines와 동의어) <a href="commands/SetBatchLines.htm">SetBatchLines</a>에 의하여 설정된 현재 값입니다. 예제: 200 또는 10ms (포맷에 따라 다름).</td>
  </tr>
  <tr id="ListLines">
    <td>A_ListLines<br><span class="ver">[v1.1.28+]</span></td>
    <td>Contains 1 if <a href="commands/ListLines.htm">ListLines</a> is enabled. 그렇지만 0이 담깁니다.</td>
  </tr>
  <tr id="TitleMatchMode">
    <td>A_TitleMatchMode</td>
    <td><a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a>가 설정한 현재 부합모드입니다: 1, 2, 3, 또는 RegEx.</td>
  </tr>
  <tr id="TitleMatchModeSpeed">
    <td>A_TitleMatchModeSpeed</td>
    <td><a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a>가 설정한 현재 일치 속도입니다 (fast 또는 slow) .</td>
  </tr>
  <tr id="DetectHiddenWindows">
    <td>A_DetectHiddenWindows</td>
    <td><a href="commands/DetectHiddenWindows.htm">DetectHiddenWindows</a>가 설정한 현재 모드입니다 (On 또는 Off).</td>
  </tr>
  <tr id="DetectHiddenText">
    <td>A_DetectHiddenText</td>
    <td><a href="commands/DetectHiddenText.htm">DetectHiddenText</a>가 설정한 현재 모드입니다 (On 또는 Off).</td>
  </tr>
  <tr id="AutoTrim">
    <td>A_AutoTrim</td>
    <td><a href="commands/AutoTrim.htm">AutoTrim</a>이 설정한 현재 모드입니다 (On 또는 Off) .</td>
  </tr>
  <tr id="StringCaseSense">
    <td>A_StringCaseSense</td>
    <td><a href="commands/StringCaseSense.htm">StringCaseSense</a>가 설정한 현재 모드입니다 (On, Off, 또는 Locale) .</td>
  </tr>
  <tr id="FileEncoding">
    <td>A_FileEncoding</td>
    <td><span class="ver">[AHK_L 46+]</span>: 다양한 명령어에 대하여 기본 인코딩을 담고 있습니다; <a href="commands/FileEncoding.htm">FileEncoding</a>을 참조하십시오.</td>
  </tr>
  <tr id="FormatInteger">
    <td>A_FormatInteger</td>
    <td><a href="commands/SetFormat.htm">SetFormat</a>이 설정한 현재 정수 형식 (H 또는 D). <span class="ver">[AHK_L 42+]:</span> 이것은 소문자 h를 담을 수도 있습니다.</td>
  </tr>
  <tr id="FormatFloat">
    <td>A_FormatFloat</td>
    <td><a href="commands/SetFormat.htm">SetFormat</a>이 설정한 현재 부동 소수점 수 형식.</td>
  </tr>
  <tr id="SendMode">
    <td>A_SendMode</td>
    <td><span class="ver">[v1.1.23+]:</span> <a href="commands/SendMode.htm">SendMode</a>가 설정한 현재 모드입니다 (Event, Input, Play, 또는 InputThenPlay).</td>
  </tr>
  <tr id="SendLevel">
    <td>A_SendLevel</td>
    <td><span class="ver">[v1.1.23+]:</span> The current <a href="commands/SendLevel.htm">SendLevel</a> setting (an integer between 0 and 100, inclusive).</td>
  </tr>
  <tr id="StoreCapslockMode">
    <td>A_StoreCapsLockMode</td>
    <td><span class="ver">[v1.1.23+]:</span> <a href="commands/SetStoreCapslockMode.htm">SetStoreCapsLockMode</a>가 설정한 현재 모드입니다 (On 또는 Off).</td>
  </tr>
  <tr id="KeyDelay">
    <td>A_KeyDelay<br>
    A_KeyDuration</td>
    <td>The current delay or duration set by <a href="commands/SetKeyDelay.htm">SetKeyDelay</a> (always decimal, not hex). A_KeyDuration requires <span class="ver">[v1.1.23+]</span>.</td>
  </tr>
  <tr id="KeyDelayPlay">
    <td>A_KeyDelayPlay<br>
    A_KeyDurationPlay</td>
    <td>The current delay or duration set by <a href="commands/SetKeyDelay.htm">SetKeyDelay</a> for the <a href="commands/Send.htm#SendPlayDetail">SendPlay</a> mode (always decimal, not hex). <span class="ver">[v1.1.23+]</span> 필요.</td>
  </tr>
  <tr id="WinDelay">
    <td>A_WinDelay</td>
    <td><a href="commands/SetWinDelay.htm">SetWinDelay</a>가 설정한 현재 지연 시간 (언제나 십진법을 사용합니다).</td>
  </tr>
  <tr id="ControlDelay">
    <td>A_ControlDelay</td>
    <td><a href="commands/SetControlDelay.htm">SetControlDelay</a>가 설정한 현재 지연 시간 (언제나 10진수를 사용합니다).</td>
  </tr>
  <tr id="MouseDelay">
    <td>A_MouseDelay<br>
    A_MouseDelayPlay</td>
    <td><a href="commands/SetMouseDelay.htm">SetMouseDelay</a>가 설정한 현재 지연 시간 (언제나 십지수를 사용합니다). A_MouseDelay is for the traditional SendEvent mode, whereas A_MouseDelayPlay is for <a href="commands/Send.htm#SendPlayDetail">SendPlay</a>. A_MouseDelayPlay requires <span class="ver">[v1.1.23+]</span>.</td>
  </tr>
  <tr id="DefaultMouseSpeed">
    <td>A_DefaultMouseSpeed</td>
    <td><a href="commands/SetDefaultMouseSpeed.htm">SetDefaultMouseSpeed</a>가 설정한 현재 속도 (언제나 십진법을 사용합니다. 십육진법은 사용하지 않습니다).</td>
  </tr>
  <tr id="CoordMode">
    <td>A_CoordModeToolTip<br>
    A_CoordModePixel<br>
    A_CoordModeMouse<br>
    A_CoordModeCaret<br>
    A_CoordModeMenu</td>
    <td><span class="ver">[v1.1.23+]:</span> <a href="commands/CoordMode.htm">CoordMode</a>가 설정한 현재 모드입니다 (Window, Client, 또는 Screen).</td>
  </tr>
  <tr id="RegView">
    <td>A_RegView</td>
    <td><span class="ver">[v1.1.08+]:</span> <a href="commands/SetRegView.htm">SetRegView</a>가 설정한 현재 레지스트리 뷰입니다.</td>
  </tr>
  <tr id="IconHidden">
    <td>A_IconHidden</td>
    <td><a href="Program.htm#tray-icon">트레이 아이콘</a>이 현재 보이지 않으면 1 그렇지 않으면 0이 담깁니다. 아이콘은 <a href="commands/_NoTrayIcon.htm">#NoTrayIcon</a>이나 <a href="commands/Menu.htm">Menu</a> 명령어를 통하여 감출 수 있습니다.</td>
  </tr>
  <tr id="IconTip">
    <td>A_IconTip</td>
    <td><a href="Program.htm#tray-icon">트레이 아이콘</a>에 맞춤 툴팁이 <code><a href="commands/Menu.htm">Menu</a>, Tray, Tip</code>을 통하여 지정되어 있지 않은 한, 비어 있습니다 -- 지정되어 있으면 툴팁 텍스트가 담깁니다.</td>
  </tr>
  <tr id="IconFile">
    <td>A_IconFile</td>
    <td>맞춤 <a href="Program.htm#tray-icon">트레이 아이콘</a>이 <code><a href="commands/Menu.htm">Menu</a>, tray, icon</code>을 통하여 지정되어 있지 않은 한 비어 있습니다 --지정 되어 있을 경우 그 아이콘 파일의 전체 경로와 이름이 담깁니다.</td>
  </tr>
  <tr id="IconNumber">
    <td>A_IconNumber</td>
    <td>A_IconFile이 비어 있으면 비어 있습니다. 그렇지 않으면, A_IconFile의 아이콘 번호입니다 (전형적으로 1).</td>
  </tr>
</table>
<h3 id="User_Idle_Time">User Idle Time</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="TimeIdle">
    <td>A_TimeIdle</td>
    <td>키보드나 마우스 또는 기타 입력으로부터 시스템이 입력을 받은 이후로 경과한 시간의 밀리초 개수입니다. 사용자가 컴퓨터 앞에 있는지 판단하는데 유용합니다. 사용자로부터 받는 물리적 입력과 더불어 <strong>프로그램이나 스크립트</strong>가 만들어 내는 인위적인 입력은 (<a href="commands/Send.htm">Send</a> 또는 <a href="commands/MouseMove.htm">MouseMove</a> 명령어) 이 값을 다시 0으로 재설정합니다. 이 값은 10씩 증가하는 경향이 있기 때문에, 다른 값과 같은지 비교하면 안됩니다. 대신에, 다른 값보다 큰지 작은지로 비교하십시오. 예를 들어: <code>IfGreater, A_TimeIdle, 600000, MsgBox, 마지막 키보드나 마우스 활동이 적어도 10 분 전이었습니다</code>.</td>
  </tr>
  <tr id="TimeIdlePhysical">
    <td>A_TimeIdlePhysical</td>
    <td>위와 비슷하지만 상응하는 갈고리가 설치되어 있으면 인위적인 키눌림과 마우스 클릭을 무시합니다. (<a href="commands/_InstallKeybdHook.htm">keyboard</a> 또는 <a href="commands/_InstallMouseHook.htm">mouse</a>); 즉, 오직 물리적 이벤트에만 응답합니다. (마치 사용자가 존재하는 듯이 키보드나 마우스 클릭을 흉내내는 것을 방지합니다.) 갈고리가 설치되어 있지 않으면, 이 값은 A_TimeIdle과 동등합니다. 둘 중에 하나의 갈고리만 설치되어 있으면, 물리적 입력의 유형만 A_TimeIdlePhysical에 영향을 미칩니다 (다른/설치-안된 갈고리의 입력은, 물리적 입력과 인위적 입력에 모두 영향이 없습니다).</td>
  </tr>
  <tr id="TimeIdleKeyboard">
    <td>A_TimeIdleKeyboard<br><span class="ver">[v1.1.28+]</span></td>
    <td>If the <a href="commands/_InstallKeybdHook.htm">keyboard hook</a> is installed, this is the number of milliseconds that have elapsed since the system last received physical keyboard input. Otherwise, this variable is equivalent to A_TimeIdle.</td>
  </tr>
  <tr id="TimeIdleMouse">
    <td>A_TimeIdleMouse<br><span class="ver">[v1.1.28+]</span></td>
    <td>If the <a href="commands/_InstallMouseHook.htm">mouse hook</a> is installed, this is the number of milliseconds that have elapsed since the system last received physical mouse input. Otherwise, this variable is equivalent to A_TimeIdle.</td>
  </tr>
</table>
<h3 id="gui">GUI 창과 메뉴 바</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="DefaultGui">
    <td>A_DefaultGui <span class="ver">[v1.1.23+]</span></td>
    <td>The name or number of the current thread's <a href="commands/Gui.htm#Default">default GUI</a>.</td>
  </tr>
  <tr id="DefaultListView">
    <td>A_DefaultListView <span class="ver">[v1.1.23+]</span></td>
    <td>The <a href="commands/Gui.htm#Events">variable name</a> or <a href="commands/Gui.htm#HwndOutputVar">HWND</a> of the <a href="commands/ListView.htm">ListView control</a> upon which the <a href="commands/ListView.htm#BuiltIn">ListView functions</a> operate. If the default GUI lacks a ListView, this variable is blank.</td>
  </tr>
  <tr id="DefaultTreeView">
    <td>A_DefaultTreeView <span class="ver">[v1.1.23+]</span></td>
    <td>The <a href="commands/Gui.htm#Events">variable name</a> or <a href="commands/Gui.htm#HwndOutputVar">HWND</a> of the <a href="commands/TreeView.htm">TreeView control</a> upon which the <a href="commands/TreeView.htm#BuiltIn">TreeView functions</a> operate. If the default GUI lacks a TreeView, this variable is blank.</td>
  </tr>
  <tr id="Gui">
    <td>A_Gui</td>
    <td><a href="commands/Gui.htm">현재 쓰레드</a>를 기동한 <a href="misc/Threads.htm">GUI</a>의 이름이나 번호입니다. 이 변수는 Gui 콘트롤, 메뉴 바 항목, 또는 GuiClose/GuiEscape와 같은 이벤트가 현재 쓰레드를 기동하지 않았다면 비어 있습니다.</td>
  </tr>
  <tr id="GuiControl">
    <td>A_GuiControl</td>
    <td><a href="misc/Threads.htm">현재 쓰레드</a>를 기동한 구이 콘트롤에 연관된 변수의 이름입니다. 구이 콘트롤에 <a href="commands/Gui.htm#Events">연관 변수</a>가 없으면, 대신에 A_GuiControl에는 해당 콘트롤의 텍스트/캡션의 앞쪽 63개의 문자가 담깁니다 (각 버튼에 변수 이름을 부여하지 않기 위해 자주 사용됩니다). A_GuiControl은 다음과 같은 경우 비어 있습니다: 1) A_Gui가 비어 있다; 2) GUI 메뉴 바 항목이나 GuiClose/GuiEscape과 같은 이벤트가 현재 쓰레드를 기동시켰다; 3) 콘트롤에 연관 변수가 없으며 캡션도 없다; 4) 또는 현재 쓰레드를 기동시킨 최초의 콘트롤이 (아마도 <a href="commands/Gui.htm#Destroy">Gui Destroy</a> 때문에 더 이상 존재하지 않는다).</td>
  </tr>
  <tr id="GuiWidth">
    <td>A_GuiWidth<br>
    A_GuiHeight</td>
    <td><a href="commands/Gui.htm#GuiSize">GuiSize 서브루틴</a>에서 참조할 때 GUI 창의 너비와 높이가 담깁니다. 창의 클라이언트 구역에 적용됩니다. 클라이언트 구역은 타이틀 바와 메뉴 바 그리고 테두리를 제외한 구역입니다. <span class="ver">[v1.1.11+]:</span> 이 값들은 <a href="commands/Gui.htm#DPIScale">DPI 스케일링</a>에 영향을 받습니다.</td>
  </tr>
  <tr>
    <td><span id="GuiX"></span><span id="GuiY"></span>A_GuiX<br>
    A_GuiY</td>
    <td><a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a> 이벤트와 <a href="commands/Gui.htm#GuiDropFiles">GuiDropFiles</a> 이베트가 일어날 때 X 좌표와 Y 좌표를 담고 있습니다. 좌표는 창의 조상단 모서리에 상대적입니다. <span class="ver">[v1.1.11+]:</span> 이 값들은 <a href="commands/Gui.htm#DPIScale">DPI 스케일링</a>에 영향을 받습니다.</td>
  </tr>
  <tr>
    <td><span id="GuiEvent"></span><span id="GuiControlEvent"></span>A_GuiEvent<br><span class="small80">또는 A_GuiControlEvent</span></td>
    <td><p><a href="misc/Threads.htm">현재 쓰레드</a>를 기동한 이벤트의 종류. 쓰레드가 <a href="commands/Gui.htm">GUI 행위</a>를 통하여 기동되지 않았다면, 이 변수는 비어 있습니다. 그렇지 않으면, 다음 문자열 중 하나가 담깁니다:</p>
      <p><strong>Normal</strong>: The event was triggered by a single left-click or via keystrokes (<kbd>↑</kbd>, <kbd>→</kbd>, <kbd>↓</kbd>, <kbd>←</kbd>, <kbd>Tab</kbd>, <kbd>Space</kbd>, underlined shortcut key, etc.). 이 값은 또GuiClose 그리고 GuiEscape와 같은 특수한 이벤트 그리고 메뉴 바 항목에도 사용됩니다.</p>
      <p><strong>DoubleClick</strong>: 이벤트가 더블클릭으로 촉발되었습니다. 주의: 클릭-쌍 중에 첫 클릭은 먼저 <em>Normal</em> 이벤트를 받습니다. 다시 말해, 서브루틴은 두 번 기동됩니다: 한 번은 첫 클릭에 그리고 다시 두 번째 클릭에 기동됩니다.</p>
      <p><strong>RightClick</strong>: 오직 <a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="commands/ListView.htm">ListViews</a>, 그리고 <a href="commands/TreeView.htm">TreeViews</a>에만 일어납니다.</p>
      <p><strong>문맥-감지 값:</strong> 자세한 것은 <a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="commands/Gui.htm#GuiDropFiles">GuiDropFiles</a>, <a href="commands/GuiControls.htm#Slider">Slider</a>, <a href="commands/GuiControls.htm#MonthCal">MonthCal</a>, <a href="commands/ListView.htm">ListView</a>, 그리고 <a href="commands/TreeView.htm">TreeView</a>를 참조하십시오.</p>
    </td>
  </tr>
  <tr id="EventInfo">
    <td>A_EventInfo</td>
    <td><p>다음 이벤트들에 대한 추가 정보를 담고 있습니다:</p>
      <ul>
        <li><a href="commands/OnClipboardChange.htm#label">OnClipboardChange 라벨</a></li>
        <li><a href="Hotkeys.htm#Wheel">마우스 휠 핫키</a> (WheelDown/Up/Left/Right)</li>
        <li><a href="commands/OnMessage.htm">OnMessage()</a></li>
        <li><a href="commands/RegisterCallback.htm">RegisterCallback()</a></li>
        <li><a href="misc/RegExCallout.htm">정규 표현식 Callouts</a></li>
        <li><a href="commands/Gui.htm#label">GUI events</a>, 즉 <a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="commands/Gui.htm#GuiDropFiles">GuiDropFiles</a>, <a href="commands/GuiControls.htm#ListBox">ListBox</a>, <a href="commands/ListView.htm">ListView</a>, <a href="commands/TreeView.htm">TreeView</a>, 그리고 <a href="commands/GuiControls.htm#StatusBar">StatusBar</a>. 이벤트에 대하여 더 이상 추가 정보가 없으면, A_EventInfo에는 0이 담깁니다.</li>
      </ul></td>
  </tr>
</table>
<p class="note"><strong>주의</strong>: A_ThisHotkey와 같은 변수와 다르게, 각 <a href="misc/Threads.htm">쓰레드</a>마다 A_Gui, A_GuiControl, A_GuiX/Y, A_GuiEvent, 그리고 A_EventInfo에 대하여 자신의 값을 유지합니다. 그러므로, 쓰레드가 다른 쓰레드에 의해 인터럽트 되더라도, 실행을 재개하면 여전히 이 값들에서 자신의 원래/올바른 값을 볼 수 있습니다.</p>
<h3 id="h">핫키, 핫스트링, 그리고 맞춤 메뉴 항목</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="ThisMenuItem">
    <td>A_ThisMenuItem</td>
    <td>가장 최근에 선택된 <a href="commands/Menu.htm">맞춤 메뉴 항목</a>의 이름입니다 (없으면 비어 있습니다).</td>
  </tr>
  <tr id="ThisMenu">
    <td>A_ThisMenu</td>
    <td>A_ThisMenuItem가 선택된 곳의 메뉴 이름입니다.</td>
  </tr>
  <tr id="ThisMenuItemPos">
    <td>A_ThisMenuItemPos</td>
    <td>안에서 A_ThisMenuItem의 <u>현재</u> 위치를 가리키는 번호입니다. 메뉴에서 첫 번째 항목은 1이고, 두 번째 항목은 2, 등등입니다. 메뉴 가름자 줄도 계산에 들어 갑니다. 이 변수는 A_ThisMenu메뉴 안에 A_ThisMenuItem이 비어 있거나 더 이상 존재하지 않으면 비어 있습니다. 또 A_ThisMenu 자체가 존재하지 않을 경우에도 비어 있습니다.</td>
  </tr>
  <tr id="ThisHotkey">
    <td>A_ThisHotkey</td>
    <td><p>가장 최근에 실행된 <a href="Hotkeys.htm">핫키</a> 또는 <a href="Hotstrings.htm">비-자동-교체 핫스트링</a>입니다 (없으면 비어 있습니다). 예, #z. 이 값은 <a href="misc/Threads.htm">현재 쓰레드</a>가 또다른 핫키로 인터럽트 되면 변합니다. 그래서 나중에 서브루틴에서 사용하기 위해 원래 값이 필요하다면 즉시 또다른 변수에 복사하십시오.</p>
      <p>핫키가 처음으로 - 스크립트에서 <a href="commands/Hotkey.htm">핫키 명령어</a>나 <a href="Hotkeys.htm">이중-쌍점 라벨</a>로 -- 만들어질 때, 그의 키 이름과 그의 수식 심볼의 순서가 그 핫키의 영구적인 이름이 됩니다. 그 이름을 핫키의 모든 <a href="commands/_IfWinActive.htm#variant">변형</a>들이 공유합니다.</p>
      <p>When a hotstring is first created, the exact text used to create it becomes the permanent name of the hotstring.</p>
      <p>다음 참조: <a href="#ThisLabel">A_ThisLabel</a></p></td>
  </tr>
  <tr id="PriorHotkey">
    <td>A_PriorHotkey</td>
    <td>위와 같지만 이전의 핫키는 제외합니다. 없으면 비어 있습니다.</td>
  </tr>
  <tr id="PriorKey">
    <td>A_PriorKey</td>
    <td><span class="ver">[v1.1.01+]:</span> 가장 최근의 키-누름이나 키-뗌보다 앞에 눌린 마지막 키의 이름입니다. 아니면 키 히스토리에서 적용가능한 키-누름을 발견할 수 없을 경우 비어 있습니다. 오토핫기 스크립트가 생성한 모든 입력은 배제됩니다. 이 변수를 사용하려면, <a href="commands/_InstallKeybdHook.htm">키보드 갈고리</a>나 <a href="commands/_InstallMouseHook.htm">마우스 갈고리</a>가 반드시 설치되어 있어야 하고 <a href="commands/KeyHistory.htm">키 히스토리</a>가 활성화되어 있어야 합니다.</td>
  </tr>
  <tr id="TimeSinceThisHotkey">
    <td>A_TimeSinceThisHotkey</td>
    <td>A_ThisHotkey가 눌린 이후로 경과한 밀리초의 개수입니다. A_ThisHotkey가 빌 때마다 -1이 됩니다.</td>
  </tr>
  <tr id="TimeSincePriorHotkey">
    <td>A_TimeSincePriorHotkey</td>
    <td>A_PriorHotkey가 눌린 이후로 경과한 밀리초의 개수입니다. A_PriorHotkey가 빌 때마다 -1이 됩니다.</td>
  </tr>
  <tr id="EndChar">
    <td>A_EndChar</td>
    <td>가장 최근의 <a href="Hotstrings.htm">비-자동-교체-핫스트링</a>을 촉발시키기 위해 사용자가 누른 <a href="Hotstrings.htm#EndChars">종료 문자(ending character)</a>입니다. 종료 문자를 ( * 옵션 때문에) 요구하지 않았다면, 이 값은 비어 있습니다.</td>
  </tr>
</table>
<h3 id="os">운영 체제와 사용자 정보</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="ComSpec">
    <td>ComSpec <span class="ver">[v1.0.43.08+]</span><br>
    A_ComSpec <span class="ver">[v1.1.28+]</span></td>
    <td>
      <p>Contains the same string as the environment's ComSpec variable. 종종 <a href="commands/Run.htm">Run/RunWait</a>와 함께 사용됩니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Windows\system32\cmd.exe</pre>
    </td>
  </tr>
  <tr id="Temp">
    <td>A_Temp<br>
    <span class="ver">[v1.0.43.09+]</span></td>
    <td><p>임시 파일을 보유하도록 지정된 폴더의 전체 경로와 이름. (순서대로) 다음 위치 중 하나에서 열람합니다: 1) <a href="Concepts.htm#environment-variables">환경 변수</a> TMP, TEMP, 또는 USERPROFILE; 2) Windows 디렉토리. 예를 들어:</p>
    <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Local\Temp</pre>
  </td>
  </tr>
  <tr id="OSType">
    <td>A_OSType</td>
    <td>실행 중인 운영 체제의 종류입니다. AutoHotkey 1.1은 오직 NT-기반의 운영 체제만 지원하기 때문에, 이 값은 언제나 WIN32_NT입니다. 예전 버전은 Windows 95/98/ME에서 실행될 때 WIN32_WINDOWS를 돌려줍니다.</td>
  </tr>
  <tr id="OSVersion">
    <td>A_OSVersion</td>
    <td><p>다음 문자열 중 하나입니다: WIN_7 <span class="ver">[requires AHK_L 42+]</span>, WIN_8 <span class="ver">[requires v1.1.08+]</span>, WIN_8.1 <span class="ver">[requires v1.1.15+]</span>, WIN_VISTA, WIN_2003, WIN_XP, WIN_2000.</p>
    <p>호환성 설정을 오토핫키 실행파일이나 컴파일된 스크립트의 특성에 적용하면 운영체제가 다른 버전 번호를 돌려줍니다. 이것이 A_OSVersion에 반영됩니다.</p>
    <p><span class="ver">[v1.1.20+]:</span> OS 버전을 위에 언급한 리스트에서 찾을 수 없으면, 문자열이 "major.minor.build" 형태로 반환됩니다. For example, <code>10.0.14393</code> is Windows 10 build 14393, also known as version 1607.</p>
      <pre><em>; 이 예제는 폐기되었습니다. 이 운영체제는 더 이상 지원하지 않습니다.</em>
if A_OSVersion in WIN_NT4,WIN_95,WIN_98,WIN_ME  <em>; 주의: 쉼표 둘레에 스페이스가 없음에 주의합니다.</em>
{
    MsgBox 이 스크립트는 Windows 2000/XP 이상을 요구합니다.
    ExitApp
}</pre>
    </td>
  </tr>
  <tr id="Is64bitOS">
    <td>A_Is64bitOS</td>
    <td><span class="ver">[v1.1.08+]:</span> 운영체제가 64비트이면 1 (true) 또는 운영체제가 32비트이면 0 (false)을 담고 있습니다.</td>
  </tr>
  <tr id="PtrSize">
    <td>A_PtrSize</td>
    <td><span class="ver">[AHK_L 42+]:</span> 포인터의 크기를 바이트 단위로 담고 있습니다. 이것은 4 (32-bit) 또는 8 (64-bit)입니다. 어떤 유형의 실행파일을 (EXE) 스크립트가 실행하는가에 따라 다릅니다.</td>
  </tr>
  <tr id="Language">
    <td>A_Language</td>
    <td>시스템의 기본 언어입니다 <a href="misc/Languages.htm">다음 4-자리 코드</a>중 하나입니다.</td>
  </tr>
  <tr id="ComputerName">
    <td>A_ComputerName</td>
    <td>네트워크에 보여지는 컴퓨터 이름입니다.</td>
  </tr>
  <tr id="UserName">
    <td>A_UserName</td>
    <td>이 스크립트를 기동한 사용자의 로그온 이름입니다.</td>
  </tr>
  <tr id="WinDir">
    <td>A_WinDir</td>
    <td>윈도우즈 디렉토리입니다. 예를 들어: <code>C:\Windows</code></td>
  </tr>
  <tr id="ProgramFiles">
    <td>A_ProgramFiles<br>
    또는 ProgramFiles</td>
    <td>
      <p>프로그램 파일 디렉토리입니다 (예, <code>C:\Program Files</code> 또는 <code>C:\Program Files (x86)</code>). This is usually the same as the <em>ProgramFiles</em> <a href="Concepts.htm#environment-variables">environment variable</a>.</p>
      <p>On <a href="#Is64bitOS">64-bit systems</a> (and not 32-bit systems), the following applies:</p>
      <ul>
        <li>If the executable (EXE) that is running the script is 32-bit, A_ProgramFiles returns the path of the "Program Files (x86)" directory.</li>
        <li>For 32-bit processes, the <em>ProgramW6432</em> environment variable contains the path of the 64-bit Program Files directory. On Windows 7 and later, it is also set for 64-bit processes.</li>
        <li>The <em>ProgramFiles(x86)</em> environment variable contains the path of the 32-bit Program Files directory.</li>
      </ul>
      <p><span class="ver">[v1.0.43.08+]</span>: A_ prefix를 생략해도 가능합니다. 그러면 쉽게 <a href="commands/_NoEnv.htm">#NoEnv</a>이전하는 데 도움이 됩니다.</p>
    </td>
  </tr>
  <tr id="AppData">
    <td>A_AppData<br>
    <span class="ver">[v1.0.43.09+]</span></td>
    <td>
      <p>현재 사용자 어플리케이션의 특정한 데이터를 담고 있는 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming</pre>
    </td>
  </tr>
  <tr id="AppDataCommon">
    <td>A_AppDataCommon<br>
    <span class="ver">[v1.0.43.09+]</span></td>
    <td>
      <p>모든-사용자 어플리케이션의 특정한 데이터를 담고 있는 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData</pre>
    </td>
  </tr>
  <tr id="Desktop">
    <td>A_Desktop</td>
    <td>
      <p>현재 사용자 데스크탑 파일을 담고 있는 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\Desktop</pre>
    </td>
  </tr>
  <tr id="DesktopCommon">
    <td>A_DesktopCommon</td>
    <td>
      <p>모든-사용자 데스크탑 파일을 담고 있는 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Users\Public\Desktop</pre>
    </td>
  </tr>
  <tr id="StartMenu">
    <td>A_StartMenu</td>
    <td>
      <p>현재 사용자이 시작 메뉴 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu</pre>
    </td>
  </tr>
  <tr id="StartMenuCommon">
    <td>A_StartMenuCommon</td>
    <td>
      <p>모든-사용자 시작 메뉴 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu</pre>
    </td>
  </tr>
  <tr id="Programs">
    <td>A_Programs</td>
    <td>
      <p>현재 사용자 시작 메뉴에 있는 프로그램 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs</pre>
    </td>
  </tr>
  <tr id="ProgramsCommon">
    <td>A_ProgramsCommon</td>
    <td>
      <p>모든 사용자 시작 메뉴에 있는 프로그램 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu\Programs</pre>
  </td>
  </tr>
  <tr id="Startup">
    <td>A_Startup</td>
    <td>
      <p>현재 사용자 시작 메뉴에 있는 시작 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</pre>
  </td>
  </tr>
  <tr id="StartupCommon">
    <td>A_StartupCommon</td>
    <td>
      <p>모든-사용자 시작 메뉴에 있는 시작 폴더의 전체 경로와 이름입니다. 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</pre>
  </td>
  </tr>
  <tr id="MyDocuments">
    <td>A_MyDocuments</td>
    <td>
      <p>현재 사용자의 "나의 문서" 폴더의 전체 경로와 이름입니다. 대부분의 비슷한 변수와 다르게, 이 폴더가 드라이브의 루트이면, 마지막 역사선을 포함하지 않습니다 (예를 들어, <code>M:\</code>가 아니라 <code>M:</code>이 됩니다). 예를 들어:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\Documents</pre>
  </td>
  </tr>
  <tr id="IsAdmin">
    <td>A_IsAdmin</td>
    <td><p>현재 사용자가 관리자 권한이 있으면, 이 변수는 1, 그렇지 않으면 0이 담깁니다.</p>
    <p id="RequireAdmin">To have the script restart itself as admin (or show a prompt to the user requesting admin), use <a href="commands/Run.htm#RunAs">Run *RunAs</a>. However, note that running the script as admin causes all programs launched by the script to also run as admin. For a possible alternative, see <a href="FAQ.htm#uac">the FAQ</a>.</p>
    </td>
  </tr>
  <tr id="Screen">
    <td><p>A_ScreenWidth<br>
    A_ScreenHeight</p></td>
    <td><p>기본 모니터의 너비와 높이, 픽셀 단위 (예, 1024 그리고 768).</p>
      <p>다중 모니터 시스템에서 다른 모니터의 크기를 알려면, <a href="commands/SysGet.htm">SysGet</a>를 사용합니다.</p>
      <p>대신에 (다중 모니터에 걸쳐 있더라도) 전체 데스크탑의 너비와 높이를 알려면, 다음 예제를 사용합니다:</p>
<pre>
<a href="commands/SysGet.htm">SysGet</a>, VirtualWidth, 78
<a href="commands/SysGet.htm">SysGet</a>, VirtualHeight, 79
</pre>
    <p>게다가, <a href="commands/SysGet.htm">SysGet</a>을 사용하면 모니의 작업 영역을 알 수 있습니다. 모니터의 전체 영역보다 더 작을 수 있습니다. 왜냐하면 태스크바와 기타 등록된 데스크탑 툴바가 배제되어 있기 때문입니다.</p></td>
  </tr>
  <tr id="ScreenDPI">
    <td>A_ScreenDPI <span class="ver">[v1.1.11+]</span></td>
    <td>화면 너비를 따라 논리적 인치당 픽셀의 개수입니다. 다중 모니터 시스템에서, 이 값은 모든 모니터에 대하여 같습니다. 대부분의 시스템에 이 값은 96입니다; 그렇지만 시스템의 텍스트 크기(DPI) 설정에 따라 다릅니다. 또 <a href="commands/Gui.htm#DPIScale">Gui -DPIScale</a>을 참조하십시오.</td>
  </tr>
  <tr id="IPAddress">
    <td>A_IPAddress1 through 4</td>
    <td>컴퓨터에서 네트워크 어댑터의 IP 주소의 앞쪽 4 자리입니다.</td>
  </tr>
</table>
<h3 id="misc">기타</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="Cursor">
    <td>A_Cursor</td>
    <td><p>현재 화면에 보여지는 마우스 커서의 유형입니다. 다음 단어 중 하나입니다: AppStarting, Arrow, Cross, Help, IBeam, Icon, No, Size, SizeAll, SizeNESW, SizeNS, SizeNWSE, SizeWE, UpArrow, Wait, Unknown. Size-유형의 커서에 사용된 약자는 방위를 나타냅니다. 예, NESW = NorthEast+SouthWest. 손-모양의 커서는 (찍기와 잡기)는 Unknown으로 분류되어 있습니다.</p></td>
  </tr>
  <tr id="Caret">
    <td>A_CaretX<br>
    A_CaretY</td>
    <td><p>현재 캐럿(텍스트 삽입 위치)의 X와 Y 좌표입니다. 이 좌표는 활성 창에 상대적입니다. <a href="commands/CoordMode.htm">CoordMode</a>를 사용하여 전체 화면에 대하여 상대적으로 만들지 않는 한 말입니다. 활성 창이 없거나 캐럿 위치를 결정할 수 없으면, 이 변수는 비어 있습니다.</p>
      <p>다음 스크립트로 캐럿을 이동시켜서 그의 현재 위치가 자동-갱신 툴팁에 나타나는 것을 볼 수 있습니다. 어떤 창은 (예, MS Word) 실제 위치에 상관 없이 같은 캐럿 위치를 보고합니다.</p>
<pre>
#Persistent
SetTimer, WatchCaret, 100
return
WatchCaret:
    ToolTip, X%A_CaretX% Y%A_CaretY%, A_CaretX, A_CaretY - 20
return
</pre>
    </td>
  </tr>
  <tr id="Clipboard">
    <td>Clipboard</td>
    <td>Can be used to get or set the contents of the OS's clipboard. 자세한 것은 <a href="misc/Clipboard.htm">Clipboard</a>를 참조하십시오.</td>
  </tr>
  <tr id="ClipboardAll">
    <td>ClipboardAll</td>
    <td>클립보드의 전체 내용입니다 (포맷과 텍스트 같은). 자세한 것은 <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a>를 참조하십시오.</td>
  </tr>
  <tr id="ErrorLevel">
    <td>ErrorLevel</td>
    <td>This variable is set by some commands to indicate their success or failure. 자세한 것은 <a href="misc/ErrorLevel.htm">ErrorLevel</a>를 참조하십시오.</td>
  </tr>
  <tr id="LastError">
    <td>A_LastError</td>
    <td>OS의 GetLastError() 함수의 결과 또는 COM 객체 요청의 최종 결과. 자세한 것은 <a href="commands/DllCall.htm#LastError">DllCall()</a> 그리고 <a href="commands/Run.htm#LastError">Run/RunWait</a>를 참조합니다.</td>
  </tr>
  <tr id="TrueFalse">
    <td>True<br />False</td>
    <td><p>Contain 1 and 0. They can be used to make a script more readable. For details, see <a href="Concepts.htm#boolean">Boolean Values</a>.</p>
    </td>
  </tr>
</table>
<h3 id="loop">Loop</h3>
<table class="info">
  <tr>
    <th abbr="변수">변수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="Index">
    <td>A_Index</td>
    <td>현재 회돌이의 반복 횟수입니다 (64-비트 정수). 예를 들어, 스크립트가 회돌이의 몸체를 처음 실행하면, 이 변수는 숫자 1이 담깁니다. 더 자세한 것은 <a href="commands/Loop.htm">회돌이</a> 또는 <a href="commands/While.htm">While-회돌이</a>를 참조하십시오.</td>
  </tr>
  <tr>
    <td>A_LoopFileName, 등등.</td>
    <td>이 변수와 기타 관련 변수들은 <a href="commands/LoopFile.htm">파일-회돌이</a> 안에서만 유효합니다.</td>
  </tr>
  <tr>
    <td>A_LoopRegName, 등등.</td>
    <td>이 변수와 기타 관련 변수들은 <a href="commands/LoopReg.htm">레지스트리-회돌이</a> 안에서만 유효합니다.</td>
  </tr>
  <tr>
    <td>A_LoopReadLine</td>
    <td><a href="commands/LoopReadFile.htm">파일-읽기 회돌이</a>를 참조하십시오.</td>
  </tr>
  <tr>
    <td>A_LoopField</td>
    <td><a href="commands/LoopParse.htm">회돌이 파싱하기</a>를 참조하십시오.</td>
  </tr>
</table>

<h2 id="cap">변수의 가용성과 메모리</h2>
<ul>
  <li>각 변수는 최대 64 MB 텍스트를 담을 수 있습니다 (이 제한은 <a href="commands/_MaxMem.htm">#MaxMem</a>을 증가시킬 수 있습니다).</li>
  <li>변수에 현재 내용보다 더 긴 새 문자열이 주어지면, 추가 시스템 메모리가 자동으로 할당됩니다.</li>
  <li>거대한 메모리가 점유한 메모리는 비워 버리면 해제됩니다. 예, <code>var := ""</code>.</li>
  <li>스크립트에 얼마나 많은 변수를 생성할 수 있는지는 제한이 없습니다. 적어도 수 백만개의 변수를 수행성능의 저하 없이 지원하도록 설계되어 있습니다.</li>
  <li>숫치 입력을 받는 명령어, 함수, 그리고 표현식은 일반적으로 부동 소수점 수에 대하여 15 자리수의 정밀도를 지원합니다. 정수에 대해서는, 64-비트 부호있는 값을 지원합니다. 그 범위는 -9223372036854775808 (-0x8000000000000000)부터 9223372036854775807 (0x7FFFFFFFFFFFFFFF)까지입니다. Any integer constants or numeric strings outside this range are not supported and might yield inconsistent results when used as numbers. 대조적으로, 정수 산술 연산은 빙 돌아 범람해 버립니다 (예, 0x7FFFFFFFFFFFFFFF + 1 = -0x8000000000000000).</li>
</ul>
</body>
</html>
