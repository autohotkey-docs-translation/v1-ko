<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>RegExReplace</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>RegExReplace() <span class="ver">[v1.0.45+]</span></h1>

<p>문자열 안에서 패턴 (정규 표현식)에 부합하는 것들을 교체합니다.</p>

<pre class="Syntax">NewStr := RegExReplace(Haystack, NeedleRegEx [, Replacement = "", OutputVarCount = "", Limit = -1, StartingPosition = 1])</pre>
<h3>매개변수</h3>
<dl>

  <dt>NewStr</dt>
  <dd><p>RegExReplace()는 <em>Haystack</em>의 내용을 연산으로 교체하여 돌려줍니다. 교체가 필요하지 않으면, <em>Haystack</em>은 그대로 반환됩니다. 에러가 일어나면 (예를 들어 <em>NeedleRegEx</em> 안의 구문 에러가 있으면), <em>Haystack</em>은 그대로 반환됩니다 (1.0.46.06 이전 버전은 예외인데, ""를 돌려줍니다) 그리고 ErrorLevel은 0 대신에 <a href="#ErrorLevel">아래의</a> 값 중 하나가 설정됩니다.</p></dd>

  <dt>Haystack</dt>
  <dd><p>그의 내용이 검색되고 교체될 문자열.</p></dd>

  <dt>NeedleRegEx</dt>
  <dd><p>검색 할 패턴, 펄-호환의 정규 표현식입니다 (PCRE). 패턴의 <a href="../misc/RegEx-QuickRef.htm#Options">옵션</a>은 문자열 처음에 포함해야 하고 그 다음에 닫는 반괄호가 따라 옵니다. 예를 들어, 패턴 "<span class="red">i)</span>abc.*123"는 대소문자 비구분 옵션을 켜고 "abc"를 검색 한 다음, 0개 이상의 문자를 검색하고, 다음에 "123"을 검색합니다. 옵션이 없다면, ")"는 선택적입니다; 예를 들어, ")abc"는 "abc"와 동등합니다.</p></dd>

  <dt>Replacement</dt>
  <dd><p><a name="BackRef"></a>부합하면 교체될 문자열, 평범한 텍스트입니다 (정규 표현식 아님). $1와 같은 역참조를 포함할 수 있습니다. <em>Haystack</em>으로부터 첫 번째 <a href="../misc/RegEx-QuickRef.htm#subpat">부패턴</a>에 부합한 부문자열을 가지고 옵니다. 가장 단순한 역참조는 $0부터 $9입니다. $0은 전체 패턴에 부합한 부문자열입니다. $1은 첫 부패턴에 부합한 부문자열입니다. $2는 두 번째 부패턴에 부합한 부문자열입니다. 등등. 10 이상의 역 참조는 (그리고 선택적으로 9 이하도), 숫자를 활괄호 안에 둘러 싸십시오; 예, ${10}, ${11}, 등등. <a href="RegExMatch.htm#NamedSubPat">이름 부패턴</a>은 그 이름을 활괄호 안에 둘러 싸십시오; 예, ${SubpatternName}. 기호 그대로 $를 지정하려면, $$를 사용하십시오 (이것은 그런 특별 취급이 필요한 유일한 문자입니다; 역사선은 피신시키는 데 전혀 필요하지 않습니다).</p>
      <p>부패턴의 대소문자를 변환하려면, $ 다음에 다음 문자 중 하나를 배치하십시오: U 또는 u (대문자), L 또는 l (소문자), T 또는 t (제목격입니다. 즉, 각 단어의 첫 글자가 대문자가 되고 다른 모든 글자는 소문자가 됩니다). 예를 들어, $U1와 $U{1} 둘 모두 첫 부패턴의 대문자 버전으로 변환합니다.</p>
      <p>존재하지 않는 역참조와 <em>Haystack</em>에서 아무 것도 부합하지 못한 것들은 -- 예를 들어 "(abc)|(xyz)"의 부패턴 중 하나 -- 빈 문자열로 변환됩니다.</p></dd>

  <dt>OutputVarCount</dt>
  <dd><p>일어난 교체의 횟수를 저장할 변수의 이름. 따옴표 처리 없음 (교체가 없으면 0).</p></dd>

  <dt>Limit</dt>
  <dd><p><em>Limit</em>을 생략하면, 기본값은 -1입니다. 기본값은 <em>Haystack</em>에서 발견된 패턴에 부합하면 <strong>모두</strong> 교체합니다. 그렇지 않으면, 허용할 교체의 최대 횟수를 지정하십시오. <em>Haystack</em>에서 마지막 교체 이후의 오른쪽 부분은 바뀌지 않습니다.</p></dd>

  <dt>StartingPosition</dt>
  <dd><p><em>StartingPosition</em>을 생략하면 기본값은 1입니다 (<em>Haystack</em>의 시작). 그렇지 않으면, 2를 지정해 두 번째 문자에서 시작하거나 3을 지정해 세 번째 문자에서 시작할 수 있습니다. 등등. <em>StartingPosition</em>이 <em>Haystack</em>의 길이를 넘어 서면, 검색은 <em>Haystack</em> 끝의 빈 문자열에서 시작됩니다 (결과적으로 아무 교체도 없습니다).</p>
      <p><em>StartingPosition</em>이 보다 작으면, <em>Haystack</em> 끝으로부터의 상대거리고 간주합니다. 예를 들어, 0은 마지막 문자에서 시작하고, -1은 마지막 문자 바로 앞에서 시작합니다. <em>StartingPosition</em>이 <em>Haystack</em>의 왼쪽 끝을 넘어서 시도하면, 모든 <em>Haystack</em>을 검색합니다.</p>
      <p><em>StartingPosition</em>의 값에 상관 없이, 반환 값은 언제나 <em>Haystack</em>의 완전한 사본입니다 -- 유일한 차이점은 <em>StartingPosition</em>이 1이었을 때와 비교하여 왼쪽이 좀 덜 변경된다는 것입니다.</p></dd>

</dl>
<h3 id="ErrorLevel">ErrorLevel</h3>
<p><span class="ver">[v1.1.04+]</span> 이 함수는 실패시 예외를 던질 수 있습니다 ("부합 없음"과 혼동하지 마십시오). 더 자세한 정보는 <a href="Catch.htm#RuntimeErrors">실행시간 에러</a>를 참조하십시오.</p>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a>은 다음 값중 하나가 설정됩니다:</p>
<ul>
  <li>0, 에러가 일어나지 않았다는 뜻입니다.</li>
  <li>다음과 같은 형태의 문자열: <em>Compile error N at offset M: description</em>. 이 문자열에서, <em>N</em>은 PCRE 에러 번호이고, <em>M</em>은 정규 표현식 안에서의 범칙 문자의 위치입니다. 그리고 <em>description</em>은 그 에러를 설명하는 텍스트입니다.</li>
  <li>음의 정수, 정규 표현식을 <em>실행</em>하는 동안에 에러가 일어났다는 뜻입니다. 그런 에러가 자주 일어나지는 않지만 일어난다면 다음과 같은 에러가 거의 대부분입니다: "too many possible empty-string matches" (-22), "recursion too deep" (-21), 그리고 "reached match limit" (-8). 이런 에러가 일어나면, 패턴을 더 엄격하게 재설계하십시오. 예를 들어 *를 ?, +로 교체하거나 가능하면 {0,3}과 같이 제한하십시오.</li>
</ul>
<h3>Options</h3>
<p>수식자에 관해서 <a href="../misc/RegEx-QuickRef.htm#Options">Options</a>를 참조하십시오. 예를 들어 "<span class="red">i)</span>abc"와 같은 경우, 패턴 "abc"에 대소문자 구분을 끕니다.</p>
<h3>수행성능</h3>
<p>간단한 부문자열을 교체하려면, <a href="StringReplace.htm">StringReplace</a>를 사용하십시오. RegExReplace()보다 더 빠릅니다.</p>
<p>교체의 최대 개수를 알 경우, 그것을 <em>Limit</em> 매개변수에 지정하면 수행성능이 향상됩니다. 검색이 더 빨리 끝날 수 있습니다 (이렇게 하면 연산하는 동안 시스템에 메모리 부하도 줄어듭니다.). 예를 들어, 거대한 문자열의 앞쪽 근처에 오직 하나만 부합한다는 사실을 알고 있다면, 1로 제한하십시오.</p>
<p>수행성능을 개선하기 위하여, 자주 사용되는 정규 표현식 100개를 메모리에 (컴파일된 형태로) 캐쉬합니다.</p>
<p><a href="../misc/RegEx-QuickRef.htm#Study">연구 옵션 (S)</a>으로 종종 (예를 들어 회돌이 안에서) 많이 사용되는 정규 표현식의 수행성능을 개선시킬 수 있습니다.</p>
<h3>논평</h3>
<p>abc123과 같이 대부분의 문자는 정규 표현식 안에 문자 그대로 사용할 수 있습니다. 그렇지만, <strong>\.*?+[{|()^$</strong>와 같은 문자는 반드시 앞에 역사선을 배치해야 문자 그대로 보여지게 됩니다. 예를 들어, <strong>\.</strong>는 문자 그대로의 점이고 <strong>\\</strong>는 기호 그대로의 역사선입니다. 피신을 피하려면 \Q...\E을 사용합니다. 예를 들어: <code>\QLiteral Text\E</code>.</p>
<p>정규 표현식 안에서, 탭과 새줄 같은 특수 문자들은 액센트 (`) 또는 역사선 (\)으로 피신시킬 수 있습니다. 예를 들어, `t는 \t과 같습니다.</p>
<p>정규 표현식의 기본을 배우려면 (또는 패턴 구문을 새롭게 기억해 보려면), <a href="../misc/RegEx-QuickRef.htm">RegEx 간편 참조서</a>를 참조하십시오.</p>
<h3>관련 항목</h3>
<p><a href="RegExMatch.htm">RegExMatch()</a>, <a href="../misc/RegEx-QuickRef.htm">RegEx 간편 참조서</a>, <a href="../misc/RegExCallout.htm">정규 표현식 외부요청</a>, <a href="StringReplace.htm">StringReplace</a>, <a href="../Functions.htm#InStr">InStr()</a></p>
<p>텍스트 데이터를 얻는 흔한 방법: <a href="FileRead.htm">FileRead</a>, <a href="URLDownloadToFile.htm">UrlDownloadToFile</a>, <a href="../misc/Clipboard.htm">Clipboard</a>, <a href="GuiControls.htm#Edit">GUI 편집 콘트롤</a></p>
<h3>예제</h3>
<pre class="NoIndent">NewStr := RegExReplace("abc123123", "123$", "xyz")  <em>; "abc123xyz"을 돌려줍니다. 왜냐하면 $는 끝에만 부합을 허용하기 때문입니다.</em>
NewStr := RegExReplace("abc123", "i)^ABC")  <em>; "123"을 돌려줍니다. 왜냐하면 대소문자 구분 옵션을 통하여 부합에 성공했기 때문입니다.</em>
NewStr := RegExReplace("abcXYZ123", "abc<span class="red">(.*)</span>123", "aaa<span class="red">$1</span>zzz")  <em>; <span class="red">$1</span> <a href="#BackRef">역참조</a>를 사용하여 "aaaXYZzzz"을 돌려 줍니다.</em>
NewStr := RegExReplace("abc123abc456", "abc\d+", "", ReplacementCount)  <em>; ""를 돌려주고 2를 ReplacementCount에 저장합니다.</em>

<em>; 일반적인 RegEx 예제는 <a href="../misc/RegEx-QuickRef.htm">RegEx 간편 참조서</a>를 일독 하십시오.</em></pre>

</body>
</html>
