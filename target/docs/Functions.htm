<!DOCTYPE HTML>
<html lang="ko">
<head>
<title>Functions - Definition &amp; Usage | AutoHotkey</title>
<meta name="description" content="Learn details about functions in general, parameters, returning values, built-in functions, variadic functions, etc." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>함수</h1>

<h2 id="toc">목차</h2>
<ul>
  <li><a href="#intro">소개와 간단한 예제</a></li>
  <li><a href="#param">매개변수</a></li>
  <li><a href="#optional">선택적 매개변수</a></li>
  <li><a href="#return">호출자에게 값을 돌려주기</a></li>
  <li><a href="#Variadic">가변 함수</a></li>
  <li><a href="#Local">지역 변수</a></li>
  <li><a href="#DynCall">동적으로 함수를 호출하기</a></li>
  <li><a href="#ShortCircuit">단축 회로 불리언 평가</a></li>
  <li><a href="#gosub">함수 안에서 서브루틴 사용하기</a></li>
  <li><a href="#remarks">Return, Exit, 그리고 총평</a></li>
  <li><a href="#include">#Include를 사용해 여러 스크립트 사이에 함수를 공유하기</a></li>
  <li><a href="#lib">함수 라이브러리: 표준 라이브러리와 사용자 라이브러리</a></li>
  <li><a href="#BuiltIn">내장 함수</a></li>
</ul>
<h2 id="intro">소개와 간단한 예제</h2>
<p id="define">함수는 서브루틴 (<a href="lib/Gosub.htm">Gosub</a>)과 비슷합니다. 단, 호출자로부터 매개변수(입력)를 받을 수 있다는 점은 다릅니다. 게다가, 함수는 선택적으로 값을 호출자에게 돌려줄 수 있습니다. 다음의 간단한 함수를 연구해 보겠습니다. 두 개의 숫자를 받고 그 합을 돌려줍니다:</p>
<pre>Add(x, y)
{
    return x + y   <em>; "<a href="lib/Return.htm">Return</a>"은 <a href="Variables.htm#Expressions">표현식</a>을 기대합니다.</em>
}</pre>
<p>위의 코드는 <em>함수 정의</em>라고 알려져 있는데 "Add" (대소문자 구분 없음)라는 이름의 함수를 생성하고 그 함수를 호출하려면 누구라도 정확하게 두 개의 매개변수 (x와 y)를 제공하도록 확립합니다. 이 함수를 호출하려면, <strong><a href="lib/SetExpression.htm">:=</a></strong><a href="lib/SetExpression.htm">연산자</a>로 그의 결과를 변수에 할당합니다. 예를 들어:</p>
<pre>Var := Add(2, 3)  <em>; 숫자 5가 Var에 저장됩니다.</em></pre>
<p>또, 함수는 그의 반환 값을 저장하지 않고서도 호출할 수 있습니다:</p>
<pre>Add(2, 3)</pre>
<p>그러나 이 경우, 함수가 돌려주는 값은 모두 폐기됩니다; 그래서 함수가 반환 값을 돌려주는 일 외에 다른 효과를 생산하지 않는 한, 이 호출은 어떤 목적에도 기여하지 못합니다.</p>
<p>함수 호출은 <a href="Variables.htm#Expressions">표현식</a>이기 때문에, 매개변수 목록의 변수 이름은 퍼센트 사인으로 둘러싸지 않아도 됩니다. 대조적으로, 기호 문자열을 겹따옴표로 둘러 싸야 합니다. 예를 들어:</p>
<pre>if <a href="#InStr">InStr</a>(MyVar, "fox")
    MsgBox 변수 MyVar에는 단어 fox가 들어 있습니다.</pre>
<p>마지막으로, 함수는 다른 명령어의 매개변수에서 호출할 수도 있습니다 (<a href="lib/StringLen.htm">StringLen</a>의 매개변수와 같이 OutputVar와 InputVar 같은 매개변수는 예외입니다). 그렇지만, <a href="Variables.htm#Expressions">표현식</a>을 지원하지 않는 매개변수는 다음 예제와 같이 반드시 "% " 를 접두기호로 사용해야 합니다:</p>
<pre>MsgBox % "정답은 다음과 같습니다: " . Add(3, 2)</pre>
<p>"% " 접두기호는 또 근본적으로 표현식을 지원하는 매개변수에도 허용됩니다. 그러나 그냥 무시됩니다.</p>
<h2 id="param">매개변수</h2>
<p>함수가 정의될 때, 그의 매개변수는 함수 이름 옆 괄호 안에 나열됩니다 (함수와 여는 괄호 사이에 공간이 있으면 안됩니다). 함수가 매개변수를 받지 않으면, 괄호를 빈 채로 둡니다: <code>GetCurrentTimestamp()</code>.</p>
<p id="ByRef"><strong>ByRef 매개변수</strong>: 함수의 관점에서, 매개변수는 본질적으로 <a href="#Local">지역 변수</a>와 똑같습니다. 그러나 다음 예제와 같이 <em>ByRef</em>로 정의된다면 다릅니다:</p>
<pre>Swap(ByRef Left, ByRef Right)
{
    temp := Left
    Left := Right
    Right := temp
}</pre>
<p>위의 예제에서, <em>ByRef</em>를 사용하면 각 매개변수들이 호출자로부터 들어오는 변수에 대하여 별명이 됩니다. 다른 말로, 매개변수와 호출자의 변수는 모두 메모리의 같은 내용을 가리킵니다. 이 때문에 Swap 함수는 호출자의 변수를 변경할 수 있습니다. <em>Left</em>의 내용을 <em>Right</em>으로 그리고 그 반대로 이동시킬 수 있습니다.</p>
<p>대조적으로, <em>ByRef</em>가 위의 예제에서 사용되지 않았다면, <em>Left</em>와 <em>Right</em>는 호출자 변수의 사본이 되어야 합니다. 그래서 Swap 함수는 외부적으로 아무 효과가 없을 것입니다.</p>
<p><a href="lib/Return.htm">return</a>은 함수의 호출자에게 오직 하나의 값만 다시 돌려줄 수 있기 때문에, <em>ByRef</em>를 사용하면 추가 결과를 더 돌려줄 수 있습니다. 호출자에게 (보통 빈) 변수를 건네게 하고 거기에 함수가 값을 저장하면 됩니다.</p>
<p>방대한 문자열을 함수에 건넬 때, <em>ByRef</em>는 수행성능을 향상시키고 메모리를 그대로 유지합니다. 문자열의 사본을 만들 필요가 없기 때문입니다. 비슷하게, <em>ByRef</em>를 사용하여 긴 문자열을 다시 호출자에게 보내면 <code>Return HugeString</code>와 같이 하는 것에 비해 보통 수행성능이 더 향상됩니다.</p>
<p><span class="ver">[AHK_L 60+]:</span> 변경가능한 변수 말고 어떤 것이 ByRef 매개변수에 건네지면, 함수는 마치 키워드 "ByRef"가 없는 것처럼 행위합니다. 예를 들어, <code>Swap(A_Index, i)</code>는 <i>A_Index</i>의 값을 <i>i</i>에 저장하지만, <i>Left</i>에 할당된 값은 <i>Swap</i> 함수가 반환되는 순간 폐기됩니다.</p>
<p><span class="ver">[v1.1.01+]:</span> <a href="#IsByRef">IsByRef()</a> 함수를 사용하면 호출자가 주어진 ByRef 매개변수에 대하여 변수를 공급했는지 알 수 있습니다.</p>
<p>알려진 한계:</p>
<ul>
  <li>객체의 필드는 <em>ByRef</em> 목적에 대하여 변수로 간주되지 않습니다. 예를 들어, <code>foo.bar</code>가 ByRef 매개변수에 건네지면, 마치 <em>ByRef</em> 키워드가 생략된 것처럼 행위합니다.</li>
  <li><a href="misc/Clipboard.htm">클립보드</a>, <a href="Variables.htm#BuiltIn">내장 변수</a>, 또는 <a href="Concepts.htm#environment-variables">환경 변수</a>를 함수의 <em>ByRef</em> 매개변수에 보낼 수 없습니다. 스크립트에 <a href="lib/_NoEnv.htm">#NoEnv</a>가 존재하지 않을지라도 보낼 수 없습니다.</li>
  <li id="recurse">함수가 자신을 재귀적으로 호출할 수는 있지만, 자신의 <a href="#Local">지역 변수</a> 또는 비-ByRef 매개변수를 자기 자신 <em>ByRef</em>에게 건네면, 새로운 레이어의 <em>ByRef</em> 매개변수는 이전 레이어의 매개변수가 아니라 자기 자신의 지역 변수의 이름을 가리킬 것입니다. 그렇지만, 함수가 자기 자신에게 <a href="#Global">전역 변수</a>, <a href="#static">정적 변수</a>, 또는 <em>ByRef</em> 매개변수를 건넬 때 이런 문제는 일어나지 않습니다.</li>
  <li>함수-호출에서 매개변수가 변수로 결정되면 (예, <code>Var</code> 또는 <code>++Var</code> 또는 <code>Var*=2</code>), 왼쪽이나 오른쪽의 다른 매개변수들은 그 변수가 함수에 건네지기 전에 변경할 수 있습니다. 예를 들어, <code>MyFunc(Var, Var++)</code>는 <em>Var</em>가 처음부터 0일 때 예상치 못하게 1과 0을 건네게 됩니다. 심지어 함수의 첫 매개변수가 <em>ByRef</em>가 아닐 때도 그렇습니다. 이 행위는 반직관적이기 때문에, 미래의 배포본에서는 바뀔 가능성이 있습니다.</li>
  <li>ByRef는 COM 클라이언트가 호출하는 함수에서 또는 COM 메쏘드를 호출할 때 직접적으로 지원하지 않습니다. 대신에, 스크립트는 안에 <a href="lib/ComObjActive.htm#ByRef">VarType</a>과 값의 주소가 들어있는 <a href="lib/ComObjType.htm">래퍼 객체</a>를 주고 받아야 합니다.</li>
</ul>
<h2 id="optional">선택적 매개변수</h2>
<p>함수를 정의할 때, 하나 이상의 매개변수에 선택적 표식을 할 수 있습니다. This is done by appending <code>:=</code> (in <span class="ver">[v1.1.09]</span> or later) or <code>=</code>, followed by the parameter's default value, which must be one of the following: <code>true</code>, <code>false</code>, 문자 그대로의 정수, 문자 그대로의 부동 소수점 수, 또는 "fox" 또는 ""와 같이 인용부호처리되어 문자 그대로의 문자열. (그러나 <span class="ver">[v1.0.46.13]</span>이전 버전의 문자열은 오직 ""만 지원합니다).</p>
<p>The use of <code>=</code> (without a colon) is permitted for backward-compatibility, but not recommended, and will not be permitted by AutoHotkey v2. Regardless of which operator is used, default values which are strings must always be enclosed in quote marks.</p>
<p>다음 함수는 Z 매개변수에 선택적 표식이 붙어 있습니다:</p>
<pre>Add(X, Y, Z:=0) {
    return X + Y + Z
}</pre>
<p>호출자가 <strong>세 개의</strong> 매개변수를 위의 함수에 건네면, Z의 기본 값은 무시됩니다. 그러나 호출자가 오직 <strong>두 개의</strong> 매개변수만 건네면, Z는 자동으로 기본값 0을 받습니다.</p>
<p id="missing">선택적 매개변수를 리스트 한 가운데에 따로 배치하는 것은 불가능합니다. 다른 말로 하면, 첫 번째 선택적 매개변수의 오른쪽에 나오는 모든 매개변수도 역시 선택적으로 표식이 붙어야 합니다. <span class="ver">[AHK_L 31+]:</span> 선택적 매개변수는 매개변수 리스트의 중앙에서는 생략할 수 있습니다. 아래와 같이 함수를 호출합니다. 동적인 함수 호출과 메쏘드 호출은 <span class="ver">[v1.1.12+]</span>이상이 필요합니다.</p>
<pre>MyFunc(1,, 3)
MyFunc(X, Y:=2, Z:=0) {  <em>; 이 경우 Z는여전히 선택적이어야 함에 유의합니다.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
<p id="OptionalByRef"><span class="ver">[v1.0.46.13+]</span>: <a href="#ByRef">ByRef 매개변수</a>도 기본값을 지원합니다; 예를 들어: <code>MyFunc(ByRef p1 = "")</code>. 호출자가 그런 매개변수를 빼먹을 때마다, 함수는 지역 변수를 만들어 기본 값을 담습니다; 다른 말로, 함수는 마치 키워드 "ByRef"가 존재하지 않는 것처럼 행위합니다.</p>

<h2 id="return">호출자에게 값을 돌려주기</h2>
<p><a href="#intro">소개</a>에 기술한 바와 같이, 함수는 선택적으로 값을 호출자에게 <a href="lib/Return.htm">돌려줄</a> 수 있습니다.</p>
<pre>
Test := returnTest()
MsgBox % Test

returnTest() {
    return 123
}
</pre>
<p>함수로부터 결과를 더 많이 돌려주고 싶다면, <a href="#ByRef">ByRef</a>를 사용할 수 있습니다:</p>
<pre>
returnByRef(A,B,C)
MsgBox % A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
    val1 := "A"
    val2 := 100
    val3 := 1.1
    return
}
</pre>
<p><span class="ver">[v1.0.97+]:</span> <a href="Objects.htm#Usage_Objects">객체</a>와 <a href="Objects.htm#Usage_Simple_Arrays">배열</a>을 사용하면 여러 값들 심지어 이름 붙은 값들도 돌려줄 수 있습니다:</p>
<pre>
Test1 := returnArray1()
MsgBox % Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox % Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox % Test3.id "," Test3.val

returnArray1() {
    Test := [123,"ABC"]
    return Test
}

returnArray2() {
    x := 456
    y := "EFG"
    return [x, y]
}

returnObject() {
    Test := {id: 789, val: "HIJ"}
    return Test
}
</pre>
<h2 id="Variadic">가변 함수 <span class="ver">[AHK_L 60+]</span></h2>
<p>함수를 정의할 때, 별표를 마지막 매개변수 뒤에 쓰면 그 함수를 가변함수로 만들 수 있습니다. 가변 개수의 매개변수를 받을 수 있습니다:</p>
<pre>Join(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Join("`n", "one", "two", "three")</pre>
<p>가변 함수를 호출할 때, 넘치는 매개변수는 함수의 마지막 매개변수에 저장되어 있는 객체를 통하여 접근할 수 있습니다. 넘친 첫 번째 매개변수는 <code><i>params</i>[1]</code>에 있고, 두 번째는 <code><i>params</i>[2]</code>에 등등에 있습니다. 다른 표준 객체처럼<code><i>params</i>.MaxIndex()</code>를 사용하면 숫치상 가장 높은 인덱스를 알 수 있습니다 (이 경우 매개변수의 개수입니다). 그렇지만, 매개변수가 없다면, MaxIndex는 빈 문자열을 돌려줍니다.</p>
<p>주의:</p>
<ul>
  <li>"가변" 매개변수는 오직 형식 매개변수 리스트의 끝에만 나타날 수 있습니다.</li>
  <li><a href="misc/RegExCallout.htm">RegEx 콜아웃은</a> 가변적일 수 없습니다; "가변" 매개변수는 받지만, 빈 채로 둡니다.</li>
  <li><a href="lib/RegisterCallback.htm">역호출</a>은 넘친 매개변수들을 베열이 아니라 <a href="lib/RegisterCallback.htm#Indirect">주소로</a> 건넵니다.</li>
</ul>
<h3 id="VariadicCall">가변 함수 호출</h3>
<p>가변 함수가 가변 개수의 매개변수를 <i>받아들일 수</i> 있는 반면, 매개변수 배열을 <i>어떤 함수에도</i> 건넬 수 있습니다. 같은 구문을 함수-호출에 적용하면 됩니다:</p>
<pre>substrings := ["one", "two", "three"]
MsgBox % Join("`n", <b class="blue">substrings*</b>)</pre>
<p>주의:</p>
<ul>
  <li>소스 배열 안에서 매개변수의 번호는 1부터 시작합니다.</li>
  <li>선택적 매개변수는 그 배열에서 완전히 생략해도 됩니다.</li>
  <li>매개변수 배열은 사용자-정의 함수를 호출할 때 이름붙은 항목을 담을 수 있습니다; 다른 경우는, 이름붙은 항목을 지원하지 않습니다.</li>
  <li>목표 함수도 가변적일 수 있습니다. 이 경우 이름붙은 항목은 상응하는 형식 매개변수가 없더라도 복사됩니다.</li>
  <li>이 구문은 또 메쏘드를 호출하거나 객체의 특성을 열람할 때 사용할 수 있습니다; 예를 들어, <code>Object.Property[Params*]</code>. <span class="ver">[v1.1.12+]</span>: 이에서는 특성을 설정하는 데에도 사용할 수 있습니다.</li>
</ul>
<p>알려진 한계:</p>
<ul>
  <li>제일 오른쪽 매개변수만 이런식으로 확장할 수 있습니다. 예를 들어, <code>MyFunc(x, y*)</code>는 지원하지만 <code>MyFunc(x*, y)</code>는 지원하지 않습니다.</li>
  <li>별표(<code>*</code>)와 매개변수 리스트를 끝내는 심볼 사이에 공백문자말고 다른 문자는 허용하지 않습니다.</li>
</ul>
<h2 id="Locals">지역 변수와 전역 변수</h2>
<h3 id="Local">지역 변수</h3>
<p>Local variables are specific to a single function and are visible only inside that function. 결과적으로, 지역 변수는 전역 변수와 이름이 같을 수 있습니다. 그리고 서로 다른 내용을 가질 수 있습니다. Separate functions may also safely use the same variable names.</p>
<p>All local variables which are not <a href="#static">static</a> are automatically freed (made empty) when the function returns.</p>
<p>Built-in variables such as <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a>, and <a href="Variables.htm#TimeIdle">A_TimeIdle</a> are never local (they can be accessed from anywhere), and cannot be redeclared.</p>
<p id="AssumeLocal">Functions are <strong>assume-local</strong> by default. Variables accessed or created inside an assume-local function are local by default, with the following exceptions:</p>
<ul>
  <li><a href="#SuperGlobal">Super-global</a> variables, including <a href="Objects.htm#Custom_Classes">classes</a>.</li>
  <li>A <a href="#DynVar">dynamic variable reference</a> may resolve to an existing global variable if no local variable exists by that name.</li>
  <li><a href="#PseudoArrays">Commands that create pseudo-arrays</a> may create all elements as global even if only the first element is declared.</li>
</ul>
<p>The default may also be overridden as shown below (by declaring the variable or by changing the mode of the function).</p>
<p id="ForceLocal"><strong>Force-local mode</strong> <span class="ver">[v1.1.27+]</span>: If the function's first line is the word "local", all variable references (even dynamic ones) are assumed to be local unless they are declared as global <em>inside</em> the function. Unlike the default mode, force-local mode has the following behavior:</p>
<ul>
  <li>Super-global variables (including classes) cannot be accessed without declaring them inside the function.</li>
  <li>Dynamic variable references follow the same rules as non-dynamic ones. Only global variables which are declared inside the function can be accessed.</li>
  <li>StringSplit and other commands which create pseudo-arrays follow the same rules as non-dynamic variable references (avoiding a common source of confusion).</li>
  <li>The <em>LocalSameAsGlobal</em> <a href="lib/_Warn.htm">warning</a> is never raised for variables within a force-local function.</li>
</ul>

<h3 id="Global">전역 변수</h3>
<p>함수 안에서 기존의 전역 변수를 참조하려면 (또는 새로 만들려면), 변수를 global로 선언한 다음 사용합니다. 예를 들어:</p>
<pre>LogToFile(TextToLog)
{
    global LogFileName  <em>; 이 전역 변수는 이 함수 바깥 어딘가에 미리 값이 주어져 있습니다.</em>
    FileAppend, %TextToLog%`n, %LogFileName%
}</pre>
<p id="AssumeGlobal"><strong>전역-간주 모드</strong>: 함수가 방대한 개수의 전역 변수를 만들거나 접근할 필요가 있다면, 그의 모든 변수를 전역적으로 간주하도록 정의할 수 있습니다 (매개변수는 제외). 첫 줄을 단어 "global"로 만들거나 지역 변수의 선언으로 만들면 됩니다. 예를 들어:</p>
<pre>SetDefaults()
{
    global  <em>; 함수의 첫 줄이 "local MyVar"와 같은 것으로 시작하면 이 단어는 생략해도 됩니다.</em>
    MyGlobal := 33  <em>; 33을 전역 변수에 할당합니다. 필요하면 먼저 변수를 만듭니다.</em>
    local x, y:=0, z  <em>; 지역 변수는 이 모드로 선언해야 합니다. 그렇지 않으면 전역적으로 간주됩니다.</em>
}</pre>
<p>전역-간주 모드를 함수에 사용하면 예를 들어 값을 <code>Array%A_Index%</code>에 할당하는 회돌이와 같이 전역 <a href="misc/Arrays.htm">배열</a>을 만들 수 있습니다.</p>
<p id="SuperGlobal"><strong>슈퍼-전역 변수</strong> <span class="ver">[v1.1.05+]</span>: If a global declaration appears outside of any function, it takes effect for all functions by default (excluding <a href="#ForceLocal">force-local</a> functions). 그래서 각 함수마다 해당 변수를 다시 선언할 필요가 없습니다. 그렇지만, 함수 매개변수나 지역 변수에 같은 이름이 선언되어 있다면, 전역 변수보다 우선 순위가 놓습니다. <a href="Objects.htm#Custom_Classes">class</a> 키워드로 만든 변수도 수퍼-전역 변수입니다.</p>
<h3 id="static">정적 변수</h3>
<p>정적 변수는 언제나 묵시적으로 지역적이지만, 지연 변수와는 다른 점이 있습니다. 호출 사이에 값을 기억합니다. 예를 들어:</p>
<pre>LogToFile(TextToLog)
{
    <strong>static</strong> LoggedLines := 0
    LoggedLines += 1  <em>; 완전히 지역적으로 유지관리합니다 (그의 값은 호출 사이에 기억됩니다).</em>
    global LogFileName
    FileAppend, %LoggedLines%: %TextToLog%`n, %LogFileName%
}</pre>
<p id="InitStatic"><strong>정적 초기화자</strong>: 1.0.46 이전 버전에서, 모든 정적 변수는 빈 채로 시작했습니다; 그래서 처음으로 사용되는 변수인지 탐지하는 유일한 방법은 그것이 비어있는지 점검하는 것이었습니다. <span class="ver">[v1.0.46+]</span>: 정적 변수는 <code>""</code> 말고 다른 것으로 초기화할 수 있습니다. 먼저 <code>:=</code>이나 <code>=</code>를 두고 바로 이어 다음 중 하나가 오면 됩니다: <code>true</code>, <code>false</code>, 기호 그대로의 숫자, 기호 그대로의 부동 소수점 수, 또는 <code>"fox"</code>과 같이 기호 그대로/ 인용부호 처리된 문자열. 예를 들어: <code>static X:=0, Y:="fox"</code>. 각 정적 변수는 (스크립트가 실행을 시작하기 전에) 오직 한 번만 초기화됩니다.</p>
<p><span class="ver">[AHK_L 58+]:</span> <code>Static var := expression</code>을 지원합니다. 그런 모든 표현식은 나타나는 순서대로 스크립트의 자동-실행 섹션 바로 앞에서 평가됩니다.</p>
<p id="AssumeStatic"><strong>정적-간주 모드</strong> <span class="ver">[v1.0.48+]:</span> 함수는 그의 모든 변수가 정적이라고 간주하도록 정의할 수 있습니다 (그의 매개변수는 제외). 첫 줄을 "static"이라는 단어로 만들면 됩니다. 예를 들어:</p>
<pre>GetFromStaticArray(WhichItemNumber)
{
    <strong>static</strong>
    static FirstCallToUs := true  <em>; 정적 선언의 초기화자는 여전히 (기동시에) 한 번만 실행됩니다.</em>
    if FirstCallToUs  <em>; 첫 번째 호출 동안 정적 배열을 만듭니다. 그러나 그 다음 호출에는 만들지 않습니다.</em>
    {
        FirstCallToUs := false
        Loop 10
            StaticArray%A_Index% := "Value #" . A_Index
    }
    return StaticArray%WhichItemNumber%
}</pre>
<p>In assume-static mode, any variable that should not be static must be declared as local or global (with the same exceptions as for <a href="#AssumeLocal">assume-local mode</a>, unless <a href="#ForceLocal">force-local mode</a> is also in effect).</p>
<p><span class="ver">[v1.1.27+]:</span> <a href="#ForceLocal">Force-local mode</a> can be combined with assume-static mode by specifying <code>local</code> and then <code>static</code>, as shown below. This allows the function to use force-local rules but create variables as static by default.</p>
<pre>global MyVar := "This is global"
DemonstrateForceStatic()

DemonstrateForceStatic()
{
    local
    static
    MyVar := "This is static"
    ListVars
    MsgBox
}
</pre>
<h3 id="More_about_locals_and_globals">지역 변수와 전역 변수에 관하여 더 자세히</h3>
<p>많은 변수들을 한 줄에 선언할 수 있습니다. 다음 예제와 같이 쉼표로 가르면 됩니다:</p>
<pre>global LogFileName, MaxRetries := 5
static TotalAttempts := 0, PrevResult</pre>
<p id="DeclareInit"><span class="ver">[v1.0.46+]</span>: 전역 변수나 지역 변수는 선언과 동시에 같은 줄에서 초기화할 수 있습니다. <code>:=</code>이나 <code>=</code> 다음에 <a href="Variables.htm#Expressions">표현식</a>을 두면 됩니다 (<code>=</code> 연산자는 선언에서 <code>:=</code>와 똑같이 행위합니다). <a href="#InitStatic">정적 초기화자</a>와 다르게, 지역 변수와 전역 변수의 초기화자는 함수가 호출될 때마다 매번 실행됩니다. 그러나 오직 실행 흐름이 실제로 거기에 다다를 때에만 초기화합니다. 다른 말로, <code>local x := 0</code>과 같은 줄은 다음과 같이 두 개의 서술문으로 작성한 것과 효과가 같습니다: <code>local x</code> 다음에 <code>x := 0</code>.</p>
<p><em>local</em>, <em>global</em>, 그리고 <em>static</em>같은 단어는 스크립트가 기동하자 마자 즉시 처리되기 때문에, 변수는 <a href="lib/IfExpression.htm">IF 서술문</a>을 수단으로 하여 조건적으로 선언할 수 없습니다. 다른 말로 하면, IF 또는 ELSE <a href="lib/Block.htm">블록</a>안에서 선언하면 해당 선언과 그 함수의 닫는 괄호 사이에 있는 모든 줄들에 예상치 못한 효과를 미칩니다. 또 주목할 것은 <code>global Array%i%</code>와 같이 동적으로 변수를 선언하는 것은 현재 가능하지 않다는 것입니다.</p>
<p id="PseudoArrays">(<a href="misc/Arrays.htm">StringSplit</a> 같은) <a href="lib/StringSplit.htm">의사-배열</a>을 생성하는 명령어에 대하여, <a href="#AssumeGlobal">전역-간주 모드</a>가 영향이 없거나 또는 의사-배열의 첫 번째 원소가 지역 변수로 선언되어 있다면, 결과 의사-배열의 각 변수는 지역 변수입니다. (그 함수의 매개변수 중 하나가 건네질지라도 마찬가지입니다 -- 그 매개변수가 <a href="#ByRef">ByRef</a>일지라도 -- 왜냐하면 매개변수는 지역 변수와 비슷하기 때문입니다). 역으로, 첫 원소가 <a href="#Global">global</a>로 선언되었다면, 전역 배열이 생성됩니다. 그렇지만, 아래의 <i>흔한 혼란의 근원</i>이 이 경우에도 적용되니다. <a href="lib/StringSplit.htm">StringSplit</a>의 첫 원소는 ArrayName0입니다. <a href="lib/WinGet.htm">WinGet List</a>와 같이 다른 배열-생성 명령어에 대하여, 첫 번째 원소는 ArrayName입니다 (즉, 숫자가 없습니다). <span class="ver">[v1.1.27+]:</span> When <a href="#ForceLocal">force-local mode</a> is in effect, these commands follow rules consistent with normal variable references; that is, any pseudo-array element not declared as global will be local even if other elements are declared global.</p>
<p id="DynVar"><span id="Dynamic"></span>Within a function (unless <a href="#ForceLocal">force-local mode</a> is in effect), any dynamic variable reference such as <code>Array%i%</code> always resolves to a local variable unless no variable of that name exists, in which case a global is used if it exists. 아예 존재하지 않으면 새로 생성될 필요가 있습니다. 지역 변수로 생성됩니다. 단, <a href="#AssumeGlobal">전역-간주 모드</a>가 켜 있다면 전역 변수로 생성됩니다. 결과적으로, 함수는 (<code>Array%i% := A_Index</code>과 같은 수단을 사용하여) 수동으로 전역 <a href="misc/Arrays.htm">배열</a>을 만들 수 있습니다. 물론 <a href="#AssumeGlobal">전역-간주</a> 함수로 선언되어 있어야 합니다.</p>
<p id="ArrayConfusion"><strong>흔한 혼란의 근원</strong>: 변수를 동적으로 참조했는데 <em>존재하지 않으면</em> 스크립트가 기동하는 순간 그 변수가 생성됩니다. 예를 들어, 함수 밖에서 사용될 때, <code>MsgBox %Array1%</code>는 스크립트가 기동하는 순간 Array1을 전역변수로 생성합니다. 반대로, 함수 안에서 사용될 때, <code>MsgBox %Array1%</code>는 스크립트가 기동하는 순간 (<a href="#AssumeGlobal">전역-간주</a> 모드가 아닌 한), Array와 Array0이 전역 변수로 선언되어 있다고 할지라도, Array1을 지역 변수중 하나로 생성합니다.</p>
<h2 id="DynCall">동적으로 함수를 호출하기</h2>
<p><span class="ver">[v1.0.47.06+]</span>: 함수는 (<a href="#BuiltIn">내장 함수</a>도 역시) 퍼센트 사인을 통하여 동적으로 호출할 수 있습니다. 예를 들어, <code>%Var%(x, "fox")</code>는 이름이 <em>Var</em> 안에 들어 있는 함수를 호출합니다. 비슷하게, <code>Func%A_Index%()</code>는 A_Index의 현재 값에 따라서 Func1() 또는 Func2(), 등등을 호출합니다.</p>
<p><span class="ver">[v1.1.07.00+]</span>: <em>Var</em> in <code>%Var%()</code> can contain a function name or a <a href="misc/Functor.htm">function object</a>. 해당 함수가 존재하지 않으면, <a href="Objects.htm#Default_Base_Object">기본 베이스 객체</a>의 __Call 메타-함수가 대신에 요청됩니다.</p>
<p>아래의 이유 중 하나 때문에 함수를 호출할 수 없다면, 그 호출을 담고 있는 표현식의 평가가 조용히 그리고 너무 빨리 끝나므로, 일관성 없는 결과를 도출할 수 있습니다:</p>
<ul>
  <li>존재하지 않는 함수를 호출합니다. 이것은 <code>If <a href="#IsFunc">IsFunc</a>(VarContainingFuncName)</code>를 사용하면 피할 수 있습니다. <a href="#BuiltIn">내장 함수</a>를 제외하고, 호출된 함수의 <a href="#define">정의</a>는 반드시 명시적으로 스크립트에 존재해야 합니다. 비-동적으로 <a href="#lib">라이브러리 함수</a>를 호출하거나 <a href="lib/_Include.htm">#Include</a>와 같은 수단을 사용합니다.</li>
  <li>너무 매개변수를 적게 건넵니다. 이것은 <a href="#IsFunc">IsFunc()</a>의 반환 값을 점검하면 피할 수 있습니다 (반환값은 필수 매개변수의 개수에 1을 더한 값입니다). <span class="ver">[v1.0.48+]</span>: Note that passing too many parameters is tolerated; each extra parameter is fully evaluated (including any calls to functions) and then discarded.</li>
</ul>
<p>마지막으로, 함수를 동적으로 호출하면 정상 호출보다 약간 더 느립니다. 왜냐하면 정상 호출은 스크립트가 실행을 하기 전에 결정(검색 완료)되기 때문입니다.</p>
<h2 id="ShortCircuit">단축 회로 불리언 평가</h2>
<p><em>AND, OR</em>, 그리고 <a href="Variables.htm#ternary">삼진 연산자</a>가 <a href="Variables.htm#Expressions">표현식</a> 안에 사용될 때, 단축 회로 평가로 수행성을 개선합니다 (함수 호출이 존재하는가 여부에 상관없이). 단축 회로 평가는 최종 결과에 영향을 미칠 수 없는 부분을 평가하지 않습니다. 개념을 보여주기 위해, 다음 예제를 연구해 보겠습니다:</p>
<pre>if (ColorName != "" AND not FindColor(ColorName))
    MsgBox %ColorName%을 발견할 수 없습니다.</pre>
<p>위의 예제에서, FindColor() 함수는 <em>ColorName</em> 변수가 비어있지 않는 한, 절대 호출되지 않습니다. 이 때문에 <em>AND</em>의 왼쪽이 <em>false</em>가 되고, 그의 오른쪽 만으로는 <em>true</em>라는 최종 결과를 생산할 가능성이 전혀 없기 때문입니다.</p>
<p>이 행위 때문에, 그 함수가 <em>AND</em>나 <em>OR</em>의 오른쪽에 호출되더라도, 함수가 생산하는 부작용이 (전역 변수의 내용을 변경하는 것과 같은) 절대로 일어나지 않을 것이라는 사실을 깨닫는 것이 중요합니다.</p>
<p>또 주목할 것은 단축-회로 평가가 내포된 <em>AND</em>와 <em>OR</em>에 단계적으로 적용된다는 것입니다. 예를 들어, 다음 표현식에서, <em>ColorName</em>이 비어 있으면 오직 왼쪽의 평가만 일어납니다. 왜냐하면 왼쪽 만으로 최종 정답을 확실하게 결정하기에 충분하기 때문입니다:</p>
<pre>if (ColorName = "" <u>OR</u> FindColor(ColorName, Region1) <u>OR</u> FindColor(ColorName, Region2))
    break   <em>; 더 이상 검색 것이 없습니다. 일치한 것이 없습니다.</em></pre>
<p>위의 예제에서 보여주는 바와 같이, 비싼 (시간이-드는) 함수라면 일반적으로 <em>AND</em>나 <em>OR</em>의 오른쪽에서 호출해야 수행성능이 개선됩니다. 이 테크닉을 사용하면 또 그의 매개변수 중 하나에 부적절한 값이, 예를 들어 빈 문자열이 건네질 때, 함수가 호출되지 못하도록 만들 수 있습니다.</p>
<p><span class="ver">[v1.0.46+]</span>: <a href="Variables.htm#ternary">삼진 조건 연산자 (?:)</a>도 단축 평가를 합니다. 필요 없는 분기는 평가하지 않습니다.</p>
<h2 id="gosub">함수 안에서 서브루틴 사용하기</h2>
<p>함수에 다른 함수의 <a href="#define">정의</a>는 담을 수 없지만, 서브루틴은 담을 수 있습니다. 다른 서브루틴과 마찬가지로 <a href="lib/Gosub.htm">Gosub</a>로 기동하고 <a href="lib/Return.htm">Return</a>으로 반환됩니다 (이 경우 Return은 Gosub에 속하지 함수에 속하지 않습니다).</p>
<p>알려진 한계: 현재, 각 서브루틴의 이름(라벨)은 전체 스크립트 안에서 유일하게 식별할 수 있어야 합니다. 프로그램은 라벨이 중복되어 있으면 기동할 때 여러분에게 고지할 것입니다.</p>
<p id="GosubPublic">함수가 <a href="lib/Gosub.htm">Gosub</a>를 사용해 (함수의 괄호 밖에 존재하는) 공개 서브루틴으로 점프해 가면, 바깥의 모든 변수는 전역 변수이고 서브루틴이 돌아올 때까지 함수 자신의 <a href="#Local">지역 변수</a>에는 접근할 수 없습니다. 그렇지만, A_ThisFunc는 여전히 함수의 이름을 담고 있을 것입니다.</p>
<p><a href="lib/Goto.htm">Goto</a>로는 함수 안에서 밖으로 점프해 갈 수 없지만, 함수는 외부/공개 서브루틴으로 <a href="lib/Gosub.htm">Gosub</a>할 수 있으며 거기부터 Goto를 사용하면 됩니다.</p>
<p><a href="lib/Goto.htm">Goto</a>의 사용은 일반적으로 권장하지 않지만, 함수 안에서 또다른 위치로 점프하는데 사용할 수 있습니다. 이렇게 하면 복잡한 함수를 간략하게 만드는 데 도움이 될 수 있습니다. 반환 지점이 수 없이 많고, 그 모두가 돌아오기 전에 깨끗하게 청소해야 할 경우 유용합니다.</p>
<p>함수는 외부적으로-호출되는 서브루틴을 담을 수 있습니다. 예를 들어 <a href="lib/SetTimer.htm">타이머</a>, <a href="lib/Gui.htm#label">GUI g-labels</a>, 그리고 <a href="lib/Menu.htm">메뉴 항목</a>이 그것입니다. 일반적으로 별도의 파일에 싸 넣고 <a href="lib/_Include.htm">#Include</a>와 함께 사용합니다. 이렇게 하면 스크립트의 <a href="Scripts.htm#auto">자동-실행 섹션</a> 때문에 서로 간섭하는 일을 막을 수 있습니다. 그렇지만, 다음 한계가 적용됩니다:</p>
<ul>
  <li>함수가 정상적으로 호출되었다면 그런 서브루틴은 <a href="#static">정적 변수</a>와 <a href="#Global">전역 변수</a>만 사용해야 합니다 (<a href="#Local">지역 변수</a> 불가). 왜냐하면 함수-호출 쓰레드를 가로 챈 (또는 그 반대로) 서브루틴 <a href="misc/Threads.htm">쓰레드</a>가 가로채어진 스레드에 보이는 지역 변수들의 값을 바꿀 가능성이 높기 때문입니다. 게다가, 언제라도 함수는 그의 호출자에게 돌아갑니다. 그의 모든 지역 변수는 비워져 메모리를 풀어줍니다.</li>
  <li>그런 서브루틴은 <a href="lib/Gui.htm#var">GUI 제어 변수</a>로 오직 <a href="#Global">전역 변수</a>만 사용해야 합니다 (<a href="#static">정적 변수</a> 불가).</li>
  <li>함수에 서브루틴 <a href="misc/Threads.htm">쓰레드</a>가 진입하면, 그 쓰레드가 만든 <a href="misc/Arrays.htm">동적 변수</a>를 참조하면 <a href="#Global">전역 변수</a>로 간주됩니다 (배열을 만든 명령어 포함).</li>
</ul>
<h2 id="remarks">Return, Exit, 그리고 총평</h2>
<p>다음 실행 흐름이 함수 안에서 <a href="lib/Return.htm">Return</a>을 만나기 전에 먼저 닫는 괄호에 도달하면, 그 함수는 끝나고 빈 값을 호출자에게 돌려줍니다 (빈 문자열). 빈 값은 또 함수가 명시적으로 <a href="lib/Return.htm">Return</a>의 매개변수를 생략할 때에도 반환됩니다.</p>
<p>함수가 <a href="lib/Exit.htm">Exit</a> 명령어를 사용하여 <a href="misc/Threads.htm">현재 쓰레드</a>를 종료하면, 그의 호출자는 반환 값을 전혀 받지 못합니다. 예를 들어, 다음 서술문 <code>Var := Add(2, 3)</code>는 가<code>Add()</code> 종료하면 <code>Var</code>를 그대로 둘 것입니다. 함수가 실행시간 에러를 일으켜도 같은 일이 일어납니다. 예를 들어 (<a href="lib/Run.htm#UseErrorLevel">UseErrorLevel</a>가 켜져 있지 않을 때) 존재하지 않는 파일을 <a href="lib/Run.htm">실행</a>하면 같은 일이 일어납니다.</p>
<p>함수는 기억하기 쉬운 값을 추가로 건네기 위한 목적으로 <a href="misc/ErrorLevel.htm">ErrorLevel</a>의 값을 변경할 수 있습니다.</p>
<p>함수를 하나 이상이 빈 값으로 호출하려면 (빈 문자열), 다음 예제와 같이 빈 따옴표 쌍을 사용합니다: <code>FindColor(ColorName, "")</code>.</p>
<p>함수를 호출하면 새로운 <a href="misc/Threads.htm">쓰레드</a>가 시작하므로, 함수가 <a href="lib/SendMode.htm">SendMode</a>와 <a href="lib/SetTitleMatchMode.htm">SetTitleMatchMode</a>와 같은 설정에 가한 변경은 모두 그의 호출자에게도 영향을 미칠 것입니다.</p>
<p>함수의 호출자는 거기에 존재하지 않은 값 또는 <a href="misc/Arrays.htm">배열</a>을 건넬 수 있습니다. 함수가 상응하는 매개변수를 <a href="#ByRef">ByRef</a>라고 기대할 경우에 유용합니다. 예를 들어, <code>GetNextLine(BlankArray%i%)</code>를 호출하면 자동으로 <code>BlankArray%i%</code> 변수가 생성됩니다 (호출자가 함수 안에 있는가 그리고 그 함수에 <a href="#AssumeGlobal">전역-간주 모드</a>가 켜져 있는가에 따라 <a href="#Local">지역 변수</a> 또는 전역 변수로 생성됩니다).</p>
<p>함수 안에서 사용될 때, <a href="lib/ListVars.htm">ListVars</a>는 함수의 <a href="#Local">지역 변수들</a>을 그의 내용과 함께 보여줍니다. 이는 스크립트 디버깅에 도움이 됩니다.</p>
<h2 id="Style_and_Naming_Conventions">스타일과 이름짓기 관례</h2>
<p>복잡한 함수는 특별한 변수에 구별되는 접두사를 부여하면 더 읽기 쉽고 관리하기 좋다는 사실을 눈치채셨을 것입니다. 예를 들어, 함수의 매개변수 리스트에서 각 매개변수의 이름을 앞에 "p" 또는 "p_"를 두어 지으면 한 눈에 그의 특수한 본성을 쉽게 구별할 수 있습니다. 특히 함수에 수 십개의 <a href="#Local">지역 변수</a>가 들어 있는데 전부 주의를 기울여 신경을 써야할 때 유용합니다. 비슷하게, 접두사 "r"이나 "r_"은 <a href="#ByRef">ByRef 매개변수</a>에 사용하면 좋고, "s"나 "s_"는 <a href="#static">정적 변수</a>에 사용할 수 있습니다.</p>
<p><a href="lib/Block.htm#otb">One True Brace (OTB) 스타일</a>을 선택적으로 함수를 정의하는 데 사용할 수 있습니다. 예를 들어:</p>
<pre>Add(x, y) {
    return x + y
}</pre>
<h2 id="include">#Include를 사용해 여러 스크립트 사이에 함수를 공유하기</h2>
<p><a href="lib/_Include.htm">#Include</a> 지시어를 사용하면 (<em>스크립트의 상단에도 가능</em>) 함수를 외부 파일로부터 적재할 수 있습니다.</p>
<p>설명: 스크립트의 실행 흐름이 함수 정의를 만다면, (순간적으로) 그것을 건너 뛰고 함수의 닫는 괄호 다음 줄부터 실행을 재개합니다. 결과적으로 실행은 위쪽에 있는 함수로 들어갈 수 없으며, 스크립트 최상단에 하나 이상의 함수가 존재하더라도 <a href="Scripts.htm#auto">자동-실행 섹션</a>에 영향을 미치지 않습니다.</p>
<h2 id="lib">함수 라이브러리: 표준 라이브러리와 사용자 라이브러리 <span class="ver">[v1.0.47+]</span></h2>
<p>스크립트는 외부 파일에 있는 함수를 호출할 수 있습니다. <a href="lib/_Include.htm">#Include</a>를 사용할 필요가 없습니다. 그러려면 함수와 같은 이름의 파일이 다음 라이브러리 디렉토리 중 하나에 존재해야 합니다:</p>
<pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; 지역 라이브러리 - 필수 <span class="ver">[AHK_L 42+]</span>.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; 사용자 라이브러리.</em>
directory-of-the-currently-running-AutoHotkey.exe\Lib\  <em>; 표준 라이브러리.</em></pre>
<p>예를 들어, 스크립트가 존재하지 않는 함수 <code>MyFunc()</code>를 호출하면, 프로그램은 사용자 라이브러리에서 "MyFunc.ahk"라른 이름의 파일을 찾습니다. 발견하지 못하면, 표준 라이브러리에서 찾습니다. 여전히 발견하지 못하면 그리고 함수의 이름에 밑줄이 포함되어 있다면 (예, <code>MyPrefix_MyFunc</code>), 프로그램은 두 라이브러리를 모두 뒤져 <code>MyPrefix.ahk</code>라는 이름의 파일을 찾고 있다면 그것을 적재합니다. 이렇게 하면 <code>MyPrefix.ahk</code>에 함수 <code>MyPrefix_MyFunc</code>를 다음을 수있고 이름이 <code>MyPrefix_</code>로 시작하는 기타 함수들을 담을 수 있습니다.</p>
<p><span class="ver">[AHK_L 42+]:</span> 지역 라이브러리가 지원됩니다. 먼저 지역 라이브러리를 검색한 다음에 사용자 라이브러리와 표준 라이브러리를 차례로 검색합니다.</p>
<p><code>MyFunc()</code>와 같이 직접 호출 해야만 라이브러리가 자동-포함됩니다. 함수가 예를 들어 타이머나 구이 이벤트 같이, 동적 또는 간접적으로 호출될 때만, 명시적으로 라이브러리를 스크립트에 포함시켜야 합니다. 예를 들어: <code><a href="lib/_Include.htm">#Include</a> &lt;MyFunc&gt;</code></p>
<p>라이브러리 파일은 일반적으로 그의 파일 이름으로 오직 하나의 함수만 담고 있지만, 사적으로 자신만 호출할 함수나 서브루틴을 담을 수도 있습니다. 그렇지만, 그런 함수는 이름이 구별되어야 합니다. 왜냐하면 그것들은 전역 이름공간 안에 여전히 존재할 것이기 때문입니다; 즉, 그것들은 스크립트 어디에서나 호출될 수 있습니다.</p>
<p>라이브러리 파일이 <a href="lib/_Include.htm">#Include</a>를 사용하면, #Include를 위한 작업 디렉토리는 그 라이브러리 파일의 디렉토리입니다. 이를 이용하면 해당 함수와 관련 함수들이 들어 있는 더 큰 라이브러리 파일로 방향전환을 할 수 있습니다.</p>
<p><a href="Scripts.htm#ahk2exe">스크립트 컴파일러 (ahk2exe)</a>도 라이브러리 함수를 지원합니다. 그렇지만, AutoHotkey.exe 사본이 위의 컴파일러 디렉토리에 존재해야 합니다 (보통 그럴 것입니다). AutoHotkey.exe가 없어도, 컴파일러는 여전히 작동하지만, 라이브러리 함수는 자동으로 포함되지 않습니다.</p>
<p>라이브러리로부터 포함된 함수들은 다른 함수와 똑같이 수행됩니다. 왜냐하면 스크립트가 실행되기 전에 미리-적재되기 때문입니다.</p>
<h2 id="BuiltIn">내장 함수</h2>
<p>내장 함수의 매개변수 리스트 끝에 선택적인 매개변수는 완전히 생략해도 좋습니다. 예를 들어, <code>WinExist("Untitled - Notepad")</code>는 유효합니다. 왜냐하면 그의 다른 세 매개변수가 빈 것으로 간주되기 때문입니다.</p>
<p>내장 함수는 스크립트가 자신의 함수를 같은 이름으로 정의하면 오버라이드됩니다. 예를 들어, 스크립트는 자신만의 맞춤 WinExist() 함수를 가질 수 있습니다. 표준 함수 대신에 이 함수가 호출됩니다. 그렇지만, 그렇게 되면 스크립트는 원래 함수를 호출할 방법이 없어져 버립니다.</p>
<p>DLL 파일에 거주하는 외부 함수는 <a href="lib/DllCall.htm">DllCall()</a>으로 호출합니다.</p>
<p>To get more details about a particular built-in function below, simply click on its name.</p>
<h3 id="Frequently-used_Functions">자주-사용되는 함수</h3>
<table class="info">
  <tr>
    <th style="width:150px">함수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="FileExist">
    <td><a href="lib/FileExist.htm">FileExist</a></td>
    <td>Checks for the existence of a file or folder and returns its attributes.</td>
  </tr>
  <tr id="GetKeyState">
    <td><a href="lib/GetKeyState.htm#function">GetKeyState</a></td>
    <td>Returns true (1) if the specified key is down and false (0) if it is up.</td>
  </tr>
  <tr id="InStr">
    <td><a href="lib/InStr.htm">InStr</a></td>
    <td>왼쪽이나 오른쪽으로부터 주어진 문자열이 나타나는지 검색합니다.</td>
  </tr>
  <tr id="RegExMatch">
    <td><a href="lib/RegExMatch.htm">RegExMatch</a></td>
    <td>문자열 안에서 패턴 (정규 표현식)에 부합하는 것들을 찾습니다.</td>
  </tr>
  <tr id="RegExReplace">
    <td><a href="lib/RegExReplace.htm">RegExReplace</a></td>
    <td>문자열 안에서 패턴 (정규 표현식)에 부합하는 것들을 교체합니다.</td>
  </tr>
  <tr id="StrLen">
    <td><a href="lib/StrLen.htm">StrLen</a></td>
    <td>문자열에 들은 문자의 갯수를 열람합니다.</td>
  </tr>
  <tr id="StrReplace">
    <td><a href="lib/StrReplace.htm">StrReplace</a></td>
    <td>Replaces occurrences of the specified substring with a new string.</td>
  </tr>
  <tr id="StrSplit">
    <td><a href="lib/StrSplit.htm">StrSplit</a></td>
    <td>문자열을 지정된 가름자를 사용하여 부분 문자열 배열로 가릅니다.</td>
  </tr>
  <tr id="SubStr">
    <td><a href="lib/SubStr.htm">SubStr</a></td>
    <td>문자열에서 지정된 위치로부터 하나 이상이 문자를 열람합니다.</td>
  </tr>
  <tr id="WinActive">
    <td><a href="lib/WinActive.htm">WinActive</a></td>
    <td>Checks if the specified window is active and returns its unique ID (HWND).</td>
  </tr>
  <tr id="WinExist">
    <td><a href="lib/WinExist.htm">WinExist</a></td>
    <td>Checks if the specified window exists and returns the unique ID (HWND) of the first matching window.</td>
  </tr>
</table>
<h3 id="Miscellaneous_Functions">기타 함수</h3>
<table class="info">
  <tr>
    <th style="width:150px">함수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="Asc">
    <td><a href="lib/Asc.htm">Asc</a></td>
    <td>Returns the numeric value of the first byte or UTF-16 code unit in the specified string.</td>
  </tr>
  <tr id="Chr">
    <td><a href="lib/Chr.htm">Chr</a></td>
    <td>Returns the string (usually a single character) corresponding to the character code indicated by the specified number.</td>
  </tr>
  <tr id="DllCall">
    <td><a href="lib/DllCall.htm">DllCall</a></td>
    <td>표준 Windows API 함수 같이, DLL안의 함수를 호출합니다.</td>
  </tr>
  <tr id="Exception">
    <td><a href="lib/Throw.htm#Exception">Exception</a></td>
    <td>Creates an object which can be used to throw a custom exception.</td>
  </tr>
  <tr id="FileOpen">
    <td><a href="lib/FileOpen.htm">FileOpen</a></td>
    <td>Opens a file to read specific content from it and/or to write new content into it.</td>
  </tr>
  <tr id="Format">
    <td><a href="lib/Format.htm">Format</a></td>
    <td>가변 개수의 입력 값을 형식 문자열에 맞추어 포맷합니다.</td>
  </tr>
  <tr id="Func">
    <td><a href="lib/Func.htm#Func">Func</a></td>
    <td>Retrieves a reference to the specified function.</td>
  </tr>
  <tr id="GetKeyName">
    <td><a href="lib/GetKey.htm">GetKeyName/VK/SC</a></td>
    <td>한 키의 스캔 코드나 가상 코드 또는 이름/텍스트를 열람합니다.</td>
  </tr>
  <tr id="Hotstring">
    <td><a href="lib/Hotstring.htm">Hotstring</a></td>
    <td>Creates, modifies, enables, or disables a hotstring while the script is running.</td>
  </tr>
  <tr id="ImageList">
    <td><a href="lib/ListView.htm#IL">IL_XXX</a></td>
    <td>Functions to add icons/pictures to, create or delete ImageLists used by ListView or TreeView controls.</td>
  </tr>
  <tr id="InputHook">
    <td><a href="lib/InputHook.htm">InputHook</a></td>
    <td>Creates an object which can be used to collect or intercept keyboard input.</td>
  </tr>
  <tr id="IsByRef">
    <td><a href="lib/IsByRef.htm">IsByRef</a></td>
    <td>Returns a non-zero number if the specified <a href="#ByRef">ByRef parameter</a> was supplied with a variable.</td>
  </tr>
  <tr id="IsFunc">
    <td><a href="lib/IsFunc.htm">IsFunc</a></td>
    <td>Returns a non-zero number if the specified function exists in the script.</td>
  </tr>
  <tr id="IsLabel">
    <td><a href="lib/IsLabel.htm">IsLabel</a></td>
    <td>Returns a non-zero number if the specified label exists in the script.</td>
  </tr>
  <tr id="IsObject">
    <td><a href="lib/IsObject.htm">IsObject</a></td>
    <td>Returns a non-zero number if the specified value is an object.</td>
  </tr>
  <tr id="IsSet">
    <td><a href="lib/IsSet.htm">IsSet</a></td>
    <td>Returns a non-zero number if the specified variable has been assigned a value.</td>
  </tr>
  <tr id="LoadPicture">
    <td><a href="lib/LoadPicture.htm">LoadPicture</a></td>
    <td>Loads a picture from file and returns a bitmap or icon handle.</td>
  </tr>
  <tr id="ListView">
    <td><a href="lib/ListView.htm#BuiltIn">LV_XXX</a></td>
    <td>Functions to add, insert, modify or delete ListView rows/colums, or to get data from them.</td>
  </tr>
  <tr id="MenuGetHandle">
    <td><a href="lib/MenuGetHandle.htm">MenuGetHandle</a></td>
    <td>Retrieves the <a href="lib/Menu.htm#Win32_Menus">Win32 menu</a> handle of a menu.</td>
  </tr>
  <tr id="MenuGetName">
    <td><a href="lib/MenuGetName.htm">MenuGetName</a></td>
    <td>Retrieves the name of a menu given a handle to its underlying <a href="lib/Menu.htm#Win32_Menus">Win32 menu</a>.</td>
  </tr>
  <tr id="NumGet">
    <td><a href="lib/NumGet.htm">NumGet</a></td>
    <td>지정된 주소+오프셋에 저장된 이진 숫자를 열람합니다.</td>
  </tr>
  <tr id="NumPut">
    <td><a href="lib/NumPut.htm">NumPut</a></td>
    <td>지정된 주소-오프셋에 이진 형식으로 숫자를 저장합니다.</td>
  </tr>
  <tr id="ObjAddRef">
    <td><a href="lib/ObjAddRef.htm">ObjAddRef / ObjRelease</a></td>
    <td>객체의 <a href="Objects.htm#Reference_Counting">참조 횟수</a>를 줄이거나 늘립니다.</td>
  </tr>
  <tr id="ObjBindMethod">
    <td><a href="lib/ObjBindMethod.htm">ObjBindMethod</a></td>
    <td>주어진 객체의 메쏘드를 호출하는 <a href="misc/Functor.htm#BoundFunc">BoundFunc object</a>를 생성합니다.</td>
  </tr>
  <tr id="ObjGetBase">
    <td><a href="lib/Object.htm#GetBase">ObjGetBase</a></td>
    <td>Retrieves an object's <a href="Objects.htm#Custom_Objects">base object</a>.</td>
  </tr>
  <tr>
    <td><a href="lib/Object.htm#RawGet">ObjRawGet</a></td>
    <td>Retrieves a key-value pair from an object, bypassing the object's <a href="Objects.htm#Meta_Functions">meta-functions</a>.</td>
  </tr>
  <tr>
    <td><a href="lib/Object.htm#RawSet">ObjRawSet</a></td>
    <td>Stores or overwrites a key-value pair in an object, bypassing the object's <a href="Objects.htm#Meta_Functions">meta-functions</a>.</td>
  </tr>
  <tr>
    <td><a href="lib/Object.htm#SetBase">ObjSetBase</a></td>
    <td>Sets an object's <a href="Objects.htm#Custom_Objects">base object</a>.</td>
  </tr>
  <tr id="ObjMethod">
    <td><a href="lib/Object.htm">ObjXXX</a></td>
    <td>Functions equivalent to the built-in methods of the Object type, such as <a href="lib/Object.htm#InsertAt">ObjInsertAt</a>. It is usually recommended to use the corresponding method instead.</td>
  </tr>
  <tr id="OnClipboardChange">
    <td><a href="lib/OnClipboardChange.htm#function">OnClipboardChange</a></td>
    <td>클립보드의 내용이 변경될 때마다 실행될 함수 또는 <a href="misc/Functor.htm">함수 객체</a>를 등록합니다.</td>
  </tr>
  <tr id="OnError">
    <td><a href="lib/OnError.htm">OnError</a></td>
    <td>Specifies a function to run automatically when an unhandled error occurs.</td>
  </tr>
  <tr id="OnExit">
    <td><a href="lib/OnExit.htm#function">OnExit</a></td>
    <td>Specifies a function to run automatically when the script exits.</td>
  </tr>
  <tr id="OnMessage">
    <td><a href="lib/OnMessage.htm">OnMessage</a></td>
    <td>메시지/이벤트를 관제합니다.</td>
  </tr>
  <tr id="Ord">
    <td><a href="lib/Ord.htm">Ord</a></td>
    <td>Returns the ordinal value (numeric character code) of the first character in the specified string.</td>
  </tr>
  <tr id="StatusBar">
    <td><a href="lib/GuiControls.htm#StatusBar_Functions">SB_XXX</a></td>
    <td>Functions to add text/icons to or divide the bar of a StatusBar control.</td>
  </tr>
  <tr id="StrGet">
    <td><a href="lib/StrGet.htm">StrGet</a></td>
    <td>Copies a string from a memory address, optionally converting it between code pages.</td>
  </tr>
  <tr id="StrPut">
    <td><a href="lib/StrPut.htm">StrPut</a></td>
    <td>Copies a string to a memory address, optionally converting it between code pages.</td>
  </tr>
  <tr id="RegisterCallback">
    <td><a href="lib/RegisterCallback.htm">RegisterCallback</a></td>
    <td>머신-코드 주소를 생성합니다. 호출될 때 이 주소를 이용하여 스크립트 안의 함수로 호출을 방향전환 합니다.</td>
  </tr>
  <tr id="Trim">
    <td><a href="lib/Trim.htm">Trim / LTrim / RTrim</a></td>
    <td>문자열의 앞뒤로부터 문자들을 걷어냅니다.</td>
  </tr>
  <tr id="TreeView">
    <td><a href="lib/TreeView.htm#BuiltIn">TV_XXX</a></td>
    <td>Functions to add, modify or delete TreeView items, or to get data from them.</td>
  </tr>
  <tr id="VarSetCapacity">
    <td><a href="lib/VarSetCapacity.htm">VarSetCapacity</a></td>
    <td>변수의 가용 능력을 확대하거나 그의 메모리를 해제합니다.</td>
  </tr>
  <tr id="VerCompare">
    <td><a href="lib/VerCompare.htm">VerCompare</a></td>
    <td>Compares two version strings.</td>
  </tr>
</table>
<h3 id="Math">수학</h3>
<table class="info">
  <tr>
    <th style="width:150px">함수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="Abs">
    <td><a href="lib/Math.htm#Abs">Abs</a></td>
    <td>Returns the absolute value of the specified number.</td>
  </tr>
  <tr id="Ceil">
    <td><a href="lib/Math.htm#Ceil">Ceil</a></td>
    <td>Returns the specified number rounded up to the nearest integer (without any .00 suffix).</td>
  </tr>
  <tr id="Exp">
    <td><a href="lib/Math.htm#Exp">Exp</a></td>
    <td><em>e</em> (대략 2.71828182845905)를 <em>N</em> 만큼 제곱해서 돌려줍니다.</td>
  </tr>
  <tr id="Floor">
    <td><a href="lib/Math.htm#Floor">Floor</a></td>
    <td>Returns the specified number rounded down to the nearest integer (without any .00 suffix).</td>
  </tr>
  <tr id="Log">
    <td><a href="lib/Math.htm#Log">Log</a></td>
    <td>Returns the logarithm (base 10) of the specified number.</td>
  </tr>
  <tr id="Ln">
    <td><a href="lib/Math.htm#Ln">Ln</a></td>
    <td>Returns the natural logarithm (base e) of the specified number.</td>
  </tr>
  <tr>
    <td><span id="Max"></span><span id="Min"></span><a href="lib/Math.htm#Max">Max</a> / <a href="lib/Math.htm#Min">Min</a></td>
    <td>Returns the highest/lowest value of one or more numbers.</td>
  </tr>
  <tr id="Mod">
    <td><a href="lib/Math.htm#Mod">Mod</a></td>
    <td>Returns the remainder of the specified dividend divided by the specified divisor.</td>
  </tr>
  <tr id="Round">
    <td><a href="lib/Math.htm#Round">Round</a></td>
    <td>Returns the specified number rounded to <em>N</em> decimal places.</td>
  </tr>
  <tr id="Sqrt">
    <td><a href="lib/Math.htm#Sqrt">Sqrt</a></td>
    <td>Returns the square root of the specified number.</td>
  </tr>
  <tr>
    <td><span id="Sin"></span><span id="Cos"></span><span id="Tan"></span><a href="lib/Math.htm#Sin">Sin</a> / <a href="lib/Math.htm#Cos">Cos</a> / <a href="lib/Math.htm#Tan">Tan</a></td>
    <td>Returns the trigonometric sine/cosine/tangent of the specified number.</td>
  </tr>
  <tr>
    <td><span id="ASin"></span><span id="ACos"></span><span id="ATan"></span><a href="lib/Math.htm#ASin">ASin</a> / <a href="lib/Math.htm#ACos">ACos</a> / <a href="lib/Math.htm#ATan">ATan</a></td>
    <td>Returns the arcsine/arccosine/arctangent in radians.</td>
  </tr>
</table>

<h3 id="COM">COM</h3>
<table class="info">
  <tr>
    <th style="width:150px">함수</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr id="ComObjActive">
    <td><a href="lib/ComObjActive.htm">ComObjActive</a></td>
    <td>등록된 COM 객체를 열람합니다.</td>
  </tr>
  <tr id="ComObjArray">
    <td><a href="lib/ComObjArray.htm">ComObjArray</a></td>
    <td>COM에 사용하기 위해 SAFEARRAY를 생성합니다.</td>
  </tr>
  <tr id="ComObjConnect">
    <td><a href="lib/ComObjConnect.htm">ComObjConnect</a></td>
    <td>COM 객체의 이벤트를 주어진 접두사를 가진 함수에 연결합니다.</td>
  </tr>
  <tr id="ComObjCreate">
    <td><a href="lib/ComObjCreate.htm">ComObjCreate</a></td>
    <td>COM 객체를 생성합니다.</td>
  </tr>
  <tr id="ComObject">
    <td><a href="lib/ComObjActive.htm">ComObject</a></td>
    <td>매개변수나 반환 값에 건넬 유형 있는 값을 나타내는 객체를 만듭니다.</td>
  </tr>
  <tr id="ComObjEnwrap">
    <td><a href="lib/ComObjActive.htm">ComObjEnwrap / ComObjUnwrap</a></td>
    <td>COM 객체를 포장하거나/풉니다.</td>
  </tr>
  <tr id="ComObjError">
    <td><a href="lib/ComObjError.htm">ComObjError</a></td>
    <td>COM 에러의 고지를 켜고 끕니다.</td>
  </tr>
  <tr id="ComObjFlags">
    <td><a href="lib/ComObjFlags.htm">ComObjFlags</a></td>
    <td>COM 포장 객체의 행위를 제어하는 플래그를 열람하거나 변경합니다.</td>
  </tr>
  <tr id="ComObjGet">
    <td><a href="lib/ComObjGet.htm">ComObjGet</a></td>
    <td>COM 콤포넌트가 제공하는 객체 주소를 돌려줍니다.</td>
  </tr>
  <tr id="ComObjMissing">
    <td><a href="lib/ComObjActive.htm">ComObjMissing</a></td>
    <td>COM 메쏘드에 건넬 "missing parameter" 객체를 만듭니다.</td>
  </tr>
  <tr id="ComObjParameter">
    <td><a href="lib/ComObjActive.htm">ComObjParameter</a></td>
    <td>값과 유형을 싸서 매개변수로 COM 메쏘드에 건넵니다.</td>
  </tr>
  <tr id="ComObjQuery">
    <td><a href="lib/ComObjQuery.htm">ComObjQuery</a></td>
    <td>COM 객체에 인터페이스 또는 서비스를 질의합니다.</td>
  </tr>
  <tr id="ComObjType">
    <td><a href="lib/ComObjType.htm">ComObjType</a></td>
    <td>유형 정보를 COM 객체로부터 열람합니다.</td>
  </tr>
  <tr id="ComObjValue">
    <td><a href="lib/ComObjValue.htm">ComObjValue</a></td>
    <td>COM 포장 객체에 저장된 값이나 포인터를 열람합니다.</td>
  </tr>
</table>

<h3 id="Other_Functions">기타 함수</h3>
<p><a href="https://github.com/polyethene/AutoHotkey-Scripts/blob/master/Functions.ahk">폴리에테네(Polyethene)의 명령어 함수</a>: OutputVar가 있는 AutoHotkey 명령어에 호출 가능한 함수를 제공합니다. 이 라이브러리는 <a href="lib/_Include.htm">#Include</a>를 통하여 스크립트에 포함할 수 있습니다.</p>
</body>
</html>
