<!DOCTYPE HTML>
<html lang="ko">
<head>
<title>List of Keys (Keyboard, Mouse and Joystick) | AutoHotkey</title>
<meta name="description" content="This page lists all mouse buttons, keyboard keys and joystick buttons which can be used for hotkeys and key-specific commands/functions." />
<meta name="keywords" content="keyboard,keys,key,mouse,buttons,button,joystick,create,hotkeys,hotkey,macros">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>List of Keys <span class="headnote">(Keyboard, Mouse and Joystick)</span></h1>
<h2 id="toc">목차</h2>
<ul>
  <li><a href="#mouse">마우스</a>
    <ul>
      <li><a href="#mouse-general">General Buttons</a></li>
      <li><a href="#mouse-advanced">Advanced Buttons</a></li>
      <li><a href="#mouse-wheel">휠</a></li>
    </ul>
  </li>
  <li><a href="#keyboard">키보드</a>
    <ul>
      <li><a href="#general">General Keys</a></li>
      <li><a href="#cursor">Cursor Control Keys</a></li>
      <li><a href="#numpad">Numpad Keys</a></li>
      <li><a href="#function">Function Keys</a></li>
      <li><a href="#modifier">Modifier Keys</a></li>
      <li><a href="#multimedia">Multimedia Keys</a></li>
      <li><a href="#other">Other Keys</a></li>
    </ul>
  </li>
  <li><a href="#Joystick">Joystick</a></li>
  <li><a href="#remote">손에 든 리모콘</a></li>
  <li><a href="#SpecialKeys">특수 키</a></li>
  <li><a href="#IME">CapsLock and IME</a></li>
</ul>

<h2 id="mouse">마우스</h2>
<h3 id="mouse-general">General Buttons</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>LButton</td>
    <td>The left mouse button when used with Send, but the primary mouse button when used with hotkeys. In other words, if the user has swapped the buttons via system settings, <code>LButton::</code> is physically activated by clicking the <strong>right</strong> mouse button, but <code>Send {LButton}</code> performs the same as physically clicking the <strong>left</strong> button. To always perform a logical left click, use <code>Click Left</code> or <code>Send {Click Left}</code>.</td>
  </tr>
  <tr>
    <td>RButton</td>
    <td>The right mouse button when used with Send, but the secondary mouse button when used with hotkeys. In other words, if the user has swapped the buttons via system settings, <code>RButton::</code> is physically activated by clicking the <strong>left</strong> mouse button, but <code>Send {RButton}</code> performs the same as physically clicking the <strong>right</strong> button. To always perform a logical right click, use <code>Click Right</code> or <code>Send {Click Right}</code>.</td>
  </tr>
  <tr>
    <td>MButton</td>
    <td>중간 또는 휠 마우스 버튼</td>
  </tr>
</table>
<h3 id="mouse-advanced">Advanced Buttons</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>XButton1</td>
    <td>4번째 마우스 버튼, 전형적으로 Browser_Back과 같은 기능을 수행합니다.</td>
  </tr>
  <tr>
    <td>XButton2</td>
    <td>5번째 마우스 버튼, 전형적으로 Browser_Forward와 같은 기능을 수행합니다.</td>
  </tr>
</table>
<h3 id="mouse-wheel">휠</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>WheelDown</td>
    <td>휠을 아래로 돌립니다 (가까워지게).</td>
  </tr>
  <tr>
    <td>WheelUp</td>
    <td>휠을 위로 돌립니다 (멀어지게).</td>
  </tr>
  <tr>
    <td>WheelLeft<br>WheelRight</td>
    <td><p><span class="ver">[v1.0.48+]:</span> 좌우로 스크롤합니다.</p>
    <p>윈도우즈 비스타 이상을 요구합니다. These can be <a href="Hotkeys.htm#HWheel">used as hotkeys</a> with some (but not all) mice which have a second wheel or support tilting the wheel to either side. 어떤 경우, 대신에 마우스와 함께 따라오는 드라이버를 사용해야만 이 특징을 제어할 수 있습니다. 특정 마우스와 상관없이, <a href="lib/Send.htm">Send</a>와 <a href="lib/Click.htm">Click</a>을 사용하여 프로그램에서 지원하기만 하면 수평으로 스크롤할 수 있습니다.</p></td>
  </tr>
</table>
<h2 id="keyboard">키보드</h2>
<p class="note"><strong>주의</strong>: 기호와 숫자 키의 이름은 기호나 숫자 키와 같습니다. 예를 들어: b는 <kbd>B</kbd> 키이고 5는 <kbd>5</kbd> 키입니다.</p>
<p>Although any single character can be used as a key name, its meaning (scan code or virtual keycode) depends on the current keyboard layout. Additionally, some special characters may need to be escaped or enclosed in braces, depending on the context. <span class="ver">[v1.1.27+]:</span> The letters a-z or A-Z can be used to refer to the corresponding virtual keycodes (usually vk41-vk5A) even if they are not included in the current keyboard layout.</p>
<h3 id="general">General Keys</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>CapsLock</td>
    <td><kbd>CapsLock</kbd> (caps lock key)
      <p class="warning"><strong>Note:</strong> Windows IME may interfere with the detection and functionality of CapsLock; see <a href="#IME">CapsLock and IME</a> for details.</p>
    </td>
  </tr>
  <tr>
    <td>Space</td>
    <td><kbd>Space</kbd> (스페이스 바)</td>
  </tr>
  <tr>
    <td>Tab</td>
    <td><kbd>Tab</kbd> (탭 키)</td>
  </tr>
  <tr>
    <td>Enter</td>
    <td><kbd>Enter</kbd></td>
  </tr>
  <tr>
    <td>Return</td>
    <td><strong>Deprecated:</strong> Use the synonym <code>Enter</code> instead to reduce ambiguity.</td>
  </tr>
  <tr>
    <td>Escape (또는 Esc)</td>
    <td><kbd>Esc</kbd></td>
  </tr>
  <tr>
    <td>Backspace (또는 BS)</td>
    <td><kbd>Backspace</kbd></td>
  </tr>
</table>
<h3 id="cursor">Cursor Control Keys</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>ScrollLock</td>
    <td><kbd>ScrollLock</kbd> (스크롤 락). While <kbd>Ctrl</kbd> is held down, <kbd>ScrollLock</kbd> produces the key code of <code>CtrlBreak</code>, but can be differentiated from <kbd>Pause</kbd> by scan code.</td>
  </tr>
  <tr>
    <td>Delete (또는 Del)</td>
    <td><kbd>Del</kbd></td>
  </tr>
  <tr>
    <td>Insert (또는 Ins)</td>
    <td><kbd>Ins</kbd></td>
  </tr>
  <tr>
    <td>Home</td>
    <td><kbd>Home</kbd></td>
  </tr>
  <tr>
    <td>End</td>
    <td><kbd>End</kbd></td>
  </tr>
  <tr>
    <td>PgUp</td>
    <td><kbd>PgUp</kbd> (페이지 업 키)</td>
  </tr>
  <tr>
    <td>PgDn</td>
    <td><kbd>PgDn</kbd> (페이지 다운 키)</td>
  </tr>
  <tr>
    <td>Up</td>
    <td><kbd>↑</kbd> (위 화살표 키)</td>
  </tr>
  <tr>
    <td>Down</td>
    <td><kbd>↓</kbd> (아래 화살표 키)</td>
  </tr>
  <tr>
    <td>Left</td>
    <td><kbd>←</kbd> (왼쪽 화살표 키)</td>
  </tr>
  <tr>
    <td>Right</td>
    <td><kbd>→</kbd> (오른쪽 화살표 키)</td>
  </tr>
</table>
<h3 id="numpad">Numpad Keys</h3>
<p>Due to system behavior, the following keys separated by a slash are identified differently depending on whether <kbd>NumLock</kbd> is ON or OFF. If <kbd>NumLock</kbd> is OFF but <kbd>Shift</kbd> is pressed, the system temporarily releases <kbd>Shift</kbd> and acts as though <kbd>NumLock</kbd> is ON.</p>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>Numpad0 / NumpadIns</td><td><kbd>0</kbd> / <kbd>Ins</kbd></td>
  </tr>
  <tr>
    <td>Numpad1 / NumpadEnd</td><td><kbd>1</kbd> / <kbd>End</kbd></td>
  </tr>
  <tr>
    <td>Numpad2 / NumpadDown</td><td><kbd>2</kbd> / <kbd>↓</kbd></td>
  </tr>
  <tr>
    <td>Numpad3 / NumpadPgDn</td><td><kbd>3</kbd> / <kbd>PgDn</kbd></td>
  </tr>
  <tr>
    <td>Numpad4 / NumpadLeft</td><td><kbd>4</kbd> / <kbd>←</kbd></td>
  </tr>
  <tr>
    <td>Numpad5 / NumpadClear</td><td><kbd>5</kbd> / 보통 아무일도 안함</td>
  </tr>
  <tr>
    <td>Numpad6 / NumpadRight</td><td><kbd>6</kbd> / <kbd>→</kbd></td>
  </tr>
  <tr>
    <td>Numpad7 / NumpadHome</td><td><kbd>7</kbd> / <kbd>Home</kbd></td>
  </tr>
  <tr>
    <td>Numpad8 / NumpadUp</td><td><kbd>8</kbd> / <kbd>↑</kbd></td>
  </tr>
  <tr>
    <td>Numpad9 / NumpadPgUp</td><td><kbd>9</kbd> / <kbd>PgUp</kbd></td>
  </tr>
  <tr>
    <td>NumpadDot / NumpadDel</td><td><kbd>.</kbd> / <kbd>Del</kbd></td>
  </tr>
  <tr>
    <td>NumLock</td>
    <td><kbd>NumLock</kbd> (number lock key). While <kbd>Ctrl</kbd> is held down, <kbd>NumLock</kbd> produces the key code of <code>Pause</code>, so use <code>^Pause</code> in hotkeys instead of <code>^NumLock</code>.</td>
  </tr>
  <tr>
    <td>NumpadDiv</td>
    <td><kbd>/</kbd> (나눗셈)</td>
  </tr>
  <tr>
    <td>NumpadMult</td>
    <td><kbd>*</kbd> (곱셈)</td>
  </tr>
  <tr>
    <td>NumpadAdd</td>
    <td><kbd>+</kbd> (덧셈)</td>
  </tr>
  <tr>
    <td>NumpadSub</td>
    <td><kbd>-</kbd> (뺄셈)</td>
  </tr>
  <tr>
    <td>NumpadEnter</td>
    <td><kbd>Enter</kbd></td>
  </tr>
</table>
<h3 id="function">Function Keys</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>F1 - F24</td>
    <td>대부분의 키보드 상단에 있는 12 개 이상의 기능키.</td>
  </tr>
</table>
<h3 id="modifier">Modifier Keys</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>LWin</td>
    <td>왼쪽 <kbd>Win</kbd>. <code>&lt;#</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>RWin</td>
    <td>
      <p>오른쪽 <kbd>Win</kbd>. <code>&gt;#</code> 핫키 접두 심볼에 상응합니다.</p>
      <p class="note"><strong>주의</strong>: <kbd>Ctrl</kbd>/<kbd>Alt</kbd>/<kbd>Shift</kbd>와 다르게, 범용의/중립적 "Win" 키는 없습니다. OS가 지원하지 않습니다. 그렇지만, <code>#</code> 수식키를 가진 핫키는 어느쪽 <kbd>Win</kbd> 키로도 촉발됩니다.</p>
    </td>
  </tr>
  <tr>
    <td>Control (또는 Ctrl)</td>
    <td><kbd>Ctrl</kbd>. 핫키처럼 (<code>Control::</code>) 틸드 접두 심볼이 붙지 않은 한, 뗄 때 촉발됩니다. <code>^</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>Alt</td>
    <td><kbd>Alt</kbd>. 핫키처럼 (<code>Alt::</code>) 틸드 접두 심볼이 붙지 않는 한, 뗄 때 촉발됩니다. <code>!</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>Shift</td>
    <td><kbd>Shift</kbd>. 핫키처럼 (<code>Shift::</code>) 틸드 접두 심볼이 붙지 않는 한, 뗄 때 촉발됩니다. <code>+</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>LControl (또는 LCtrl)</td>
    <td>왼쪽 <kbd>Ctrl</kbd>. <code>&lt;^</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>RControl (또는 RCtrl)</td>
    <td>오른쪽 <kbd>Ctrl</kbd>. <code>&gt;^</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>LShift</td>
    <td>왼쪽 <kbd>Shift</kbd>. <code>&lt;+</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>RShift</td>
    <td>오른쪽 <kbd>Shift</kbd>. <code>&gt;+</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>LAlt</td>
    <td>왼쪽 <kbd>Alt</kbd>. <code>&lt;!</code> 핫키 접두 심볼에 상응합니다.</td>
  </tr>
  <tr>
    <td>RAlt</td>
    <td>
      <p>오른쪽 <kbd>Alt</kbd>. <code>&gt;!</code> 핫키 접두 심볼에 상응합니다.</p>
      <p class="note"><strong>주의</strong>: 키보드 레이아웃에 RAlt 대신 AltGr이 있다면, 그것을 핫키로 사용할 수 있습니다. <a href="Hotkeys.htm#AltGr">다음</a>에 기술하는 바와 같이 <code>&lt;^&gt;!</code>처럼 접두 심볼 처리를 해 주면 됩니다. 게다가, <code>LControl &amp; RAlt::</code>은 AltGr 자체를 핫키로 만들어 줍니다.</p>
    </td>
  </tr>
</table>
<h3 id="multimedia">Multimedia Keys</h3>
<p>The function assigned to each of the keys listed below can be overridden by modifying the Windows registry. 다음 테이블은 대부분의 윈도우즈 버전에서 각 키의 기본 기능을 보여줍니다.</p>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>Browser_Back</td>
    <td>뒤로</td>
  </tr>
  <tr>
    <td>Browser_Forward</td>
    <td>앞으로</td>
  </tr>
  <tr>
    <td>Browser_Refresh</td>
    <td>갱신</td>
  </tr>
  <tr>
    <td>Browser_Stop</td>
    <td>멈춤</td>
  </tr>
  <tr>
    <td>Browser_Search</td>
    <td>검색</td>
  </tr>
  <tr>
    <td>Browser_Favorites</td>
    <td>즐겨찾기</td>
  </tr>
  <tr>
    <td>Browser_Home</td>
    <td>홈페이지</td>
  </tr>
  <tr>
    <td>Volume_Mute</td>
    <td>음소거</td>
  </tr>
  <tr>
    <td>Volume_Down</td>
    <td>소리 줄이기</td>
  </tr>
  <tr>
    <td>Volume_Up</td>
    <td>소리 높이기</td>
  </tr>
  <tr>
    <td>Media_Next</td>
    <td>다음 트랙</td>
  </tr>
  <tr>
    <td>Media_Prev</td>
    <td>이전 트랙</td>
  </tr>
  <tr>
    <td>Media_Stop</td>
    <td>멈춤</td>
  </tr>
  <tr>
    <td>Media_Play_Pause</td>
    <td>연주/정지</td>
  </tr>
  <tr>
    <td>Launch_Mail</td>
    <td>기본 이메일 프로그램 기동</td>
  </tr>
  <tr>
    <td>Launch_Media</td>
    <td>기본 미디어 플레이어 기동</td>
  </tr>
  <tr>
    <td>Launch_App1</td>
    <td>내 컴퓨터 기동</td>
  </tr>
  <tr>
    <td>Launch_App2</td>
    <td>계산기 기동</td>
  </tr>
</table>
<h3 id="other">Other Keys</h3>
<table class="info">
  <tr>
    <th style="width:12em">Name</th>
    <th abbr="설명">설명</th>
  </tr>
  <tr>
    <td>AppsKey</td>
    <td><kbd>Menu</kbd>. 이 키는 우클릭 문맥 메뉴를 요청합니다.</td>
  </tr>
  <tr>
    <td>PrintScreen</td>
    <td><kbd>PrtSc</kbd> (화면 인쇄)</td>
  </tr>
  <tr>
    <td>CtrlBreak</td>
    <td><kbd>Ctrl</kbd>+<kbd>Pause</kbd> or <kbd>Ctrl</kbd>+<kbd>ScrollLock</kbd></td>
  </tr>
  <tr>
    <td>Pause</td>
    <td><kbd>Pause</kbd> or <kbd>Ctrl</kbd>+<kbd>NumLock</kbd>. While <kbd>Ctrl</kbd> is held down, <kbd>Pause</kbd> produces the key code of <code>CtrlBreak</code> and <kbd>NumLock</kbd> produces <code>Pause</code>, so use <code>^CtrlBreak</code> in hotkeys instead of <code>^Pause</code>.</td>
  </tr>
  <tr>
    <td>Break</td>
    <td><strong>Deprecated:</strong> Use the synonym <code>Pause</code> instead.</td>
  </tr>
  <tr>
    <td>Help</td>
    <td><kbd>Help</kbd>. 이 키는 보통 대부분의 키보드에 존재하지 않습니다. 보통 <kbd>F1</kbd>과 같지 않습니다.</td>
  </tr>
  <tr>
    <td>Sleep</td>
    <td><kbd>Sleep</kbd>. 어떤 키보드에서 수면 키는 잘 작동하지 않을 수 있습니다.</td>
  </tr>
  <tr id="sc">
    <td>SC<b>nnn</b></td>
    <td><b>nnn</b>에 키의 스캔 코드를 지정합니다. 위에 언급하지 않은 비정상 키들을 인식합니다. 자세한 것은 <a href="#SpecialKeys">특수 키</a>를 참조하십시오.</td>
  </tr>
  <tr id="vk">
    <td >VK<b>nn</b></td>
    <td><p><b>nn</b>에 키의 십육진 가상 키 코드를 지정합니다. 자주 사용되지 않는 이 방법은 어떤 유형의 <a href="Hotkeys.htm">핫키</a>가 <a href="lib/_InstallKeybdHook.htm">키보드 갈고리</a>를 요구하는 것을 방해할 수도 있습니다. 예를 들어, 다음 핫키들은 키보드 갈고리를 사용하지 않지만, 부작용으로서 <kbd>Home</kbd> <em>또는</em> NumpadHome을 누르면 촉발됩니다:</p>
      <pre>^VK24::MsgBox Control 키를 누른 채로 Home 또는 NumpadHome를 눌렀습니다.
</pre>
      <p><strong>알려진 한계:</strong> VK 핫키가 <a href="lib/_InstallKeybdHook.htm">키보드 갈고리</a>를 사용하도록 강제되어 있으면, <code>*VK24</code>이나 <code>~VK24</code>와 같이, 두 키가 아니라 둘 중에 하나의 키에만 촉발됩니다 (예, NumpadHome에 촉발되면 <kbd>Home</kbd>은 촉발되지 않음). VKnn 메쏘드에 관한 더 자세한 정보는 <a href="#SpecialKeys">특수 키</a>를 참조합니다.</p>
      <p class="warning"><strong>Warning:</strong> Only <a href="lib/Send.htm">Send</a>, <a href="lib/GetKey.htm">GetKeyName()</a>, <a href="lib/GetKey.htm">GetKeyVK()</a>, <a href="lib/GetKey.htm">GetKeySC()</a> and <a href="lib/_MenuMaskKey.htm">#MenuMaskKey</a> support combining VKnn and SCnnn. <span class="ver">[v1.1.27+]:</span> The presence of an invalid suffix prevents VKnn from being recognized. For example, <code>vk1Bsc001::</code> raises an error in v1.1.27+, but <code>sc001</code> was ignored (had no effect) in previous versions.</p>
      </td>
  </tr>
</table>
<h2 id="Joystick">Joystick</h2>
<p><strong>Joy1 through Joy32</strong>: 조이스틱의 버튼. <a href="scripts/index.htm#JoystickTest">다음 테스트 스크립트</a>를 사용하면 여러분이 보유한 조이스틱의 버튼 개수를 알 수 있습니다. ^ (control) 그리고 + (shift) 같은 <a href="Hotkeys.htm">핫키 접두 심볼</a>은 지원하지 않습니다 (그렇지만 <a href="lib/GetKeyState.htm#function">GetKeyState()</a>을 대안으로 사용할 수 있습니다). 조이스틱 버튼을 누른다고 해서 언제나 활성창으로 "뚫고 들어가는" 것은 아니라는 사실을 주의하십시오. 그 창이 조이스틱 버튼 누름을 탐지하도록 설계되어 있다면 침투하지 못할 수 있습니다.</p>
<p>다음 조이스틱 콘트롤 이름은 핫키로 사용할 수 없지만, <a href="lib/GetKeyState.htm#function">GetKeyState()</a>와 함께 사용할 수 있습니다:</p>
<ul>
  <li><strong>JoyX, JoyY, and JoyZ</strong>: 조이스틱의 X (수평), Y (수직), 그리고 Z (고도/깊이) 축.</li>
  <li><strong>JoyR</strong>: 조이스틱의 러더 또는 4 번째 축.</li>
  <li><strong>JoyU and JoyV</strong>: 조이스틱의 5번째 6 번째 축.</li>
  <li><strong>JoyPOV</strong>: The point-of-view (hat) control.</li>
  <li><strong>JoyName</strong>: 조이스틱 또는 조이스틱 드라이버의 이름.</li>
  <li><strong>JoyButtons</strong>: 조이스틱이 지원하는 버튼의 개수 (언제나 정확한 것은 아님).</li>
  <li><strong>JoyAxes</strong>: 조이스틱이 지원하는 축의 개수.</li>
  <li><strong>JoyInfo</strong>: 다음 기호로 구성되는 문자열을 제공합니다. 조이스틱이 갖춘 능력을 알려줍니다: <strong>Z</strong> (Z 축), <strong>R</strong> (R 축), <strong>U</strong> (U 축), <strong>V</strong> (V 축), <strong>P</strong> (POV 콘트롤), <strong>D</strong> (POV 콘트롤은 이산적으로 설정됩니다), <strong>C</strong> (POV 콘트롤은 연속적으로 설정됩니다). 예제 문자열: ZRUVPD</li>
</ul>
<p><strong>다중 조이스틱</strong>: 컴퓨터에 여러 조이스틱이 있고 첫 번째 마우스 말고도 다른 조이스틱을 사용하고 싶다면, 조이스틱 번호를 (최대 16) 컨트롤 이름 앞에 붙이십시오. 예를 들어, 2joy1은 두 번째 조이스틱의 첫 번째 버튼입니다.</p>
<p class="note"><strong>주의</strong>: 스크립트에게 조이스틱을 인식시키지 못하고 있다면, 어떤 보고에 의하면 조이스틱 번호를 1말고 다른 번호를 지정할 필요가 있다고 합니다. 오직 하나의 조이스틱만 있다고 할지라도 말입니다. 어떻게 이런 상황이 일어나는지 그리고 그것이 정상인 것인지는 잘 모르지만, <a href="scripts/index.htm#JoystickTest">조이스틱 테스트 스크립트</a>에서 조이스틱 번호를 가지고 실험해 보면 이 방법이 여러분의 시스템에 적용이 될지 알 수 있을 것입니다.</p>
<p><strong>다음도 참조하십시오</strong>:</p>
<ul>
  <li><a href="misc/RemapJoystick.htm">조이스틱 리맵핑:</a> 조이스틱으로 키눌림과 마우스 클릭을 전송하는 방법.</li>
  <li><a href="scripts/index.htm#JoystickMouse">Joystick-To-Mouse 스크립트</a>: 조이스틱을 마우스로 사용하기.</li>
</ul>

<h2 id="remote">손에 든 리모콘</h2>
<p>손에 든 리모콘으로부터의 신호에 반응합니다. <a href="scripts/index.htm#WinLIRC">WinLIRC 클라이언트 스크립트</a>를 사용하십시오.</p>
<h2 id="SpecialKeys">특수 키</h2>
<p>키보드나 마우스에 위에 나열된 키가 없더라도, 핫키로 사용할 수 있습니다. 다음 단계를 따르십시오:</p>
<ol>
  <li>적어도 하나의 스크립트는 <a href="lib/_InstallKeybdHook.htm">키보드 갈고리</a>를 사용하여 실행 중임을 확인합니다. 스크립트에 키보드 갈고리가 설치되어 있는지 확인하려면 메인 창을 열고 메뉴바에서 "View-&gt;<a href="lib/KeyHistory.htm">Key history</a>"를 선택해 보면 됩니다.</li>
  <li>스크립트의 트레이 아이콘을 더블클릭하여 메인 창을 엽니다.</li>
  <li>키보드에서 "미스테리 키"중 하나를 누릅니다.</li>
  <li>메뉴 항목 "View-&gt;<a href="lib/KeyHistory.htm">Key history</a>"를 선택합니다.</li>
  <li>페이지 아래로 감아 내립니다. 아래 어딘가에 누른 키에 대한 키-누름 그리고 키-뗌 이벤트가 있을 겁니다. 주의: 어떤 키는 이벤트를 발생시키지 않습니다 그리하여 여기에서 보이지 않습니다. 이럴 경우라면 직접적으로 그 특정한 키를 핫키로 만들 수 없습니다. 왜냐하면 키보드 드라이버나 하드웨어가 너무 아래 레벨에서 처리하고 있어서 오토핫키가 접근할 수 없기 때문입니다. 가능한 해결책은, 더 아래를 보십시오.</li>
  <li>키를 탐지할 수 있으면, 리스트의 두 번째 컬럼에 세 자리 십육진 값을 적습니다 (예, <strong>159</strong>).</li>
  <li>이 키를 핫키로 정의하려면, 다음 예를 따르십시오:
<pre><strong>SC159::</strong> <em>; 159를 키 값으로 교체하십시오.</em>
MsgBox, %A_ThisHotkey% was pressed.
return</pre></li>
</ol>
<p><strong>역 방향</strong>: 다른 키를 "미지의 키"가 <em>되도록</em> 리맵하려면, 다음 예제를 따르십시오:</p>
<pre><em>; 159를 위에서 발견한 값과 교체합니다. (필요하면) FF를 가상 키로 교체합니다.
; 가상 키 코드는 Key History 화면의 첫 컬럼에서 발견할 수 있습니다.</em>
#c::Send {vkFFsc159} <em>; See <a href="lib/Send.htm#vk">Send {vkXXscYYY}</a> for more details.</em></pre>
<p><strong>또다른 해결책</strong>: 키나 마우스 버튼을 <a href="lib/KeyHistory.htm">Key History</a> 화면에서 탐지할 수 없으면, 다음 중 하나를 시도해 보면 도움이 될 것입니다:</p>
<ol>
  <li>
    <p>마우스나 키보드에 함께 따라오는 소프트웨어의 환경을 재구성하면 (종종 제어판이나 시작 메뉴를 통하여 접근할 수 있습니다) "미지의 키"가 다른 키눌림을 전송하도록 만들 수 있습니다. 그런 키눌림은 스크립트에서 핫키로 정의할 수 있습니다. 예를 들어, 미지의 키가 <kbd>Ctrl</kbd>+<kbd>F1</kbd>을 전송하도록 구성했다면, 스크립트에서 <code>^F1::</code>을 사용해 간접적으로 그 키를 핫키로 만들 수 있습니다.</p>
  </li>
  <li>
    <p>Try <a href="https://www.autohotkey.com/board/topic/38015-ahkhid-an-ahk-implementation-of-the-hid-functions/">AHKHID</a>. You can also try searching the <a href="https://www.autohotkey.com/boards/">forum</a> for a keywords like <code>RawInput*</code>, <code>USB HID</code> or <code>AHKHID</code>.</p>
  </li>
  <li>
    <p>다음은 마지막 의존책입니다. 일반적으로 절망적일 경우에만 시도하십시오. 성공의 가능성이 매우 낮고 원하지 않는 부작용을 야기해 다시 돌이킬 수 없을 수도 있기 때문입니다:<br>
      키보드나 마우스에 따라오는 소프트웨어를 제거합니다. 또는 드라이버를 보다 표준적인 드라이버 예를 들어 OS에 내장된 드라이버로 교체합니다. 성공한 한다면 여러분의 전용 드라이버가 제공하는 특징이 없더라도 살아갈 수 있다는 확신을 가질 수 있습니다.</p>
  </li>
</ol>

<h2 id="IME">CapsLock and IME</h2>
<p>Some configurations of Windows IME (such as Japanese input with English keyboard) use CapsLock to toggle between modes. In such cases, CapsLock is suppressed by the IME and cannot be detected by AutoHotkey. However, the <kbd>Alt</kbd>+<kbd>CapsLock</kbd>, <kbd>Ctrl</kbd>+<kbd>CapsLock</kbd> and <kbd>Shift</kbd>+<kbd>CapsLock</kbd> shortcuts can be disabled with a workaround. Specifically, send a key-up to modify the state of the IME, but prevent any other effects by signalling the keyboard hook to suppress the event. The following function can be used for this purpose:</p>
<pre filename="SendSuppressedKeyUp.ahk">
<em>; Requires AutoHotkey v1.1.26+, and the keyboard hook must be installed.</em>
#InstallKeybdHook
SendSuppressedKeyUp(key) {
    DllCall("keybd_event"
        , "char", GetKeyVK(key)
        , "char", GetKeySC(key)
        , "uint", KEYEVENTF_KEYUP := 0x2
        , "uptr", KEY_BLOCK_THIS := 0xFFC3D450)
}
</pre>
<p>After copying the function into a script or saving it as <em>SendSuppressedKeyUp.ahk</em> in a <a href="Functions.htm#lib">function library</a>, it can be used as follows:</p>
<pre>
<em>; Disable Alt+key shortcuts for the IME.</em>
~LAlt::SendSuppressedKeyUp("LAlt")

<em>; Test hotkey:</em>
!CapsLock::MsgBox % A_ThisHotkey

<em>; Remap CapsLock to LCtrl in a way compatible with IME.</em>
*CapsLock::
    Send {Blind}{LCtrl DownR}
    SendSuppressedKeyUp("LCtrl")
    return
*CapsLock up::
    Send {Blind}{LCtrl Up}
    return
</pre>

</body>
</html>
